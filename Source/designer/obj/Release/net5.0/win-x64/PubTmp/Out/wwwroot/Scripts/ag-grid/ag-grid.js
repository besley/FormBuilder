// ag-grid v7.0.2
(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["agGrid"] = factory();
	else
		root["agGrid"] = factory();
})(this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	
	////////// MAKE SURE YOU EDIT main-webpack.js IF EDITING THIS FILE!!!

	var populateClientExports = __webpack_require__(1).populateClientExports;
	populateClientExports(exports);


/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
	 * @version v7.0.2
	 * @link http://www.ag-grid.com/
	 * @license MIT
	 */
	var grid_1 = __webpack_require__(2);
	var gridApi_1 = __webpack_require__(11);
	var events_1 = __webpack_require__(10);
	var componentUtil_1 = __webpack_require__(9);
	var columnController_1 = __webpack_require__(13);
	var agGridNg1_1 = __webpack_require__(94);
	var agGridWebComponent_1 = __webpack_require__(95);
	var gridCell_1 = __webpack_require__(33);
	var rowNode_1 = __webpack_require__(27);
	var originalColumnGroup_1 = __webpack_require__(17);
	var columnGroup_1 = __webpack_require__(14);
	var column_1 = __webpack_require__(15);
	var focusedCellController_1 = __webpack_require__(35);
	var functions_1 = __webpack_require__(81);
	var gridOptionsWrapper_1 = __webpack_require__(3);
	var balancedColumnTreeBuilder_1 = __webpack_require__(19);
	var columnKeyCreator_1 = __webpack_require__(20);
	var columnUtils_1 = __webpack_require__(16);
	var displayedGroupCreator_1 = __webpack_require__(21);
	var groupInstanceIdCreator_1 = __webpack_require__(80);
	var context_1 = __webpack_require__(6);
	var dragAndDropService_1 = __webpack_require__(68);
	var dragService_1 = __webpack_require__(31);
	var filterManager_1 = __webpack_require__(43);
	var numberFilter_1 = __webpack_require__(46);
	var textFilter_1 = __webpack_require__(45);
	var gridPanel_1 = __webpack_require__(24);
	var mouseEventService_1 = __webpack_require__(32);
	var cssClassApplier_1 = __webpack_require__(72);
	var headerContainer_1 = __webpack_require__(67);
	var headerRenderer_1 = __webpack_require__(66);
	var headerTemplateLoader_1 = __webpack_require__(75);
	var horizontalDragService_1 = __webpack_require__(71);
	var moveColumnController_1 = __webpack_require__(77);
	var renderedHeaderCell_1 = __webpack_require__(74);
	var renderedHeaderGroupCell_1 = __webpack_require__(70);
	var standardMenu_1 = __webpack_require__(82);
	var borderLayout_1 = __webpack_require__(30);
	var tabbedLayout_1 = __webpack_require__(96);
	var verticalStack_1 = __webpack_require__(97);
	var autoWidthCalculator_1 = __webpack_require__(22);
	var renderedRow_1 = __webpack_require__(37);
	var rowRenderer_1 = __webpack_require__(23);
	var filterStage_1 = __webpack_require__(83);
	var flattenStage_1 = __webpack_require__(85);
	var sortStage_1 = __webpack_require__(84);
	var floatingRowModel_1 = __webpack_require__(26);
	var paginationController_1 = __webpack_require__(41);
	var component_1 = __webpack_require__(47);
	var cellNavigationService_1 = __webpack_require__(65);
	var columnChangeEvent_1 = __webpack_require__(79);
	var constants_1 = __webpack_require__(8);
	var csvCreator_1 = __webpack_require__(12);
	var eventService_1 = __webpack_require__(4);
	var expressionService_1 = __webpack_require__(18);
	var gridCore_1 = __webpack_require__(40);
	var logger_1 = __webpack_require__(5);
	var masterSlaveService_1 = __webpack_require__(25);
	var selectionController_1 = __webpack_require__(28);
	var sortController_1 = __webpack_require__(42);
	var svgFactory_1 = __webpack_require__(59);
	var templateService_1 = __webpack_require__(36);
	var utils_1 = __webpack_require__(7);
	var valueService_1 = __webpack_require__(29);
	var popupService_1 = __webpack_require__(44);
	var gridRow_1 = __webpack_require__(34);
	var inMemoryRowModel_1 = __webpack_require__(89);
	var virtualPageRowModel_1 = __webpack_require__(86);
	var animateSlideCellRenderer_1 = __webpack_require__(56);
	var cellEditorFactory_1 = __webpack_require__(48);
	var popupEditorWrapper_1 = __webpack_require__(51);
	var popupSelectCellEditor_1 = __webpack_require__(53);
	var popupTextCellEditor_1 = __webpack_require__(52);
	var selectCellEditor_1 = __webpack_require__(50);
	var textCellEditor_1 = __webpack_require__(49);
	var largeTextCellEditor_1 = __webpack_require__(54);
	var cellRendererFactory_1 = __webpack_require__(55);
	var groupCellRenderer_1 = __webpack_require__(58);
	var cellRendererService_1 = __webpack_require__(60);
	var valueFormatterService_1 = __webpack_require__(61);
	var checkboxSelectionComponent_1 = __webpack_require__(62);
	var componentAnnotations_1 = __webpack_require__(92);
	var agCheckbox_1 = __webpack_require__(91);
	var bodyDropPivotTarget_1 = __webpack_require__(78);
	var bodyDropTarget_1 = __webpack_require__(76);
	var focusService_1 = __webpack_require__(39);
	var setLeftFeature_1 = __webpack_require__(63);
	var renderedCell_1 = __webpack_require__(38);
	var headerRowComp_1 = __webpack_require__(69);
	var animateShowChangeCellRenderer_1 = __webpack_require__(57);
	var inMemoryNodeManager_1 = __webpack_require__(90);
	var virtualPageCache_1 = __webpack_require__(87);
	var virtualPage_1 = __webpack_require__(88);
	var baseFrameworkFactory_1 = __webpack_require__(93);
	var methodNotImplementedException_1 = __webpack_require__(64);
	var touchListener_1 = __webpack_require__(73);
	function populateClientExports(exports) {
	    // columnController
	    exports.BalancedColumnTreeBuilder = balancedColumnTreeBuilder_1.BalancedColumnTreeBuilder;
	    exports.ColumnController = columnController_1.ColumnController;
	    exports.ColumnKeyCreator = columnKeyCreator_1.ColumnKeyCreator;
	    exports.ColumnUtils = columnUtils_1.ColumnUtils;
	    exports.DisplayedGroupCreator = displayedGroupCreator_1.DisplayedGroupCreator;
	    exports.GroupInstanceIdCreator = groupInstanceIdCreator_1.GroupInstanceIdCreator;
	    // components
	    exports.ComponentUtil = componentUtil_1.ComponentUtil;
	    exports.initialiseAgGridWithAngular1 = agGridNg1_1.initialiseAgGridWithAngular1;
	    exports.initialiseAgGridWithWebComponents = agGridWebComponent_1.initialiseAgGridWithWebComponents;
	    // context
	    exports.Context = context_1.Context;
	    exports.Autowired = context_1.Autowired;
	    exports.PostConstruct = context_1.PostConstruct;
	    exports.PreDestroy = context_1.PreDestroy;
	    exports.Optional = context_1.Optional;
	    exports.Bean = context_1.Bean;
	    exports.Qualifier = context_1.Qualifier;
	    exports.Listener = componentAnnotations_1.Listener;
	    exports.QuerySelector = componentAnnotations_1.QuerySelector;
	    // dragAndDrop
	    exports.HDirection = dragAndDropService_1.HDirection;
	    exports.VDirection = dragAndDropService_1.VDirection;
	    exports.DragAndDropService = dragAndDropService_1.DragAndDropService;
	    exports.DragService = dragService_1.DragService;
	    exports.DragSourceType = dragAndDropService_1.DragSourceType;
	    // entities
	    exports.Column = column_1.Column;
	    exports.ColumnGroup = columnGroup_1.ColumnGroup;
	    exports.GridCell = gridCell_1.GridCell;
	    exports.GridRow = gridRow_1.GridRow;
	    exports.OriginalColumnGroup = originalColumnGroup_1.OriginalColumnGroup;
	    exports.RowNode = rowNode_1.RowNode;
	    // filter
	    exports.FilterManager = filterManager_1.FilterManager;
	    exports.NumberFilter = numberFilter_1.NumberFilter;
	    exports.TextFilter = textFilter_1.TextFilter;
	    // gridPanel
	    exports.GridPanel = gridPanel_1.GridPanel;
	    exports.MouseEventService = mouseEventService_1.MouseEventService;
	    // headerRendering
	    exports.BodyDropPivotTarget = bodyDropPivotTarget_1.BodyDropPivotTarget;
	    exports.BodyDropTarget = bodyDropTarget_1.BodyDropTarget;
	    exports.CssClassApplier = cssClassApplier_1.CssClassApplier;
	    exports.HeaderContainer = headerContainer_1.HeaderContainer;
	    exports.HeaderRenderer = headerRenderer_1.HeaderRenderer;
	    exports.HeaderRowComp = headerRowComp_1.HeaderRowComp;
	    exports.HeaderTemplateLoader = headerTemplateLoader_1.HeaderTemplateLoader;
	    exports.HorizontalDragService = horizontalDragService_1.HorizontalDragService;
	    exports.MoveColumnController = moveColumnController_1.MoveColumnController;
	    exports.RenderedHeaderCell = renderedHeaderCell_1.RenderedHeaderCell;
	    exports.RenderedHeaderGroupCell = renderedHeaderGroupCell_1.RenderedHeaderGroupCell;
	    exports.StandardMenuFactory = standardMenu_1.StandardMenuFactory;
	    // layout
	    exports.BorderLayout = borderLayout_1.BorderLayout;
	    exports.TabbedLayout = tabbedLayout_1.TabbedLayout;
	    exports.VerticalStack = verticalStack_1.VerticalStack;
	    // misc
	    exports.FocusService = focusService_1.FocusService;
	    exports.MethodNotImplementedException = methodNotImplementedException_1.MethodNotImplementedException;
	    // rendering / cellEditors
	    exports.LargeTextCellEditor = largeTextCellEditor_1.LargeTextCellEditor;
	    exports.PopupEditorWrapper = popupEditorWrapper_1.PopupEditorWrapper;
	    exports.PopupSelectCellEditor = popupSelectCellEditor_1.PopupSelectCellEditor;
	    exports.PopupTextCellEditor = popupTextCellEditor_1.PopupTextCellEditor;
	    exports.SelectCellEditor = selectCellEditor_1.SelectCellEditor;
	    exports.TextCellEditor = textCellEditor_1.TextCellEditor;
	    // rendering / cellRenderers
	    exports.AnimateShowChangeCellRenderer = animateShowChangeCellRenderer_1.AnimateShowChangeCellRenderer;
	    exports.AnimateSlideCellRenderer = animateSlideCellRenderer_1.AnimateSlideCellRenderer;
	    exports.GroupCellRenderer = groupCellRenderer_1.GroupCellRenderer;
	    // features
	    exports.SetLeftFeature = setLeftFeature_1.SetLeftFeature;
	    // rendering
	    exports.AutoWidthCalculator = autoWidthCalculator_1.AutoWidthCalculator;
	    exports.CellEditorFactory = cellEditorFactory_1.CellEditorFactory;
	    exports.RenderedHeaderCell = renderedHeaderCell_1.RenderedHeaderCell;
	    exports.CellRendererFactory = cellRendererFactory_1.CellRendererFactory;
	    exports.CellRendererService = cellRendererService_1.CellRendererService;
	    exports.CheckboxSelectionComponent = checkboxSelectionComponent_1.CheckboxSelectionComponent;
	    exports.RenderedCell = renderedCell_1.RenderedCell;
	    exports.RenderedRow = renderedRow_1.RenderedRow;
	    exports.RowRenderer = rowRenderer_1.RowRenderer;
	    exports.ValueFormatterService = valueFormatterService_1.ValueFormatterService;
	    // rowControllers/inMemory
	    exports.FilterStage = filterStage_1.FilterStage;
	    exports.FlattenStage = flattenStage_1.FlattenStage;
	    exports.InMemoryRowModel = inMemoryRowModel_1.InMemoryRowModel;
	    exports.SortStage = sortStage_1.SortStage;
	    exports.InMemoryNodeManager = inMemoryNodeManager_1.InMemoryNodeManager;
	    // rowControllers
	    exports.FloatingRowModel = floatingRowModel_1.FloatingRowModel;
	    exports.PaginationController = paginationController_1.PaginationController;
	    exports.VirtualPageRowModel = virtualPageRowModel_1.VirtualPageRowModel;
	    exports.VirtualPageCache = virtualPageCache_1.VirtualPageCache;
	    exports.VirtualPage = virtualPage_1.VirtualPage;
	    // widgets
	    exports.AgCheckbox = agCheckbox_1.AgCheckbox;
	    exports.Component = component_1.Component;
	    exports.PopupService = popupService_1.PopupService;
	    exports.Listener = componentAnnotations_1.Listener;
	    exports.QuerySelector = componentAnnotations_1.QuerySelector;
	    exports.TouchListener = touchListener_1.TouchListener;
	    // root
	    exports.BaseFrameworkFactory = baseFrameworkFactory_1.BaseFrameworkFactory;
	    exports.CellNavigationService = cellNavigationService_1.CellNavigationService;
	    exports.ColumnChangeEvent = columnChangeEvent_1.ColumnChangeEvent;
	    exports.Constants = constants_1.Constants;
	    exports.CsvCreator = csvCreator_1.CsvCreator;
	    exports.Events = events_1.Events;
	    exports.EventService = eventService_1.EventService;
	    exports.ExpressionService = expressionService_1.ExpressionService;
	    exports.FocusedCellController = focusedCellController_1.FocusedCellController;
	    exports.defaultGroupComparator = functions_1.defaultGroupComparator;
	    exports.Grid = grid_1.Grid;
	    exports.GridApi = gridApi_1.GridApi;
	    exports.GridCore = gridCore_1.GridCore;
	    exports.GridOptionsWrapper = gridOptionsWrapper_1.GridOptionsWrapper;
	    exports.Logger = logger_1.Logger;
	    exports.MasterSlaveService = masterSlaveService_1.MasterSlaveService;
	    exports.SelectionController = selectionController_1.SelectionController;
	    exports.CheckboxSelectionComponent = checkboxSelectionComponent_1.CheckboxSelectionComponent;
	    exports.SortController = sortController_1.SortController;
	    exports.SvgFactory = svgFactory_1.SvgFactory;
	    exports.TemplateService = templateService_1.TemplateService;
	    exports.Utils = utils_1.Utils;
	    exports.NumberSequence = utils_1.NumberSequence;
	    exports.ValueService = valueService_1.ValueService;
	}
	exports.populateClientExports = populateClientExports;


/***/ },
/* 2 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
	 * @version v7.0.2
	 * @link http://www.ag-grid.com/
	 * @license MIT
	 */
	var gridOptionsWrapper_1 = __webpack_require__(3);
	var paginationController_1 = __webpack_require__(41);
	var floatingRowModel_1 = __webpack_require__(26);
	var selectionController_1 = __webpack_require__(28);
	var columnController_1 = __webpack_require__(13);
	var rowRenderer_1 = __webpack_require__(23);
	var headerRenderer_1 = __webpack_require__(66);
	var filterManager_1 = __webpack_require__(43);
	var valueService_1 = __webpack_require__(29);
	var masterSlaveService_1 = __webpack_require__(25);
	var eventService_1 = __webpack_require__(4);
	var gridPanel_1 = __webpack_require__(24);
	var gridApi_1 = __webpack_require__(11);
	var headerTemplateLoader_1 = __webpack_require__(75);
	var balancedColumnTreeBuilder_1 = __webpack_require__(19);
	var displayedGroupCreator_1 = __webpack_require__(21);
	var expressionService_1 = __webpack_require__(18);
	var templateService_1 = __webpack_require__(36);
	var popupService_1 = __webpack_require__(44);
	var logger_1 = __webpack_require__(5);
	var columnUtils_1 = __webpack_require__(16);
	var autoWidthCalculator_1 = __webpack_require__(22);
	var horizontalDragService_1 = __webpack_require__(71);
	var context_1 = __webpack_require__(6);
	var csvCreator_1 = __webpack_require__(12);
	var gridCore_1 = __webpack_require__(40);
	var standardMenu_1 = __webpack_require__(82);
	var dragAndDropService_1 = __webpack_require__(68);
	var dragService_1 = __webpack_require__(31);
	var sortController_1 = __webpack_require__(42);
	var focusedCellController_1 = __webpack_require__(35);
	var mouseEventService_1 = __webpack_require__(32);
	var cellNavigationService_1 = __webpack_require__(65);
	var utils_1 = __webpack_require__(7);
	var filterStage_1 = __webpack_require__(83);
	var sortStage_1 = __webpack_require__(84);
	var flattenStage_1 = __webpack_require__(85);
	var focusService_1 = __webpack_require__(39);
	var cellEditorFactory_1 = __webpack_require__(48);
	var events_1 = __webpack_require__(10);
	var virtualPageRowModel_1 = __webpack_require__(86);
	var inMemoryRowModel_1 = __webpack_require__(89);
	var cellRendererFactory_1 = __webpack_require__(55);
	var cellRendererService_1 = __webpack_require__(60);
	var valueFormatterService_1 = __webpack_require__(61);
	var agCheckbox_1 = __webpack_require__(91);
	var baseFrameworkFactory_1 = __webpack_require__(93);
	var Grid = (function () {
	    function Grid(eGridDiv, gridOptions, params) {
	        if (!eGridDiv) {
	            console.error('ag-Grid: no div element provided to the grid');
	        }
	        if (!gridOptions) {
	            console.error('ag-Grid: no gridOptions provided to the grid');
	        }
	        var rowModelClass = this.getRowModelClass(gridOptions);
	        var enterprise = utils_1.Utils.exists(Grid.enterpriseBeans);
	        var frameworkFactory = params ? params.frameworkFactory : null;
	        if (utils_1.Utils.missing(frameworkFactory)) {
	            frameworkFactory = new baseFrameworkFactory_1.BaseFrameworkFactory();
	        }
	        this.context = new context_1.Context({
	            overrideBeans: Grid.enterpriseBeans,
	            seed: {
	                enterprise: enterprise,
	                gridOptions: gridOptions,
	                eGridDiv: eGridDiv,
	                $scope: params ? params.$scope : null,
	                $compile: params ? params.$compile : null,
	                quickFilterOnScope: params ? params.quickFilterOnScope : null,
	                globalEventListener: params ? params.globalEventListener : null,
	                frameworkFactory: frameworkFactory
	            },
	            beans: [rowModelClass, cellRendererFactory_1.CellRendererFactory, horizontalDragService_1.HorizontalDragService, headerTemplateLoader_1.HeaderTemplateLoader, floatingRowModel_1.FloatingRowModel, dragService_1.DragService,
	                displayedGroupCreator_1.DisplayedGroupCreator, eventService_1.EventService, gridOptionsWrapper_1.GridOptionsWrapper, selectionController_1.SelectionController,
	                filterManager_1.FilterManager, columnController_1.ColumnController, rowRenderer_1.RowRenderer,
	                headerRenderer_1.HeaderRenderer, expressionService_1.ExpressionService, balancedColumnTreeBuilder_1.BalancedColumnTreeBuilder, csvCreator_1.CsvCreator,
	                templateService_1.TemplateService, gridPanel_1.GridPanel, popupService_1.PopupService, valueService_1.ValueService, masterSlaveService_1.MasterSlaveService,
	                logger_1.LoggerFactory, columnUtils_1.ColumnUtils, autoWidthCalculator_1.AutoWidthCalculator, gridApi_1.GridApi,
	                paginationController_1.PaginationController, popupService_1.PopupService, gridCore_1.GridCore, standardMenu_1.StandardMenuFactory,
	                dragAndDropService_1.DragAndDropService, sortController_1.SortController, columnController_1.ColumnApi, focusedCellController_1.FocusedCellController, mouseEventService_1.MouseEventService,
	                cellNavigationService_1.CellNavigationService, filterStage_1.FilterStage, sortStage_1.SortStage, flattenStage_1.FlattenStage, focusService_1.FocusService,
	                cellEditorFactory_1.CellEditorFactory, cellRendererService_1.CellRendererService, valueFormatterService_1.ValueFormatterService],
	            components: [{ componentName: 'AgCheckbox', theClass: agCheckbox_1.AgCheckbox }],
	            debug: !!gridOptions.debug
	        });
	        var eventService = this.context.getBean('eventService');
	        var readyEvent = {
	            api: gridOptions.api,
	            columnApi: gridOptions.columnApi
	        };
	        eventService.dispatchEvent(events_1.Events.EVENT_GRID_READY, readyEvent);
	        if (gridOptions.debug) {
	            console.log('ag-Grid -> initialised successfully, enterprise = ' + enterprise);
	        }
	    }
	    Grid.setEnterpriseBeans = function (enterpriseBeans, rowModelClasses) {
	        this.enterpriseBeans = enterpriseBeans;
	        // the enterprise can inject additional row models. this is how it injects the viewportRowModel
	        utils_1.Utils.iterateObject(rowModelClasses, function (key, value) { return Grid.RowModelClasses[key] = value; });
	    };
	    Grid.prototype.getRowModelClass = function (gridOptions) {
	        var rowModelType = gridOptions.rowModelType;
	        if (utils_1.Utils.exists(rowModelType)) {
	            var rowModelClass = Grid.RowModelClasses[rowModelType];
	            if (utils_1.Utils.exists(rowModelClass)) {
	                return rowModelClass;
	            }
	            else {
	                console.error('ag-Grid: count not find matching row model for rowModelType ' + rowModelType);
	                if (rowModelType === 'viewport') {
	                    console.error('ag-Grid: rowModelType viewport is only available in ag-Grid Enterprise');
	                }
	            }
	        }
	        return inMemoryRowModel_1.InMemoryRowModel;
	    };
	    ;
	    Grid.prototype.destroy = function () {
	        this.context.destroy();
	    };
	    // the default is InMemoryRowModel, which is also used for pagination.
	    // the enterprise adds viewport to this list.
	    Grid.RowModelClasses = {
	        virtual: virtualPageRowModel_1.VirtualPageRowModel,
	        pagination: inMemoryRowModel_1.InMemoryRowModel
	    };
	    return Grid;
	})();
	exports.Grid = Grid;


/***/ },
/* 3 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
	 * @version v7.0.2
	 * @link http://www.ag-grid.com/
	 * @license MIT
	 */
	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var __param = (this && this.__param) || function (paramIndex, decorator) {
	    return function (target, key) { decorator(target, key, paramIndex); }
	};
	var eventService_1 = __webpack_require__(4);
	var constants_1 = __webpack_require__(8);
	var componentUtil_1 = __webpack_require__(9);
	var gridApi_1 = __webpack_require__(11);
	var context_1 = __webpack_require__(6);
	var columnController_1 = __webpack_require__(13);
	var utils_1 = __webpack_require__(7);
	var DEFAULT_ROW_HEIGHT = 25;
	var DEFAULT_VIEWPORT_ROW_MODEL_PAGE_SIZE = 5;
	var DEFAULT_VIEWPORT_ROW_MODEL_BUFFER_SIZE = 5;
	function isTrue(value) {
	    return value === true || value === 'true';
	}
	function positiveNumberOrZero(value, defaultValue) {
	    if (value > 0) {
	        return value;
	    }
	    else {
	        // zero gets returned if number is missing or the wrong type
	        return defaultValue;
	    }
	}
	var GridOptionsWrapper = (function () {
	    function GridOptionsWrapper() {
	        this.propertyEventService = new eventService_1.EventService();
	        this.domDataKey = '__AG_' + Math.random().toString;
	    }
	    GridOptionsWrapper.prototype.agWire = function (gridApi, columnApi) {
	        this.gridOptions.api = gridApi;
	        this.gridOptions.columnApi = columnApi;
	        this.checkForDeprecated();
	    };
	    GridOptionsWrapper.prototype.destroy = function () {
	        // need to remove these, as we don't own the lifecycle of the gridOptions, we need to
	        // remove the references in case the user keeps the grid options, we want the rest
	        // of the grid to be picked up by the garbage collector
	        this.gridOptions.api = null;
	        this.gridOptions.columnApi = null;
	    };
	    GridOptionsWrapper.prototype.init = function () {
	        this.eventService.addGlobalListener(this.globalEventHandler.bind(this));
	        this.setupCellRenderers();
	        if (this.isGroupSelectsChildren() && this.isSuppressParentsInRowNodes()) {
	            console.warn('ag-Grid: groupSelectsChildren does not work wth suppressParentsInRowNodes, this selection method needs the part in rowNode to work');
	        }
	        if (this.isGroupSelectsChildren() && !this.isRowSelectionMulti()) {
	            console.warn('ag-Grid: rowSelectionMulti must be true for groupSelectsChildren to make sense');
	        }
	    };
	    GridOptionsWrapper.prototype.setupCellRenderers = function () {
	        this.fullWidthCellRenderer = this.frameworkFactory.gridOptionsFullWidthCellRenderer(this.gridOptions);
	        this.groupRowRenderer = this.frameworkFactory.gridOptionsGroupRowRenderer(this.gridOptions);
	        this.groupRowInnerRenderer = this.frameworkFactory.gridOptionsGroupRowInnerRenderer(this.gridOptions);
	    };
	    GridOptionsWrapper.prototype.getDomDataKey = function () {
	        return this.domDataKey;
	    };
	    // the cellRenderers come from the instances for this class, not from gridOptions, which allows
	    // the baseFrameworkFactory to replace with framework specific ones
	    GridOptionsWrapper.prototype.getFullWidthCellRenderer = function () { return this.fullWidthCellRenderer; };
	    GridOptionsWrapper.prototype.getGroupRowRenderer = function () { return this.groupRowRenderer; };
	    GridOptionsWrapper.prototype.getGroupRowInnerRenderer = function () { return this.groupRowInnerRenderer; };
	    GridOptionsWrapper.prototype.isEnterprise = function () { return this.enterprise; };
	    GridOptionsWrapper.prototype.isRowSelection = function () { return this.gridOptions.rowSelection === "single" || this.gridOptions.rowSelection === "multiple"; };
	    GridOptionsWrapper.prototype.isRowDeselection = function () { return isTrue(this.gridOptions.rowDeselection); };
	    GridOptionsWrapper.prototype.isRowSelectionMulti = function () { return this.gridOptions.rowSelection === 'multiple'; };
	    GridOptionsWrapper.prototype.getContext = function () { return this.gridOptions.context; };
	    GridOptionsWrapper.prototype.isPivotMode = function () { return isTrue(this.gridOptions.pivotMode); };
	    GridOptionsWrapper.prototype.isRowModelPagination = function () { return this.gridOptions.rowModelType === constants_1.Constants.ROW_MODEL_TYPE_PAGINATION; };
	    GridOptionsWrapper.prototype.isRowModelVirtual = function () { return this.gridOptions.rowModelType === constants_1.Constants.ROW_MODEL_TYPE_VIRTUAL; };
	    GridOptionsWrapper.prototype.isRowModelViewport = function () { return this.gridOptions.rowModelType === constants_1.Constants.ROW_MODEL_TYPE_VIEWPORT; };
	    GridOptionsWrapper.prototype.isRowModelDefault = function () { return !(this.isRowModelPagination() || this.isRowModelVirtual() || this.isRowModelViewport()); };
	    GridOptionsWrapper.prototype.isFullRowEdit = function () { return this.gridOptions.editType === 'fullRow'; };
	    GridOptionsWrapper.prototype.isSuppressFocusAfterRefresh = function () { return isTrue(this.gridOptions.suppressFocusAfterRefresh); };
	    GridOptionsWrapper.prototype.isShowToolPanel = function () { return isTrue(this.gridOptions.showToolPanel); };
	    GridOptionsWrapper.prototype.isToolPanelSuppressRowGroups = function () { return isTrue(this.gridOptions.toolPanelSuppressRowGroups); };
	    GridOptionsWrapper.prototype.isToolPanelSuppressValues = function () { return isTrue(this.gridOptions.toolPanelSuppressValues); };
	    GridOptionsWrapper.prototype.isToolPanelSuppressPivots = function () { return isTrue(this.gridOptions.toolPanelSuppressPivots); };
	    GridOptionsWrapper.prototype.isToolPanelSuppressPivotMode = function () { return isTrue(this.gridOptions.toolPanelSuppressPivotMode); };
	    GridOptionsWrapper.prototype.isSuppressTouch = function () { return isTrue(this.gridOptions.suppressTouch); };
	    GridOptionsWrapper.prototype.isEnableCellChangeFlash = function () { return isTrue(this.gridOptions.enableCellChangeFlash); };
	    GridOptionsWrapper.prototype.isGroupSelectsChildren = function () { return isTrue(this.gridOptions.groupSelectsChildren); };
	    GridOptionsWrapper.prototype.isGroupSelectsFiltered = function () { return isTrue(this.gridOptions.groupSelectsFiltered); };
	    GridOptionsWrapper.prototype.isGroupRemoveSingleChildren = function () { return isTrue(this.gridOptions.groupRemoveSingleChildren); };
	    GridOptionsWrapper.prototype.isGroupIncludeFooter = function () { return isTrue(this.gridOptions.groupIncludeFooter); };
	    GridOptionsWrapper.prototype.isGroupSuppressBlankHeader = function () { return isTrue(this.gridOptions.groupSuppressBlankHeader); };
	    GridOptionsWrapper.prototype.isSuppressRowClickSelection = function () { return isTrue(this.gridOptions.suppressRowClickSelection); };
	    GridOptionsWrapper.prototype.isSuppressCellSelection = function () { return isTrue(this.gridOptions.suppressCellSelection); };
	    GridOptionsWrapper.prototype.isSuppressMultiSort = function () { return isTrue(this.gridOptions.suppressMultiSort); };
	    GridOptionsWrapper.prototype.isGroupSuppressAutoColumn = function () { return isTrue(this.gridOptions.groupSuppressAutoColumn); };
	    GridOptionsWrapper.prototype.isSuppressDragLeaveHidesColumns = function () { return isTrue(this.gridOptions.suppressDragLeaveHidesColumns); };
	    GridOptionsWrapper.prototype.isForPrint = function () { return isTrue(this.gridOptions.forPrint); };
	    GridOptionsWrapper.prototype.isSuppressHorizontalScroll = function () { return isTrue(this.gridOptions.suppressHorizontalScroll); };
	    GridOptionsWrapper.prototype.isSuppressLoadingOverlay = function () { return isTrue(this.gridOptions.suppressLoadingOverlay); };
	    GridOptionsWrapper.prototype.isSuppressNoRowsOverlay = function () { return isTrue(this.gridOptions.suppressNoRowsOverlay); };
	    GridOptionsWrapper.prototype.isSuppressFieldDotNotation = function () { return isTrue(this.gridOptions.suppressFieldDotNotation); };
	    GridOptionsWrapper.prototype.getFloatingTopRowData = function () { return this.gridOptions.floatingTopRowData; };
	    GridOptionsWrapper.prototype.getFloatingBottomRowData = function () { return this.gridOptions.floatingBottomRowData; };
	    GridOptionsWrapper.prototype.isFunctionsPassive = function () { return isTrue(this.gridOptions.functionsPassive); };
	    GridOptionsWrapper.prototype.isSuppressRowHoverClass = function () { return isTrue(this.gridOptions.suppressRowHoverClass); };
	    GridOptionsWrapper.prototype.getQuickFilterText = function () { return this.gridOptions.quickFilterText; };
	    GridOptionsWrapper.prototype.isUnSortIcon = function () { return isTrue(this.gridOptions.unSortIcon); };
	    GridOptionsWrapper.prototype.isSuppressMenuHide = function () { return isTrue(this.gridOptions.suppressMenuHide); };
	    GridOptionsWrapper.prototype.getRowStyle = function () { return this.gridOptions.rowStyle; };
	    GridOptionsWrapper.prototype.getRowClass = function () { return this.gridOptions.rowClass; };
	    GridOptionsWrapper.prototype.getRowStyleFunc = function () { return this.gridOptions.getRowStyle; };
	    GridOptionsWrapper.prototype.getRowClassFunc = function () { return this.gridOptions.getRowClass; };
	    GridOptionsWrapper.prototype.getDoesDataFlowerFunc = function () { return this.gridOptions.doesDataFlower; };
	    GridOptionsWrapper.prototype.getScrollbarWidth = function () { return this.gridOptions.scrollbarWidth; };
	    GridOptionsWrapper.prototype.getIsFullWidthCellFunc = function () { return this.gridOptions.isFullWidthCell; };
	    GridOptionsWrapper.prototype.getFullWidthCellRendererParams = function () { return this.gridOptions.fullWidthCellRendererParams; };
	    GridOptionsWrapper.prototype.getBusinessKeyForNodeFunc = function () { return this.gridOptions.getBusinessKeyForNode; };
	    GridOptionsWrapper.prototype.getHeaderCellRenderer = function () { return this.gridOptions.headerCellRenderer; };
	    GridOptionsWrapper.prototype.getApi = function () { return this.gridOptions.api; };
	    GridOptionsWrapper.prototype.getColumnApi = function () { return this.gridOptions.columnApi; };
	    GridOptionsWrapper.prototype.isEnableColResize = function () { return isTrue(this.gridOptions.enableColResize); };
	    GridOptionsWrapper.prototype.isSingleClickEdit = function () { return isTrue(this.gridOptions.singleClickEdit); };
	    GridOptionsWrapper.prototype.getGroupDefaultExpanded = function () { return this.gridOptions.groupDefaultExpanded; };
	    GridOptionsWrapper.prototype.getAutoSizePadding = function () { return this.gridOptions.autoSizePadding; };
	    GridOptionsWrapper.prototype.getMaxConcurrentDatasourceRequests = function () { return this.gridOptions.maxConcurrentDatasourceRequests; };
	    GridOptionsWrapper.prototype.getMaxPagesInCache = function () { return this.gridOptions.maxPagesInCache; };
	    GridOptionsWrapper.prototype.getPaginationOverflowSize = function () { return this.gridOptions.paginationOverflowSize; };
	    GridOptionsWrapper.prototype.getPaginationPageSize = function () { return this.gridOptions.paginationPageSize; };
	    GridOptionsWrapper.prototype.getPaginationInitialRowCount = function () { return this.gridOptions.paginationInitialRowCount; };
	    GridOptionsWrapper.prototype.getRowData = function () { return this.gridOptions.rowData; };
	    GridOptionsWrapper.prototype.isGroupUseEntireRow = function () { return isTrue(this.gridOptions.groupUseEntireRow); };
	    GridOptionsWrapper.prototype.isEnableRtlSupport = function () { return isTrue(this.gridOptions.enableRtlSupport); };
	    GridOptionsWrapper.prototype.getGroupColumnDef = function () { return this.gridOptions.groupColumnDef; };
	    GridOptionsWrapper.prototype.isGroupSuppressRow = function () { return isTrue(this.gridOptions.groupSuppressRow); };
	    GridOptionsWrapper.prototype.getRowGroupPanelShow = function () { return this.gridOptions.rowGroupPanelShow; };
	    GridOptionsWrapper.prototype.getPivotPanelShow = function () { return this.gridOptions.pivotPanelShow; };
	    GridOptionsWrapper.prototype.isAngularCompileRows = function () { return isTrue(this.gridOptions.angularCompileRows); };
	    GridOptionsWrapper.prototype.isAngularCompileFilters = function () { return isTrue(this.gridOptions.angularCompileFilters); };
	    GridOptionsWrapper.prototype.isAngularCompileHeaders = function () { return isTrue(this.gridOptions.angularCompileHeaders); };
	    GridOptionsWrapper.prototype.isDebug = function () { return isTrue(this.gridOptions.debug); };
	    GridOptionsWrapper.prototype.getColumnDefs = function () { return this.gridOptions.columnDefs; };
	    GridOptionsWrapper.prototype.getDatasource = function () { return this.gridOptions.datasource; };
	    GridOptionsWrapper.prototype.getViewportDatasource = function () { return this.gridOptions.viewportDatasource; };
	    GridOptionsWrapper.prototype.isEnableSorting = function () { return isTrue(this.gridOptions.enableSorting) || isTrue(this.gridOptions.enableServerSideSorting); };
	    GridOptionsWrapper.prototype.isEnableCellExpressions = function () { return isTrue(this.gridOptions.enableCellExpressions); };
	    GridOptionsWrapper.prototype.isSuppressMiddleClickScrolls = function () { return isTrue(this.gridOptions.suppressMiddleClickScrolls); };
	    GridOptionsWrapper.prototype.isSuppressPreventDefaultOnMouseWheel = function () { return isTrue(this.gridOptions.suppressPreventDefaultOnMouseWheel); };
	    GridOptionsWrapper.prototype.isEnableServerSideSorting = function () { return isTrue(this.gridOptions.enableServerSideSorting); };
	    GridOptionsWrapper.prototype.isSuppressColumnVirtualisation = function () { return isTrue(this.gridOptions.suppressColumnVirtualisation); };
	    GridOptionsWrapper.prototype.isSuppressContextMenu = function () { return isTrue(this.gridOptions.suppressContextMenu); };
	    GridOptionsWrapper.prototype.isSuppressCopyRowsToClipboard = function () { return isTrue(this.gridOptions.suppressCopyRowsToClipboard); };
	    GridOptionsWrapper.prototype.isEnableFilter = function () { return isTrue(this.gridOptions.enableFilter) || isTrue(this.gridOptions.enableServerSideFilter); };
	    GridOptionsWrapper.prototype.isEnableServerSideFilter = function () { return this.gridOptions.enableServerSideFilter; };
	    GridOptionsWrapper.prototype.isSuppressScrollLag = function () { return isTrue(this.gridOptions.suppressScrollLag); };
	    GridOptionsWrapper.prototype.isSuppressMovableColumns = function () { return isTrue(this.gridOptions.suppressMovableColumns); };
	    GridOptionsWrapper.prototype.isAnimateRows = function () { return isTrue(this.gridOptions.animateRows); };
	    GridOptionsWrapper.prototype.isSuppressColumnMoveAnimation = function () { return isTrue(this.gridOptions.suppressColumnMoveAnimation); };
	    GridOptionsWrapper.prototype.isSuppressMenuColumnPanel = function () { return isTrue(this.gridOptions.suppressMenuColumnPanel); };
	    GridOptionsWrapper.prototype.isSuppressMenuFilterPanel = function () { return isTrue(this.gridOptions.suppressMenuFilterPanel); };
	    GridOptionsWrapper.prototype.isSuppressUseColIdForGroups = function () { return isTrue(this.gridOptions.suppressUseColIdForGroups); };
	    GridOptionsWrapper.prototype.isSuppressAggFuncInHeader = function () { return isTrue(this.gridOptions.suppressAggFuncInHeader); };
	    GridOptionsWrapper.prototype.isSuppressMenuMainPanel = function () { return isTrue(this.gridOptions.suppressMenuMainPanel); };
	    GridOptionsWrapper.prototype.isEnableRangeSelection = function () { return isTrue(this.gridOptions.enableRangeSelection); };
	    GridOptionsWrapper.prototype.isRememberGroupStateWhenNewData = function () { return isTrue(this.gridOptions.rememberGroupStateWhenNewData); };
	    GridOptionsWrapper.prototype.getIcons = function () { return this.gridOptions.icons; };
	    GridOptionsWrapper.prototype.getAggFuncs = function () { return this.gridOptions.aggFuncs; };
	    GridOptionsWrapper.prototype.getIsScrollLag = function () { return this.gridOptions.isScrollLag; };
	    GridOptionsWrapper.prototype.getSortingOrder = function () { return this.gridOptions.sortingOrder; };
	    GridOptionsWrapper.prototype.getSlaveGrids = function () { return this.gridOptions.slaveGrids; };
	    GridOptionsWrapper.prototype.getGroupRowRendererParams = function () { return this.gridOptions.groupRowRendererParams; };
	    GridOptionsWrapper.prototype.getOverlayLoadingTemplate = function () { return this.gridOptions.overlayLoadingTemplate; };
	    GridOptionsWrapper.prototype.getOverlayNoRowsTemplate = function () { return this.gridOptions.overlayNoRowsTemplate; };
	    GridOptionsWrapper.prototype.getCheckboxSelection = function () { return this.gridOptions.checkboxSelection; };
	    GridOptionsWrapper.prototype.isSuppressAutoSize = function () { return isTrue(this.gridOptions.suppressAutoSize); };
	    GridOptionsWrapper.prototype.isSuppressParentsInRowNodes = function () { return isTrue(this.gridOptions.suppressParentsInRowNodes); };
	    GridOptionsWrapper.prototype.isEnableStatusBar = function () { return isTrue(this.gridOptions.enableStatusBar); };
	    GridOptionsWrapper.prototype.isFunctionsReadOnly = function () { return isTrue(this.gridOptions.functionsReadOnly); };
	    GridOptionsWrapper.prototype.getDefaultColDef = function () { return this.gridOptions.defaultColDef; };
	    GridOptionsWrapper.prototype.getDefaultColGroupDef = function () { return this.gridOptions.defaultColGroupDef; };
	    GridOptionsWrapper.prototype.getHeaderCellTemplate = function () { return this.gridOptions.headerCellTemplate; };
	    GridOptionsWrapper.prototype.getHeaderCellTemplateFunc = function () { return this.gridOptions.getHeaderCellTemplate; };
	    GridOptionsWrapper.prototype.getNodeChildDetailsFunc = function () { return this.gridOptions.getNodeChildDetails; };
	    GridOptionsWrapper.prototype.getGroupRowAggNodesFunc = function () { return this.gridOptions.groupRowAggNodes; };
	    GridOptionsWrapper.prototype.getContextMenuItemsFunc = function () { return this.gridOptions.getContextMenuItems; };
	    GridOptionsWrapper.prototype.getMainMenuItemsFunc = function () { return this.gridOptions.getMainMenuItems; };
	    GridOptionsWrapper.prototype.getRowNodeIdFunc = function () { return this.gridOptions.getRowNodeId; };
	    GridOptionsWrapper.prototype.getProcessSecondaryColDefFunc = function () { return this.gridOptions.processSecondaryColDef; };
	    GridOptionsWrapper.prototype.getProcessSecondaryColGroupDefFunc = function () { return this.gridOptions.processSecondaryColGroupDef; };
	    GridOptionsWrapper.prototype.getProcessCellForClipboardFunc = function () { return this.gridOptions.processCellForClipboard; };
	    GridOptionsWrapper.prototype.getProcessCellFromClipboardFunc = function () { return this.gridOptions.processCellFromClipboard; };
	    GridOptionsWrapper.prototype.getViewportRowModelPageSize = function () { return positiveNumberOrZero(this.gridOptions.viewportRowModelPageSize, DEFAULT_VIEWPORT_ROW_MODEL_PAGE_SIZE); };
	    GridOptionsWrapper.prototype.getViewportRowModelBufferSize = function () { return positiveNumberOrZero(this.gridOptions.viewportRowModelBufferSize, DEFAULT_VIEWPORT_ROW_MODEL_BUFFER_SIZE); };
	    // public getCellRenderers(): {[key: string]: {new(): ICellRenderer} | ICellRendererFunc} { return this.gridOptions.cellRenderers; }
	    // public getCellEditors(): {[key: string]: {new(): ICellEditor}} { return this.gridOptions.cellEditors; }
	    GridOptionsWrapper.prototype.setProperty = function (key, value) {
	        var gridOptionsNoType = this.gridOptions;
	        var previousValue = gridOptionsNoType[key];
	        gridOptionsNoType[key] = value;
	        this.propertyEventService.dispatchEvent(key, { currentValue: value, previousValue: previousValue });
	    };
	    GridOptionsWrapper.prototype.addEventListener = function (key, listener) {
	        this.propertyEventService.addEventListener(key, listener);
	    };
	    GridOptionsWrapper.prototype.removeEventListener = function (key, listener) {
	        this.propertyEventService.removeEventListener(key, listener);
	    };
	    GridOptionsWrapper.prototype.executeProcessRowPostCreateFunc = function (params) {
	        if (this.gridOptions.processRowPostCreate) {
	            this.gridOptions.processRowPostCreate(params);
	        }
	    };
	    // properties
	    GridOptionsWrapper.prototype.getHeaderHeight = function () {
	        if (typeof this.gridOptions.headerHeight === 'number') {
	            return this.gridOptions.headerHeight;
	        }
	        else {
	            return 25;
	        }
	    };
	    GridOptionsWrapper.prototype.isExternalFilterPresent = function () {
	        if (typeof this.gridOptions.isExternalFilterPresent === 'function') {
	            return this.gridOptions.isExternalFilterPresent();
	        }
	        else {
	            return false;
	        }
	    };
	    GridOptionsWrapper.prototype.doesExternalFilterPass = function (node) {
	        if (typeof this.gridOptions.doesExternalFilterPass === 'function') {
	            return this.gridOptions.doesExternalFilterPass(node);
	        }
	        else {
	            return false;
	        }
	    };
	    GridOptionsWrapper.prototype.getLayoutInterval = function () {
	        if (typeof this.gridOptions.layoutInterval === 'number') {
	            return this.gridOptions.layoutInterval;
	        }
	        else {
	            return constants_1.Constants.LAYOUT_INTERVAL;
	        }
	    };
	    GridOptionsWrapper.prototype.getMinColWidth = function () {
	        if (this.gridOptions.minColWidth > GridOptionsWrapper.MIN_COL_WIDTH) {
	            return this.gridOptions.minColWidth;
	        }
	        else {
	            return GridOptionsWrapper.MIN_COL_WIDTH;
	        }
	    };
	    GridOptionsWrapper.prototype.getMaxColWidth = function () {
	        if (this.gridOptions.maxColWidth > GridOptionsWrapper.MIN_COL_WIDTH) {
	            return this.gridOptions.maxColWidth;
	        }
	        else {
	            return null;
	        }
	    };
	    GridOptionsWrapper.prototype.getColWidth = function () {
	        if (typeof this.gridOptions.colWidth !== 'number' || this.gridOptions.colWidth < GridOptionsWrapper.MIN_COL_WIDTH) {
	            return 200;
	        }
	        else {
	            return this.gridOptions.colWidth;
	        }
	    };
	    GridOptionsWrapper.prototype.getRowBuffer = function () {
	        if (typeof this.gridOptions.rowBuffer === 'number') {
	            if (this.gridOptions.rowBuffer < 0) {
	                console.warn('ag-Grid: rowBuffer should not be negative');
	            }
	            return this.gridOptions.rowBuffer;
	        }
	        else {
	            return constants_1.Constants.ROW_BUFFER_SIZE;
	        }
	    };
	    GridOptionsWrapper.prototype.checkForDeprecated = function () {
	        // casting to generic object, so typescript compiles even though
	        // we are looking for attributes that don't exist
	        var options = this.gridOptions;
	        if (options.suppressUnSort) {
	            console.warn('ag-grid: as of v1.12.4 suppressUnSort is not used. Please use sortOrder instead.');
	        }
	        if (options.suppressDescSort) {
	            console.warn('ag-grid: as of v1.12.4 suppressDescSort is not used. Please use sortOrder instead.');
	        }
	        if (options.groupAggFields) {
	            console.warn('ag-grid: as of v3 groupAggFields is not used. Please add appropriate agg fields to your columns.');
	        }
	        if (options.groupHidePivotColumns) {
	            console.warn('ag-grid: as of v3 groupHidePivotColumns is not used as pivot columns are now called rowGroup columns. Please refer to the documentation');
	        }
	        if (options.groupKeys) {
	            console.warn('ag-grid: as of v3 groupKeys is not used. You need to set rowGroupIndex on the columns to group. Please refer to the documentation');
	        }
	        if (options.ready || options.onReady) {
	            console.warn('ag-grid: as of v3.3 ready event is now called gridReady, so the callback should be onGridReady');
	        }
	        if (typeof options.groupDefaultExpanded === 'boolean') {
	            console.warn('ag-grid: groupDefaultExpanded can no longer be boolean. for groupDefaultExpanded=true, use groupDefaultExpanded=9999 instead, to expand all the groups');
	        }
	        if (options.onRowDeselected || options.rowDeselected) {
	            console.warn('ag-grid: since version 3.4 event rowDeselected no longer exists, please check the docs');
	        }
	        if (options.rowsAlreadyGrouped) {
	            console.warn('ag-grid: since version 3.4 rowsAlreadyGrouped no longer exists, please use getNodeChildDetails() instead');
	        }
	        if (options.groupAggFunction) {
	            console.warn('ag-grid: since version 4.3.x groupAggFunction is now called groupRowAggNodes');
	        }
	    };
	    GridOptionsWrapper.prototype.getLocaleTextFunc = function () {
	        if (this.gridOptions.localeTextFunc) {
	            return this.gridOptions.localeTextFunc;
	        }
	        var that = this;
	        return function (key, defaultValue) {
	            var localeText = that.gridOptions.localeText;
	            if (localeText && localeText[key]) {
	                return localeText[key];
	            }
	            else {
	                return defaultValue;
	            }
	        };
	    };
	    // responsible for calling the onXXX functions on gridOptions
	    GridOptionsWrapper.prototype.globalEventHandler = function (eventName, event) {
	        var callbackMethodName = componentUtil_1.ComponentUtil.getCallbackForEvent(eventName);
	        if (typeof this.gridOptions[callbackMethodName] === 'function') {
	            this.gridOptions[callbackMethodName](event);
	        }
	    };
	    // we don't allow dynamic row height for virtual paging
	    GridOptionsWrapper.prototype.getRowHeightAsNumber = function () {
	        var rowHeight = this.gridOptions.rowHeight;
	        if (utils_1.Utils.missing(rowHeight)) {
	            return DEFAULT_ROW_HEIGHT;
	        }
	        else if (typeof this.gridOptions.rowHeight === 'number') {
	            return this.gridOptions.rowHeight;
	        }
	        else {
	            console.warn('ag-Grid row height must be a number if not using standard row model');
	            return DEFAULT_ROW_HEIGHT;
	        }
	    };
	    GridOptionsWrapper.prototype.getRowHeightForNode = function (rowNode) {
	        // check the function first, in case use set both function and
	        // number, when using virtual pagination then function can be
	        // used for floating rows and the number for the body rows.
	        if (typeof this.gridOptions.getRowHeight === 'function') {
	            var params = {
	                node: rowNode,
	                data: rowNode.data,
	                api: this.gridOptions.api,
	                context: this.gridOptions.context
	            };
	            return this.gridOptions.getRowHeight(params);
	        }
	        else if (typeof this.gridOptions.rowHeight === 'number') {
	            return this.gridOptions.rowHeight;
	        }
	        else {
	            return DEFAULT_ROW_HEIGHT;
	        }
	    };
	    GridOptionsWrapper.MIN_COL_WIDTH = 10;
	    GridOptionsWrapper.PROP_HEADER_HEIGHT = 'headerHeight';
	    __decorate([
	        context_1.Autowired('gridOptions'), 
	        __metadata('design:type', Object)
	    ], GridOptionsWrapper.prototype, "gridOptions", void 0);
	    __decorate([
	        context_1.Autowired('columnController'), 
	        __metadata('design:type', columnController_1.ColumnController)
	    ], GridOptionsWrapper.prototype, "columnController", void 0);
	    __decorate([
	        context_1.Autowired('eventService'), 
	        __metadata('design:type', eventService_1.EventService)
	    ], GridOptionsWrapper.prototype, "eventService", void 0);
	    __decorate([
	        context_1.Autowired('enterprise'), 
	        __metadata('design:type', Boolean)
	    ], GridOptionsWrapper.prototype, "enterprise", void 0);
	    __decorate([
	        context_1.Autowired('frameworkFactory'), 
	        __metadata('design:type', Object)
	    ], GridOptionsWrapper.prototype, "frameworkFactory", void 0);
	    __decorate([
	        __param(0, context_1.Qualifier('gridApi')),
	        __param(1, context_1.Qualifier('columnApi')), 
	        __metadata('design:type', Function), 
	        __metadata('design:paramtypes', [gridApi_1.GridApi, columnController_1.ColumnApi]), 
	        __metadata('design:returntype', void 0)
	    ], GridOptionsWrapper.prototype, "agWire", null);
	    __decorate([
	        context_1.PreDestroy, 
	        __metadata('design:type', Function), 
	        __metadata('design:paramtypes', []), 
	        __metadata('design:returntype', void 0)
	    ], GridOptionsWrapper.prototype, "destroy", null);
	    __decorate([
	        context_1.PostConstruct, 
	        __metadata('design:type', Function), 
	        __metadata('design:paramtypes', []), 
	        __metadata('design:returntype', void 0)
	    ], GridOptionsWrapper.prototype, "init", null);
	    GridOptionsWrapper = __decorate([
	        context_1.Bean('gridOptionsWrapper'), 
	        __metadata('design:paramtypes', [])
	    ], GridOptionsWrapper);
	    return GridOptionsWrapper;
	})();
	exports.GridOptionsWrapper = GridOptionsWrapper;


/***/ },
/* 4 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
	 * @version v7.0.2
	 * @link http://www.ag-grid.com/
	 * @license MIT
	 */
	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var __param = (this && this.__param) || function (paramIndex, decorator) {
	    return function (target, key) { decorator(target, key, paramIndex); }
	};
	var logger_1 = __webpack_require__(5);
	var utils_1 = __webpack_require__(7);
	var context_1 = __webpack_require__(6);
	var context_2 = __webpack_require__(6);
	var EventService = (function () {
	    function EventService() {
	        this.allListeners = {};
	        this.globalListeners = [];
	    }
	    EventService.prototype.agWire = function (loggerFactory, globalEventListener) {
	        if (globalEventListener === void 0) { globalEventListener = null; }
	        this.logger = loggerFactory.create('EventService');
	        if (globalEventListener) {
	            this.addGlobalListener(globalEventListener);
	        }
	    };
	    EventService.prototype.getListenerList = function (eventType) {
	        var listenerList = this.allListeners[eventType];
	        if (!listenerList) {
	            listenerList = [];
	            this.allListeners[eventType] = listenerList;
	        }
	        return listenerList;
	    };
	    EventService.prototype.addEventListener = function (eventType, listener) {
	        var listenerList = this.getListenerList(eventType);
	        if (listenerList.indexOf(listener) < 0) {
	            listenerList.push(listener);
	        }
	    };
	    // for some events, it's important that the model gets to hear about them before the view,
	    // as the model may need to update before the view works on the info. if you register
	    // via this method, you get notified before the view parts
	    EventService.prototype.addModalPriorityEventListener = function (eventType, listener) {
	        this.addEventListener(eventType + EventService.PRIORITY, listener);
	    };
	    EventService.prototype.addGlobalListener = function (listener) {
	        this.globalListeners.push(listener);
	    };
	    EventService.prototype.removeEventListener = function (eventType, listener) {
	        var listenerList = this.getListenerList(eventType);
	        utils_1.Utils.removeFromArray(listenerList, listener);
	    };
	    EventService.prototype.removeGlobalListener = function (listener) {
	        utils_1.Utils.removeFromArray(this.globalListeners, listener);
	    };
	    // why do we pass the type here? the type is in ColumnChangeEvent, so unless the
	    // type is not in other types of events???
	    EventService.prototype.dispatchEvent = function (eventType, event) {
	        if (!event) {
	            event = {};
	        }
	        // console.log(`dispatching ${eventType}: ${event}`);
	        // this allows the columnController to get events before anyone else
	        var p1ListenerList = this.getListenerList(eventType + EventService.PRIORITY);
	        p1ListenerList.forEach(function (listener) {
	            listener(event);
	        });
	        var listenerList = this.getListenerList(eventType);
	        listenerList.forEach(function (listener) {
	            listener(event);
	        });
	        this.globalListeners.forEach(function (listener) {
	            listener(eventType, event);
	        });
	    };
	    EventService.PRIORITY = '-P1';
	    __decorate([
	        __param(0, context_2.Qualifier('loggerFactory')),
	        __param(1, context_2.Qualifier('globalEventListener')), 
	        __metadata('design:type', Function), 
	        __metadata('design:paramtypes', [logger_1.LoggerFactory, Function]), 
	        __metadata('design:returntype', void 0)
	    ], EventService.prototype, "agWire", null);
	    EventService = __decorate([
	        context_1.Bean('eventService'), 
	        __metadata('design:paramtypes', [])
	    ], EventService);
	    return EventService;
	})();
	exports.EventService = EventService;


/***/ },
/* 5 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
	 * @version v7.0.2
	 * @link http://www.ag-grid.com/
	 * @license MIT
	 */
	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var __param = (this && this.__param) || function (paramIndex, decorator) {
	    return function (target, key) { decorator(target, key, paramIndex); }
	};
	var gridOptionsWrapper_1 = __webpack_require__(3);
	var context_1 = __webpack_require__(6);
	var context_2 = __webpack_require__(6);
	var LoggerFactory = (function () {
	    function LoggerFactory() {
	    }
	    LoggerFactory.prototype.setBeans = function (gridOptionsWrapper) {
	        this.logging = gridOptionsWrapper.isDebug();
	    };
	    LoggerFactory.prototype.create = function (name) {
	        return new Logger(name, this.logging);
	    };
	    __decorate([
	        __param(0, context_2.Qualifier('gridOptionsWrapper')), 
	        __metadata('design:type', Function), 
	        __metadata('design:paramtypes', [gridOptionsWrapper_1.GridOptionsWrapper]), 
	        __metadata('design:returntype', void 0)
	    ], LoggerFactory.prototype, "setBeans", null);
	    LoggerFactory = __decorate([
	        context_1.Bean('loggerFactory'), 
	        __metadata('design:paramtypes', [])
	    ], LoggerFactory);
	    return LoggerFactory;
	})();
	exports.LoggerFactory = LoggerFactory;
	var Logger = (function () {
	    function Logger(name, logging) {
	        this.name = name;
	        this.logging = logging;
	    }
	    Logger.prototype.log = function (message) {
	        if (this.logging) {
	            console.log('ag-Grid.' + this.name + ': ' + message);
	        }
	    };
	    return Logger;
	})();
	exports.Logger = Logger;


/***/ },
/* 6 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
	 * @version v7.0.2
	 * @link http://www.ag-grid.com/
	 * @license MIT
	 */
	var utils_1 = __webpack_require__(7);
	var logger_1 = __webpack_require__(5);
	var Context = (function () {
	    function Context(params) {
	        this.beans = {};
	        this.componentsMappedByName = {};
	        this.destroyed = false;
	        if (!params || !params.beans) {
	            return;
	        }
	        this.contextParams = params;
	        this.logger = new logger_1.Logger('Context', this.contextParams.debug);
	        this.logger.log('>> creating ag-Application Context');
	        this.setupComponents();
	        this.createBeans();
	        var beans = utils_1.Utils.mapObject(this.beans, function (beanEntry) { return beanEntry.beanInstance; });
	        this.wireBeans(beans);
	        this.logger.log('>> ag-Application Context ready - component is alive');
	    }
	    Context.prototype.setupComponents = function () {
	        var _this = this;
	        if (this.contextParams.components) {
	            this.contextParams.components.forEach(function (componentMeta) { return _this.addComponent(componentMeta); });
	        }
	    };
	    Context.prototype.addComponent = function (componentMeta) {
	        // get name of the class as a string
	        // var className = _.getNameOfClass(ComponentClass);
	        // insert a dash after every capital letter
	        // var classEscaped = className.replace(/([A-Z])/g, "-$1").toLowerCase();
	        var classEscaped = componentMeta.componentName.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase();
	        // put all to upper case
	        var classUpperCase = classEscaped.toUpperCase();
	        // finally store
	        this.componentsMappedByName[classUpperCase] = componentMeta.theClass;
	    };
	    Context.prototype.createComponent = function (element) {
	        var key = element.nodeName;
	        if (this.componentsMappedByName && this.componentsMappedByName[key]) {
	            var newComponent = new this.componentsMappedByName[key];
	            this.copyAttributesFromNode(element, newComponent.getGui());
	            this.wireBean(newComponent);
	            return newComponent;
	        }
	        else {
	            return null;
	        }
	    };
	    Context.prototype.copyAttributesFromNode = function (fromNode, toNode) {
	        if (fromNode.attributes) {
	            var count = fromNode.attributes.length;
	            for (var i = 0; i < count; i++) {
	                var attr = fromNode.attributes[i];
	                toNode.setAttribute(attr.name, attr.value);
	            }
	        }
	    };
	    Context.prototype.wireBean = function (bean) {
	        this.wireBeans([bean]);
	    };
	    Context.prototype.wireBeans = function (beans) {
	        this.autoWireBeans(beans);
	        this.methodWireBeans(beans);
	        this.postConstruct(beans);
	    };
	    Context.prototype.createBeans = function () {
	        var _this = this;
	        // register all normal beans
	        this.contextParams.beans.forEach(this.createBeanEntry.bind(this));
	        // register override beans, these will overwrite beans above of same name
	        if (this.contextParams.overrideBeans) {
	            this.contextParams.overrideBeans.forEach(this.createBeanEntry.bind(this));
	        }
	        // instantiate all beans - overridden beans will be left out
	        utils_1.Utils.iterateObject(this.beans, function (key, beanEntry) {
	            var constructorParamsMeta;
	            if (beanEntry.bean.prototype.__agBeanMetaData
	                && beanEntry.bean.prototype.__agBeanMetaData.autowireMethods
	                && beanEntry.bean.prototype.__agBeanMetaData.autowireMethods.agConstructor) {
	                constructorParamsMeta = beanEntry.bean.prototype.__agBeanMetaData.autowireMethods.agConstructor;
	            }
	            var constructorParams = _this.getBeansForParameters(constructorParamsMeta, beanEntry.beanName);
	            var newInstance = applyToConstructor(beanEntry.bean, constructorParams);
	            beanEntry.beanInstance = newInstance;
	            _this.logger.log('bean ' + _this.getBeanName(newInstance) + ' created');
	        });
	    };
	    Context.prototype.createBeanEntry = function (Bean) {
	        var metaData = Bean.prototype.__agBeanMetaData;
	        if (!metaData) {
	            var beanName;
	            if (Bean.prototype.constructor) {
	                beanName = Bean.prototype.constructor.name;
	            }
	            else {
	                beanName = '' + Bean;
	            }
	            console.error('context item ' + beanName + ' is not a bean');
	            return;
	        }
	        var beanEntry = {
	            bean: Bean,
	            beanInstance: null,
	            beanName: metaData.beanName
	        };
	        this.beans[metaData.beanName] = beanEntry;
	    };
	    Context.prototype.autoWireBeans = function (beans) {
	        var _this = this;
	        beans.forEach(function (bean) { return _this.autoWireBean(bean); });
	    };
	    Context.prototype.methodWireBeans = function (beans) {
	        var _this = this;
	        beans.forEach(function (bean) { return _this.methodWireBean(bean); });
	    };
	    Context.prototype.autoWireBean = function (bean) {
	        var _this = this;
	        if (!bean
	            || !bean.__agBeanMetaData
	            || !bean.__agBeanMetaData.agClassAttributes) {
	            return;
	        }
	        var attributes = bean.__agBeanMetaData.agClassAttributes;
	        if (!attributes) {
	            return;
	        }
	        var beanName = this.getBeanName(bean);
	        attributes.forEach(function (attribute) {
	            var otherBean = _this.lookupBeanInstance(beanName, attribute.beanName, attribute.optional);
	            bean[attribute.attributeName] = otherBean;
	        });
	    };
	    Context.prototype.getBeanName = function (bean) {
	        var constructorString = bean.constructor.toString();
	        var beanName = constructorString.substring(9, constructorString.indexOf('('));
	        return beanName;
	    };
	    Context.prototype.methodWireBean = function (bean) {
	        var _this = this;
	        var autowiredMethods;
	        if (bean.__agBeanMetaData) {
	            autowiredMethods = bean.__agBeanMetaData.autowireMethods;
	        }
	        utils_1.Utils.iterateObject(autowiredMethods, function (methodName, wireParams) {
	            // skip constructor, as this is dealt with elsewhere
	            if (methodName === 'agConstructor') {
	                return;
	            }
	            var beanName = _this.getBeanName(bean);
	            var initParams = _this.getBeansForParameters(wireParams, beanName);
	            bean[methodName].apply(bean, initParams);
	        });
	    };
	    Context.prototype.getBeansForParameters = function (parameters, beanName) {
	        var _this = this;
	        var beansList = [];
	        if (parameters) {
	            utils_1.Utils.iterateObject(parameters, function (paramIndex, otherBeanName) {
	                var otherBean = _this.lookupBeanInstance(beanName, otherBeanName);
	                beansList[Number(paramIndex)] = otherBean;
	            });
	        }
	        return beansList;
	    };
	    Context.prototype.lookupBeanInstance = function (wiringBean, beanName, optional) {
	        if (optional === void 0) { optional = false; }
	        if (beanName === 'context') {
	            return this;
	        }
	        else if (this.contextParams.seed && this.contextParams.seed.hasOwnProperty(beanName)) {
	            return this.contextParams.seed[beanName];
	        }
	        else {
	            var beanEntry = this.beans[beanName];
	            if (beanEntry) {
	                return beanEntry.beanInstance;
	            }
	            if (!optional) {
	                console.error('ag-Grid: unable to find bean reference ' + beanName + ' while initialising ' + wiringBean);
	            }
	            return null;
	        }
	    };
	    Context.prototype.postConstruct = function (beans) {
	        beans.forEach(function (bean) {
	            // try calling init methods
	            if (bean.__agBeanMetaData && bean.__agBeanMetaData.postConstructMethods) {
	                bean.__agBeanMetaData.postConstructMethods.forEach(function (methodName) { return bean[methodName](); });
	            }
	        });
	    };
	    Context.prototype.getBean = function (name) {
	        return this.lookupBeanInstance('getBean', name, true);
	    };
	    Context.prototype.destroy = function () {
	        // should only be able to destroy once
	        if (this.destroyed) {
	            return;
	        }
	        this.logger.log('>> Shutting down ag-Application Context');
	        // try calling destroy methods
	        utils_1.Utils.iterateObject(this.beans, function (key, beanEntry) {
	            var bean = beanEntry.beanInstance;
	            if (bean.__agBeanMetaData && bean.__agBeanMetaData.preDestroyMethods) {
	                bean.__agBeanMetaData.preDestroyMethods.forEach(function (methodName) { return bean[methodName](); });
	            }
	        });
	        this.destroyed = true;
	        this.logger.log('>> ag-Application Context shut down - component is dead');
	    };
	    return Context;
	})();
	exports.Context = Context;
	// taken from: http://stackoverflow.com/questions/3362471/how-can-i-call-a-javascript-constructor-using-call-or-apply
	// allows calling 'apply' on a constructor
	function applyToConstructor(constructor, argArray) {
	    var args = [null].concat(argArray);
	    var factoryFunction = constructor.bind.apply(constructor, args);
	    return new factoryFunction();
	}
	function PostConstruct(target, methodName, descriptor) {
	    var props = getOrCreateProps(target);
	    if (!props.postConstructMethods) {
	        props.postConstructMethods = [];
	    }
	    props.postConstructMethods.push(methodName);
	}
	exports.PostConstruct = PostConstruct;
	function PreDestroy(target, methodName, descriptor) {
	    var props = getOrCreateProps(target);
	    if (!props.preDestroyMethods) {
	        props.preDestroyMethods = [];
	    }
	    props.preDestroyMethods.push(methodName);
	}
	exports.PreDestroy = PreDestroy;
	function Bean(beanName) {
	    return function (classConstructor) {
	        var props = getOrCreateProps(classConstructor.prototype);
	        props.beanName = beanName;
	    };
	}
	exports.Bean = Bean;
	function Autowired(name) {
	    return autowiredFunc.bind(this, name, false);
	}
	exports.Autowired = Autowired;
	function Optional(name) {
	    return autowiredFunc.bind(this, name, true);
	}
	exports.Optional = Optional;
	function autowiredFunc(name, optional, classPrototype, methodOrAttributeName, index) {
	    if (name === null) {
	        console.error('ag-Grid: Autowired name should not be null');
	        return;
	    }
	    if (typeof index === 'number') {
	        console.error('ag-Grid: Autowired should be on an attribute');
	        return;
	    }
	    // it's an attribute on the class
	    var props = getOrCreateProps(classPrototype);
	    if (!props.agClassAttributes) {
	        props.agClassAttributes = [];
	    }
	    props.agClassAttributes.push({
	        attributeName: methodOrAttributeName,
	        beanName: name,
	        optional: optional
	    });
	}
	function Qualifier(name) {
	    return function (classPrototype, methodOrAttributeName, index) {
	        var props;
	        if (typeof index === 'number') {
	            // it's a parameter on a method
	            var methodName;
	            if (methodOrAttributeName) {
	                props = getOrCreateProps(classPrototype);
	                methodName = methodOrAttributeName;
	            }
	            else {
	                props = getOrCreateProps(classPrototype.prototype);
	                methodName = 'agConstructor';
	            }
	            if (!props.autowireMethods) {
	                props.autowireMethods = {};
	            }
	            if (!props.autowireMethods[methodName]) {
	                props.autowireMethods[methodName] = {};
	            }
	            props.autowireMethods[methodName][index] = name;
	        }
	    };
	}
	exports.Qualifier = Qualifier;
	function getOrCreateProps(target) {
	    var props = target.__agBeanMetaData;
	    if (!props) {
	        props = {};
	        target.__agBeanMetaData = props;
	    }
	    return props;
	}


/***/ },
/* 7 */
/***/ function(module, exports) {

	/**
	 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
	 * @version v7.0.2
	 * @link http://www.ag-grid.com/
	 * @license MIT
	 */
	var FUNCTION_STRIP_COMMENTS = /((\/\/.*$)|(\/\*[\s\S]*?\*\/))/mg;
	var FUNCTION_ARGUMENT_NAMES = /([^\s,]+)/g;
	// util class, only used when debugging, for printing time to console
	var Timer = (function () {
	    function Timer() {
	        this.timestamp = new Date().getTime();
	    }
	    Timer.prototype.print = function (msg) {
	        var duration = (new Date().getTime()) - this.timestamp;
	        console.log(msg + " = " + duration);
	        this.timestamp = new Date().getTime();
	    };
	    return Timer;
	})();
	exports.Timer = Timer;
	var Utils = (function () {
	    function Utils() {
	    }
	    // returns true if the event is close to the original event by X pixels either vertically or horizontally.
	    // we only start dragging after X pixels so this allows us to know if we should start dragging yet.
	    Utils.areEventsNear = function (e1, e2, pixelCount) {
	        // by default, we wait 4 pixels before starting the drag
	        if (pixelCount === 0) {
	            return false;
	        }
	        var diffX = Math.abs(e1.clientX - e2.clientX);
	        var diffY = Math.abs(e1.clientY - e2.clientY);
	        return Math.max(diffX, diffY) <= pixelCount;
	    };
	    Utils.shallowCompare = function (arr1, arr2) {
	        // if both are missing, then they are the same
	        if (this.missing(arr1) && this.missing(arr2)) {
	            return true;
	        }
	        // if one is present, but other is missing, then then are different
	        if (this.missing(arr1) || this.missing(arr2)) {
	            return false;
	        }
	        if (arr1.length !== arr2.length) {
	            return false;
	        }
	        for (var i = 0; i < arr1.length; i++) {
	            if (arr1[i] !== arr2[i]) {
	                return false;
	            }
	        }
	        return true;
	    };
	    Utils.getNameOfClass = function (TheClass) {
	        var funcNameRegex = /function (.{1,})\(/;
	        var funcAsString = TheClass.toString();
	        var results = (funcNameRegex).exec(funcAsString);
	        return (results && results.length > 1) ? results[1] : "";
	    };
	    Utils.values = function (object) {
	        var result = [];
	        this.iterateObject(object, function (key, value) {
	            result.push(value);
	        });
	        return result;
	    };
	    Utils.getValueUsingField = function (data, field, fieldContainsDots) {
	        if (!field || !data) {
	            return;
	        }
	        // if no '.', then it's not a deep value
	        if (!fieldContainsDots) {
	            return data[field];
	        }
	        else {
	            // otherwise it is a deep value, so need to dig for it
	            var fields = field.split('.');
	            var currentObject = data;
	            for (var i = 0; i < fields.length; i++) {
	                currentObject = currentObject[fields[i]];
	                if (this.missing(currentObject)) {
	                    return null;
	                }
	            }
	            return currentObject;
	        }
	    };
	    Utils.iterateObject = function (object, callback) {
	        if (this.missing(object)) {
	            return;
	        }
	        var keys = Object.keys(object);
	        for (var i = 0; i < keys.length; i++) {
	            var key = keys[i];
	            var value = object[key];
	            callback(key, value);
	        }
	    };
	    Utils.cloneObject = function (object) {
	        var copy = {};
	        var keys = Object.keys(object);
	        for (var i = 0; i < keys.length; i++) {
	            var key = keys[i];
	            var value = object[key];
	            copy[key] = value;
	        }
	        return copy;
	    };
	    Utils.map = function (array, callback) {
	        var result = [];
	        for (var i = 0; i < array.length; i++) {
	            var item = array[i];
	            var mappedItem = callback(item);
	            result.push(mappedItem);
	        }
	        return result;
	    };
	    Utils.mapObject = function (object, callback) {
	        var result = [];
	        Utils.iterateObject(object, function (key, value) {
	            result.push(callback(value));
	        });
	        return result;
	    };
	    Utils.forEach = function (array, callback) {
	        if (!array) {
	            return;
	        }
	        for (var i = 0; i < array.length; i++) {
	            var value = array[i];
	            callback(value, i);
	        }
	    };
	    Utils.filter = function (array, callback) {
	        var result = [];
	        array.forEach(function (item) {
	            if (callback(item)) {
	                result.push(item);
	            }
	        });
	        return result;
	    };
	    Utils.assign = function (object, source) {
	        if (this.exists(source)) {
	            this.iterateObject(source, function (key, value) {
	                object[key] = value;
	            });
	        }
	    };
	    Utils.pushAll = function (target, source) {
	        if (this.missing(source) || this.missing(target)) {
	            return;
	        }
	        source.forEach(function (func) { return target.push(func); });
	    };
	    Utils.getFunctionParameters = function (func) {
	        var fnStr = func.toString().replace(FUNCTION_STRIP_COMMENTS, '');
	        var result = fnStr.slice(fnStr.indexOf('(') + 1, fnStr.indexOf(')')).match(FUNCTION_ARGUMENT_NAMES);
	        if (result === null) {
	            return [];
	        }
	        else {
	            return result;
	        }
	    };
	    Utils.find = function (collection, predicate, value) {
	        if (collection === null || collection === undefined) {
	            return null;
	        }
	        var firstMatchingItem;
	        for (var i = 0; i < collection.length; i++) {
	            var item = collection[i];
	            if (typeof predicate === 'string') {
	                if (item[predicate] === value) {
	                    firstMatchingItem = item;
	                    break;
	                }
	            }
	            else {
	                var callback = predicate;
	                if (callback(item)) {
	                    firstMatchingItem = item;
	                    break;
	                }
	            }
	        }
	        return firstMatchingItem;
	    };
	    Utils.toStrings = function (array) {
	        return this.map(array, function (item) {
	            if (item === undefined || item === null || !item.toString) {
	                return null;
	            }
	            else {
	                return item.toString();
	            }
	        });
	    };
	    Utils.iterateArray = function (array, callback) {
	        for (var index = 0; index < array.length; index++) {
	            var value = array[index];
	            callback(value, index);
	        }
	    };
	    //Returns true if it is a DOM node
	    //taken from: http://stackoverflow.com/questions/384286/javascript-isdom-how-do-you-check-if-a-javascript-object-is-a-dom-object
	    Utils.isNode = function (o) {
	        return (typeof Node === "function" ? o instanceof Node :
	            o && typeof o === "object" && typeof o.nodeType === "number" && typeof o.nodeName === "string");
	    };
	    //Returns true if it is a DOM element
	    //taken from: http://stackoverflow.com/questions/384286/javascript-isdom-how-do-you-check-if-a-javascript-object-is-a-dom-object
	    Utils.isElement = function (o) {
	        return (typeof HTMLElement === "function" ? o instanceof HTMLElement :
	            o && typeof o === "object" && o !== null && o.nodeType === 1 && typeof o.nodeName === "string");
	    };
	    Utils.isNodeOrElement = function (o) {
	        return this.isNode(o) || this.isElement(o);
	    };
	    //adds all type of change listeners to an element, intended to be a text field
	    Utils.addChangeListener = function (element, listener) {
	        element.addEventListener("changed", listener);
	        element.addEventListener("paste", listener);
	        element.addEventListener("input", listener);
	        // IE doesn't fire changed for special keys (eg delete, backspace), so need to
	        // listen for this further ones
	        element.addEventListener("keydown", listener);
	        element.addEventListener("keyup", listener);
	    };
	    //if value is undefined, null or blank, returns null, otherwise returns the value
	    Utils.makeNull = function (value) {
	        if (value === null || value === undefined || value === "") {
	            return null;
	        }
	        else {
	            return value;
	        }
	    };
	    Utils.missing = function (value) {
	        return !this.exists(value);
	    };
	    Utils.missingOrEmpty = function (value) {
	        return this.missing(value) || value.length === 0;
	    };
	    Utils.missingOrEmptyObject = function (value) {
	        return this.missing(value) || Object.keys(value).length === 0;
	    };
	    Utils.exists = function (value) {
	        if (value === null || value === undefined || value === '') {
	            return false;
	        }
	        else {
	            return true;
	        }
	    };
	    Utils.existsAndNotEmpty = function (value) {
	        return this.exists(value) && value.length > 0;
	    };
	    Utils.removeAllChildren = function (node) {
	        if (node) {
	            while (node.hasChildNodes()) {
	                node.removeChild(node.lastChild);
	            }
	        }
	    };
	    Utils.removeElement = function (parent, cssSelector) {
	        this.removeFromParent(parent.querySelector(cssSelector));
	    };
	    Utils.removeFromParent = function (node) {
	        if (node && node.parentNode) {
	            node.parentNode.removeChild(node);
	        }
	    };
	    Utils.isVisible = function (element) {
	        return (element.offsetParent !== null);
	    };
	    /**
	     * loads the template and returns it as an element. makes up for no simple way in
	     * the dom api to load html directly, eg we cannot do this: document.createElement(template)
	     */
	    Utils.loadTemplate = function (template) {
	        var tempDiv = document.createElement("div");
	        tempDiv.innerHTML = template;
	        return tempDiv.firstChild;
	    };
	    Utils.addOrRemoveCssClass = function (element, className, addOrRemove) {
	        if (addOrRemove) {
	            this.addCssClass(element, className);
	        }
	        else {
	            this.removeCssClass(element, className);
	        }
	    };
	    Utils.callIfPresent = function (func) {
	        if (func) {
	            func();
	        }
	    };
	    Utils.addCssClass = function (element, className) {
	        var _this = this;
	        if (!className || className.length === 0) {
	            return;
	        }
	        if (className.indexOf(' ') >= 0) {
	            className.split(' ').forEach(function (value) { return _this.addCssClass(element, value); });
	            return;
	        }
	        if (element.classList) {
	            element.classList.add(className);
	        }
	        else {
	            if (element.className && element.className.length > 0) {
	                var cssClasses = element.className.split(' ');
	                if (cssClasses.indexOf(className) < 0) {
	                    cssClasses.push(className);
	                    element.className = cssClasses.join(' ');
	                }
	            }
	            else {
	                element.className = className;
	            }
	        }
	    };
	    Utils.containsClass = function (element, className) {
	        if (element.classList) {
	            // for modern browsers
	            return element.classList.contains(className);
	        }
	        else if (element.className) {
	            // for older browsers, check against the string of class names
	            // if only one class, can check for exact match
	            var onlyClass = element.className === className;
	            // if many classes, check for class name, we have to pad with ' ' to stop other
	            // class names that are a substring of this class
	            var contains = element.className.indexOf(' ' + className + ' ') >= 0;
	            // the padding above then breaks when it's the first or last class names
	            var startsWithClass = element.className.indexOf(className + ' ') === 0;
	            var endsWithClass = element.className.lastIndexOf(' ' + className) === (element.className.length - className.length - 1);
	            return onlyClass || contains || startsWithClass || endsWithClass;
	        }
	        else {
	            // if item is not a node
	            return false;
	        }
	    };
	    Utils.getElementAttribute = function (element, attributeName) {
	        if (element.attributes) {
	            if (element.attributes[attributeName]) {
	                var attribute = element.attributes[attributeName];
	                return attribute.value;
	            }
	            else {
	                return null;
	            }
	        }
	        else {
	            return null;
	        }
	    };
	    Utils.offsetHeight = function (element) {
	        return element && element.clientHeight ? element.clientHeight : 0;
	    };
	    Utils.offsetWidth = function (element) {
	        return element && element.clientWidth ? element.clientWidth : 0;
	    };
	    Utils.removeCssClass = function (element, className) {
	        if (element.className && element.className.length > 0) {
	            var cssClasses = element.className.split(' ');
	            var index = cssClasses.indexOf(className);
	            if (index >= 0) {
	                cssClasses.splice(index, 1);
	                element.className = cssClasses.join(' ');
	            }
	        }
	    };
	    Utils.removeRepeatsFromArray = function (array, object) {
	        if (!array) {
	            return;
	        }
	        for (var index = array.length - 2; index >= 0; index--) {
	            var thisOneMatches = array[index] === object;
	            var nextOneMatches = array[index + 1] === object;
	            if (thisOneMatches && nextOneMatches) {
	                array.splice(index + 1, 1);
	            }
	        }
	    };
	    Utils.removeFromArray = function (array, object) {
	        if (array.indexOf(object) >= 0) {
	            array.splice(array.indexOf(object), 1);
	        }
	    };
	    Utils.insertIntoArray = function (array, object, toIndex) {
	        array.splice(toIndex, 0, object);
	    };
	    Utils.insertArrayIntoArray = function (dest, src, toIndex) {
	        if (this.missing(dest) || this.missing(src)) {
	            return;
	        }
	        // put items in backwards, otherwise inserted items end up in reverse order
	        for (var i = src.length - 1; i >= 0; i--) {
	            var item = src[i];
	            this.insertIntoArray(dest, item, toIndex);
	        }
	    };
	    Utils.moveInArray = function (array, objectsToMove, toIndex) {
	        var _this = this;
	        // first take out it items from the array
	        objectsToMove.forEach(function (obj) {
	            _this.removeFromArray(array, obj);
	        });
	        // now add the objects, in same order as provided to us, that means we start at the end
	        // as the objects will be pushed to the right as they are inserted
	        objectsToMove.slice().reverse().forEach(function (obj) {
	            _this.insertIntoArray(array, obj, toIndex);
	        });
	    };
	    Utils.defaultComparator = function (valueA, valueB) {
	        var valueAMissing = valueA === null || valueA === undefined;
	        var valueBMissing = valueB === null || valueB === undefined;
	        if (valueAMissing && valueBMissing) {
	            return 0;
	        }
	        if (valueAMissing) {
	            return -1;
	        }
	        if (valueBMissing) {
	            return 1;
	        }
	        if (typeof valueA === "string") {
	            try {
	                // using local compare also allows chinese comparisons
	                return valueA.localeCompare(valueB);
	            }
	            catch (e) {
	            }
	        }
	        if (valueA < valueB) {
	            return -1;
	        }
	        else if (valueA > valueB) {
	            return 1;
	        }
	        else {
	            return 0;
	        }
	    };
	    Utils.compareArrays = function (array1, array2) {
	        if (this.missing(array1) && this.missing(array2)) {
	            return true;
	        }
	        if (this.missing(array1) || this.missing(array2)) {
	            return false;
	        }
	        if (array1.length !== array2.length) {
	            return false;
	        }
	        for (var i = 0; i < array1.length; i++) {
	            if (array1[i] !== array2[i]) {
	                return false;
	            }
	        }
	        return true;
	    };
	    Utils.toStringOrNull = function (value) {
	        if (this.exists(value) && value.toString) {
	            return value.toString();
	        }
	        else {
	            return null;
	        }
	    };
	    Utils.formatWidth = function (width) {
	        if (typeof width === "number") {
	            return width + "px";
	        }
	        else {
	            return width;
	        }
	    };
	    Utils.formatNumberTwoDecimalPlacesAndCommas = function (value) {
	        // took this from: http://blog.tompawlak.org/number-currency-formatting-javascript
	        if (typeof value === 'number') {
	            return (Math.round(value * 100) / 100).toString().replace(/(\d)(?=(\d{3})+(?!\d))/g, "$1,");
	        }
	        else {
	            return '';
	        }
	    };
	    Utils.prependDC = function (parent, documentFragment) {
	        if (this.exists(parent.firstChild)) {
	            parent.insertBefore(documentFragment, parent.firstChild);
	        }
	        else {
	            parent.appendChild(documentFragment);
	        }
	    };
	    // static prepend(parent: HTMLElement, child: HTMLElement): void {
	    //     if (this.exists(parent.firstChild)) {
	    //         parent.insertBefore(child, parent.firstChild);
	    //     } else {
	    //         parent.appendChild(child);
	    //     }
	    // }
	    /**
	     * If icon provided, use this (either a string, or a function callback).
	     * if not, then use the second parameter, which is the svgFactory function
	     */
	    Utils.createIcon = function (iconName, gridOptionsWrapper, column, svgFactoryFunc) {
	        var eResult = document.createElement('span');
	        eResult.appendChild(this.createIconNoSpan(iconName, gridOptionsWrapper, column, svgFactoryFunc));
	        return eResult;
	    };
	    Utils.createIconNoSpan = function (iconName, gridOptionsWrapper, column, svgFactoryFunc) {
	        var userProvidedIcon;
	        // check col for icon first
	        if (column && column.getColDef().icons) {
	            userProvidedIcon = column.getColDef().icons[iconName];
	        }
	        // it not in col, try grid options
	        if (!userProvidedIcon && gridOptionsWrapper.getIcons()) {
	            userProvidedIcon = gridOptionsWrapper.getIcons()[iconName];
	        }
	        // now if user provided, use it
	        if (userProvidedIcon) {
	            var rendererResult;
	            if (typeof userProvidedIcon === 'function') {
	                rendererResult = userProvidedIcon();
	            }
	            else if (typeof userProvidedIcon === 'string') {
	                rendererResult = userProvidedIcon;
	            }
	            else {
	                throw 'icon from grid options needs to be a string or a function';
	            }
	            if (typeof rendererResult === 'string') {
	                return this.loadTemplate(rendererResult);
	            }
	            else if (this.isNodeOrElement(rendererResult)) {
	                return rendererResult;
	            }
	            else {
	                throw 'iconRenderer should return back a string or a dom object';
	            }
	        }
	        else {
	            // otherwise we use the built in icon
	            if (svgFactoryFunc) {
	                return svgFactoryFunc();
	            }
	            else {
	                return null;
	            }
	        }
	    };
	    Utils.addStylesToElement = function (eElement, styles) {
	        if (!styles) {
	            return;
	        }
	        Object.keys(styles).forEach(function (key) {
	            eElement.style[key] = styles[key];
	        });
	    };
	    Utils.isScrollShowing = function (element) {
	        return element.clientHeight < element.scrollHeight;
	    };
	    Utils.getScrollbarWidth = function () {
	        var outer = document.createElement("div");
	        outer.style.visibility = "hidden";
	        outer.style.width = "100px";
	        outer.style.msOverflowStyle = "scrollbar"; // needed for WinJS apps
	        document.body.appendChild(outer);
	        var widthNoScroll = outer.offsetWidth;
	        // force scrollbars
	        outer.style.overflow = "scroll";
	        // add innerdiv
	        var inner = document.createElement("div");
	        inner.style.width = "100%";
	        outer.appendChild(inner);
	        var widthWithScroll = inner.offsetWidth;
	        // remove divs
	        outer.parentNode.removeChild(outer);
	        return widthNoScroll - widthWithScroll;
	    };
	    Utils.isKeyPressed = function (event, keyToCheck) {
	        var pressedKey = event.which || event.keyCode;
	        return pressedKey === keyToCheck;
	    };
	    Utils.setVisible = function (element, visible, visibleStyle) {
	        if (visible) {
	            if (this.exists(visibleStyle)) {
	                element.style.display = visibleStyle;
	            }
	            else {
	                element.style.display = 'inline';
	            }
	        }
	        else {
	            element.style.display = 'none';
	        }
	    };
	    Utils.isBrowserIE = function () {
	        if (this.isIE === undefined) {
	            this.isIE = false || !!document.documentMode; // At least IE6
	        }
	        return this.isIE;
	    };
	    Utils.isBrowserEdge = function () {
	        if (this.isEdge === undefined) {
	            this.isEdge = !this.isBrowserIE() && !!window.StyleMedia;
	        }
	        return this.isEdge;
	    };
	    Utils.isBrowserSafari = function () {
	        if (this.isSafari === undefined) {
	            this.isSafari = Object.prototype.toString.call(window.HTMLElement).indexOf('Constructor') > 0;
	        }
	        return this.isSafari;
	    };
	    // srcElement is only available in IE. In all other browsers it is target
	    // http://stackoverflow.com/questions/5301643/how-can-i-make-event-srcelement-work-in-firefox-and-what-does-it-mean
	    Utils.getTarget = function (event) {
	        var eventNoType = event;
	        return eventNoType.target || eventNoType.srcElement;
	    };
	    // taken from: http://stackoverflow.com/questions/1038727/how-to-get-browser-width-using-javascript-code
	    Utils.getBodyWidth = function () {
	        if (document.body) {
	            return document.body.clientWidth;
	        }
	        if (window.innerHeight) {
	            return window.innerWidth;
	        }
	        if (document.documentElement && document.documentElement.clientWidth) {
	            return document.documentElement.clientWidth;
	        }
	        return -1;
	    };
	    // taken from: http://stackoverflow.com/questions/1038727/how-to-get-browser-width-using-javascript-code
	    Utils.getBodyHeight = function () {
	        if (document.body) {
	            return document.body.clientHeight;
	        }
	        if (window.innerHeight) {
	            return window.innerHeight;
	        }
	        if (document.documentElement && document.documentElement.clientHeight) {
	            return document.documentElement.clientHeight;
	        }
	        return -1;
	    };
	    Utils.setCheckboxState = function (eCheckbox, state) {
	        if (typeof state === 'boolean') {
	            eCheckbox.checked = state;
	            eCheckbox.indeterminate = false;
	        }
	        else {
	            // isNodeSelected returns back undefined if it's a group and the children
	            // are a mix of selected and unselected
	            eCheckbox.indeterminate = true;
	        }
	    };
	    Utils.traverseNodesWithKey = function (nodes, callback) {
	        var keyParts = [];
	        recursiveSearchNodes(nodes);
	        function recursiveSearchNodes(nodes) {
	            nodes.forEach(function (node) {
	                if (node.group) {
	                    keyParts.push(node.key);
	                    var key = keyParts.join('|');
	                    callback(node, key);
	                    recursiveSearchNodes(node.childrenAfterGroup);
	                    keyParts.pop();
	                }
	            });
	        }
	    };
	    // Taken from here: https://github.com/facebook/fixed-data-table/blob/master/src/vendor_upstream/dom/normalizeWheel.js
	    /**
	     * Mouse wheel (and 2-finger trackpad) support on the web sucks.  It is
	     * complicated, thus this doc is long and (hopefully) detailed enough to answer
	     * your questions.
	     *
	     * If you need to react to the mouse wheel in a predictable way, this code is
	     * like your bestest friend. * hugs *
	     *
	     * As of today, there are 4 DOM event types you can listen to:
	     *
	     *   'wheel'                -- Chrome(31+), FF(17+), IE(9+)
	     *   'mousewheel'           -- Chrome, IE(6+), Opera, Safari
	     *   'MozMousePixelScroll'  -- FF(3.5 only!) (2010-2013) -- don't bother!
	     *   'DOMMouseScroll'       -- FF(0.9.7+) since 2003
	     *
	     * So what to do?  The is the best:
	     *
	     *   normalizeWheel.getEventType();
	     *
	     * In your event callback, use this code to get sane interpretation of the
	     * deltas.  This code will return an object with properties:
	     *
	     *   spinX   -- normalized spin speed (use for zoom) - x plane
	     *   spinY   -- " - y plane
	     *   pixelX  -- normalized distance (to pixels) - x plane
	     *   pixelY  -- " - y plane
	     *
	     * Wheel values are provided by the browser assuming you are using the wheel to
	     * scroll a web page by a number of lines or pixels (or pages).  Values can vary
	     * significantly on different platforms and browsers, forgetting that you can
	     * scroll at different speeds.  Some devices (like trackpads) emit more events
	     * at smaller increments with fine granularity, and some emit massive jumps with
	     * linear speed or acceleration.
	     *
	     * This code does its best to normalize the deltas for you:
	     *
	     *   - spin is trying to normalize how far the wheel was spun (or trackpad
	     *     dragged).  This is super useful for zoom support where you want to
	     *     throw away the chunky scroll steps on the PC and make those equal to
	     *     the slow and smooth tiny steps on the Mac. Key data: This code tries to
	     *     resolve a single slow step on a wheel to 1.
	     *
	     *   - pixel is normalizing the desired scroll delta in pixel units.  You'll
	     *     get the crazy differences between browsers, but at least it'll be in
	     *     pixels!
	     *
	     *   - positive value indicates scrolling DOWN/RIGHT, negative UP/LEFT.  This
	     *     should translate to positive value zooming IN, negative zooming OUT.
	     *     This matches the newer 'wheel' event.
	     *
	     * Why are there spinX, spinY (or pixels)?
	     *
	     *   - spinX is a 2-finger side drag on the trackpad, and a shift + wheel turn
	     *     with a mouse.  It results in side-scrolling in the browser by default.
	     *
	     *   - spinY is what you expect -- it's the classic axis of a mouse wheel.
	     *
	     *   - I dropped spinZ/pixelZ.  It is supported by the DOM 3 'wheel' event and
	     *     probably is by browsers in conjunction with fancy 3D controllers .. but
	     *     you know.
	     *
	     * Implementation info:
	     *
	     * Examples of 'wheel' event if you scroll slowly (down) by one step with an
	     * average mouse:
	     *
	     *   OS X + Chrome  (mouse)     -    4   pixel delta  (wheelDelta -120)
	     *   OS X + Safari  (mouse)     -  N/A   pixel delta  (wheelDelta  -12)
	     *   OS X + Firefox (mouse)     -    0.1 line  delta  (wheelDelta  N/A)
	     *   Win8 + Chrome  (mouse)     -  100   pixel delta  (wheelDelta -120)
	     *   Win8 + Firefox (mouse)     -    3   line  delta  (wheelDelta -120)
	     *
	     * On the trackpad:
	     *
	     *   OS X + Chrome  (trackpad)  -    2   pixel delta  (wheelDelta   -6)
	     *   OS X + Firefox (trackpad)  -    1   pixel delta  (wheelDelta  N/A)
	     *
	     * On other/older browsers.. it's more complicated as there can be multiple and
	     * also missing delta values.
	     *
	     * The 'wheel' event is more standard:
	     *
	     * http://www.w3.org/TR/DOM-Level-3-Events/#events-wheelevents
	     *
	     * The basics is that it includes a unit, deltaMode (pixels, lines, pages), and
	     * deltaX, deltaY and deltaZ.  Some browsers provide other values to maintain
	     * backward compatibility with older events.  Those other values help us
	     * better normalize spin speed.  Example of what the browsers provide:
	     *
	     *                          | event.wheelDelta | event.detail
	     *        ------------------+------------------+--------------
	     *          Safari v5/OS X  |       -120       |       0
	     *          Safari v5/Win7  |       -120       |       0
	     *         Chrome v17/OS X  |       -120       |       0
	     *         Chrome v17/Win7  |       -120       |       0
	     *                IE9/Win7  |       -120       |   undefined
	     *         Firefox v4/OS X  |     undefined    |       1
	     *         Firefox v4/Win7  |     undefined    |       3
	     *
	     */
	    Utils.normalizeWheel = function (event) {
	        var PIXEL_STEP = 10;
	        var LINE_HEIGHT = 40;
	        var PAGE_HEIGHT = 800;
	        // spinX, spinY
	        var sX = 0;
	        var sY = 0;
	        // pixelX, pixelY
	        var pX = 0;
	        var pY = 0;
	        // Legacy
	        if ('detail' in event) {
	            sY = event.detail;
	        }
	        if ('wheelDelta' in event) {
	            sY = -event.wheelDelta / 120;
	        }
	        if ('wheelDeltaY' in event) {
	            sY = -event.wheelDeltaY / 120;
	        }
	        if ('wheelDeltaX' in event) {
	            sX = -event.wheelDeltaX / 120;
	        }
	        // side scrolling on FF with DOMMouseScroll
	        if ('axis' in event && event.axis === event.HORIZONTAL_AXIS) {
	            sX = sY;
	            sY = 0;
	        }
	        pX = sX * PIXEL_STEP;
	        pY = sY * PIXEL_STEP;
	        if ('deltaY' in event) {
	            pY = event.deltaY;
	        }
	        if ('deltaX' in event) {
	            pX = event.deltaX;
	        }
	        if ((pX || pY) && event.deltaMode) {
	            if (event.deltaMode == 1) {
	                pX *= LINE_HEIGHT;
	                pY *= LINE_HEIGHT;
	            }
	            else {
	                pX *= PAGE_HEIGHT;
	                pY *= PAGE_HEIGHT;
	            }
	        }
	        // Fall-back if spin cannot be determined
	        if (pX && !sX) {
	            sX = (pX < 1) ? -1 : 1;
	        }
	        if (pY && !sY) {
	            sY = (pY < 1) ? -1 : 1;
	        }
	        return { spinX: sX,
	            spinY: sY,
	            pixelX: pX,
	            pixelY: pY };
	    };
	    return Utils;
	})();
	exports.Utils = Utils;
	var NumberSequence = (function () {
	    function NumberSequence(initValue, step) {
	        if (initValue === void 0) { initValue = 0; }
	        if (step === void 0) { step = 1; }
	        this.nextValue = initValue;
	        this.step = step;
	    }
	    NumberSequence.prototype.next = function () {
	        var valToReturn = this.nextValue;
	        this.nextValue += this.step;
	        return valToReturn;
	    };
	    return NumberSequence;
	})();
	exports.NumberSequence = NumberSequence;


/***/ },
/* 8 */
/***/ function(module, exports) {

	/**
	 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
	 * @version v7.0.2
	 * @link http://www.ag-grid.com/
	 * @license MIT
	 */
	var Constants = (function () {
	    function Constants() {
	    }
	    Constants.STEP_EVERYTHING = 0;
	    Constants.STEP_FILTER = 1;
	    Constants.STEP_SORT = 2;
	    Constants.STEP_MAP = 3;
	    Constants.STEP_AGGREGATE = 4;
	    Constants.STEP_PIVOT = 5;
	    Constants.ROW_BUFFER_SIZE = 10;
	    Constants.LAYOUT_INTERVAL = 500;
	    Constants.KEY_BACKSPACE = 8;
	    Constants.KEY_TAB = 9;
	    Constants.KEY_ENTER = 13;
	    Constants.KEY_SHIFT = 16;
	    Constants.KEY_ESCAPE = 27;
	    Constants.KEY_SPACE = 32;
	    Constants.KEY_LEFT = 37;
	    Constants.KEY_UP = 38;
	    Constants.KEY_RIGHT = 39;
	    Constants.KEY_DOWN = 40;
	    Constants.KEY_DELETE = 46;
	    Constants.KEY_A = 65;
	    Constants.KEY_C = 67;
	    Constants.KEY_V = 86;
	    Constants.KEY_D = 68;
	    Constants.KEY_F2 = 113;
	    Constants.ROW_MODEL_TYPE_PAGINATION = 'pagination';
	    Constants.ROW_MODEL_TYPE_VIRTUAL = 'virtual';
	    Constants.ROW_MODEL_TYPE_VIEWPORT = 'viewport';
	    Constants.ROW_MODEL_TYPE_NORMAL = 'normal';
	    Constants.ALWAYS = 'always';
	    Constants.ONLY_WHEN_GROUPING = 'onlyWhenGrouping';
	    Constants.FLOATING_TOP = 'top';
	    Constants.FLOATING_BOTTOM = 'bottom';
	    return Constants;
	})();
	exports.Constants = Constants;


/***/ },
/* 9 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
	 * @version v7.0.2
	 * @link http://www.ag-grid.com/
	 * @license MIT
	 */
	var events_1 = __webpack_require__(10);
	var utils_1 = __webpack_require__(7);
	var ComponentUtil = (function () {
	    function ComponentUtil() {
	    }
	    ComponentUtil.getEventCallbacks = function () {
	        if (!ComponentUtil.EVENT_CALLBACKS) {
	            ComponentUtil.EVENT_CALLBACKS = [];
	            ComponentUtil.EVENTS.forEach(function (eventName) {
	                ComponentUtil.EVENT_CALLBACKS.push(ComponentUtil.getCallbackForEvent(eventName));
	            });
	        }
	        return ComponentUtil.EVENT_CALLBACKS;
	    };
	    ComponentUtil.copyAttributesToGridOptions = function (gridOptions, component) {
	        checkForDeprecated(component);
	        // create empty grid options if none were passed
	        if (typeof gridOptions !== 'object') {
	            gridOptions = {};
	        }
	        // to allow array style lookup in TypeScript, take type away from 'this' and 'gridOptions'
	        var pGridOptions = gridOptions;
	        // add in all the simple properties
	        ComponentUtil.ARRAY_PROPERTIES
	            .concat(ComponentUtil.STRING_PROPERTIES)
	            .concat(ComponentUtil.OBJECT_PROPERTIES)
	            .concat(ComponentUtil.FUNCTION_PROPERTIES)
	            .forEach(function (key) {
	            if (typeof (component)[key] !== 'undefined') {
	                pGridOptions[key] = component[key];
	            }
	        });
	        ComponentUtil.BOOLEAN_PROPERTIES.forEach(function (key) {
	            if (typeof (component)[key] !== 'undefined') {
	                pGridOptions[key] = ComponentUtil.toBoolean(component[key]);
	            }
	        });
	        ComponentUtil.NUMBER_PROPERTIES.forEach(function (key) {
	            if (typeof (component)[key] !== 'undefined') {
	                pGridOptions[key] = ComponentUtil.toNumber(component[key]);
	            }
	        });
	        ComponentUtil.getEventCallbacks().forEach(function (funcName) {
	            if (typeof (component)[funcName] !== 'undefined') {
	                pGridOptions[funcName] = component[funcName];
	            }
	        });
	        return gridOptions;
	    };
	    ComponentUtil.getCallbackForEvent = function (eventName) {
	        if (!eventName || eventName.length < 2) {
	            return eventName;
	        }
	        else {
	            return 'on' + eventName[0].toUpperCase() + eventName.substr(1);
	        }
	    };
	    // change this method, the caller should know if it's initialised or not, plus 'initialised'
	    // is not relevant for all component types. maybe pass in the api and columnApi instead???
	    ComponentUtil.processOnChange = function (changes, gridOptions, api, columnApi) {
	        //if (!component._initialised || !changes) { return; }
	        if (!changes) {
	            return;
	        }
	        checkForDeprecated(changes);
	        // to allow array style lookup in TypeScript, take type away from 'this' and 'gridOptions'
	        var pGridOptions = gridOptions;
	        // check if any change for the simple types, and if so, then just copy in the new value
	        ComponentUtil.ARRAY_PROPERTIES
	            .concat(ComponentUtil.OBJECT_PROPERTIES)
	            .concat(ComponentUtil.STRING_PROPERTIES)
	            .forEach(function (key) {
	            if (changes[key]) {
	                pGridOptions[key] = changes[key].currentValue;
	            }
	        });
	        ComponentUtil.BOOLEAN_PROPERTIES.forEach(function (key) {
	            if (changes[key]) {
	                pGridOptions[key] = ComponentUtil.toBoolean(changes[key].currentValue);
	            }
	        });
	        ComponentUtil.NUMBER_PROPERTIES.forEach(function (key) {
	            if (changes[key]) {
	                pGridOptions[key] = ComponentUtil.toNumber(changes[key].currentValue);
	            }
	        });
	        ComponentUtil.getEventCallbacks().forEach(function (funcName) {
	            if (changes[funcName]) {
	                pGridOptions[funcName] = changes[funcName].currentValue;
	            }
	        });
	        if (changes.showToolPanel) {
	            api.showToolPanel(ComponentUtil.toBoolean(changes.showToolPanel.currentValue));
	        }
	        if (changes.quickFilterText) {
	            api.setQuickFilter(changes.quickFilterText.currentValue);
	        }
	        if (changes.rowData) {
	            api.setRowData(changes.rowData.currentValue);
	        }
	        if (changes.floatingTopRowData) {
	            api.setFloatingTopRowData(changes.floatingTopRowData.currentValue);
	        }
	        if (changes.floatingBottomRowData) {
	            api.setFloatingBottomRowData(changes.floatingBottomRowData.currentValue);
	        }
	        if (changes.columnDefs) {
	            api.setColumnDefs(changes.columnDefs.currentValue);
	        }
	        if (changes.datasource) {
	            api.setDatasource(changes.datasource.currentValue);
	        }
	        if (changes.headerHeight) {
	            api.setHeaderHeight(ComponentUtil.toNumber(changes.headerHeight.currentValue));
	        }
	        if (changes.pivotMode) {
	            columnApi.setPivotMode(ComponentUtil.toBoolean(changes.pivotMode.currentValue));
	        }
	    };
	    ComponentUtil.toBoolean = function (value) {
	        if (typeof value === 'boolean') {
	            return value;
	        }
	        else if (typeof value === 'string') {
	            // for boolean, compare to empty String to allow attributes appearing with
	            // not value to be treated as 'true'
	            return value.toUpperCase() === 'TRUE' || value == '';
	        }
	        else {
	            return false;
	        }
	    };
	    ComponentUtil.toNumber = function (value) {
	        if (typeof value === 'number') {
	            return value;
	        }
	        else if (typeof value === 'string') {
	            return Number(value);
	        }
	        else {
	            return undefined;
	        }
	    };
	    // all the events are populated in here AFTER this class (at the bottom of the file).
	    ComponentUtil.EVENTS = [];
	    ComponentUtil.STRING_PROPERTIES = [
	        'sortingOrder', 'rowClass', 'rowSelection', 'overlayLoadingTemplate',
	        'overlayNoRowsTemplate', 'headerCellTemplate', 'quickFilterText', 'rowModelType',
	        'editType'];
	    ComponentUtil.OBJECT_PROPERTIES = [
	        'rowStyle', 'context', 'groupColumnDef', 'localeText', 'icons', 'datasource', 'viewportDatasource',
	        'groupRowRendererParams', 'aggFuncs', 'fullWidthCellRendererParams', 'defaultColGroupDef', 'defaultColDef'
	    ];
	    ComponentUtil.ARRAY_PROPERTIES = [
	        'slaveGrids', 'rowData', 'floatingTopRowData', 'floatingBottomRowData', 'columnDefs'
	    ];
	    ComponentUtil.NUMBER_PROPERTIES = [
	        'rowHeight', 'rowBuffer', 'colWidth', 'headerHeight', 'groupDefaultExpanded',
	        'minColWidth', 'maxColWidth', 'viewportRowModelPageSize', 'viewportRowModelBufferSize',
	        'layoutInterval', 'autoSizePadding', 'maxPagesInCache', 'maxConcurrentDatasourceRequests',
	        'paginationOverflowSize', 'paginationPageSize', 'paginationInitialRowCount', 'scrollbarWidth'
	    ];
	    ComponentUtil.BOOLEAN_PROPERTIES = [
	        'toolPanelSuppressRowGroups', 'toolPanelSuppressValues', 'toolPanelSuppressPivots', 'toolPanelSuppressPivotMode',
	        'suppressRowClickSelection', 'suppressCellSelection', 'suppressHorizontalScroll', 'debug',
	        'enableColResize', 'enableCellExpressions', 'enableSorting', 'enableServerSideSorting',
	        'enableFilter', 'enableServerSideFilter', 'angularCompileRows', 'angularCompileFilters',
	        'angularCompileHeaders', 'groupSuppressAutoColumn', 'groupSelectsChildren',
	        'groupIncludeFooter', 'groupUseEntireRow', 'groupSuppressRow', 'groupSuppressBlankHeader', 'forPrint',
	        'suppressMenuHide', 'rowDeselection', 'unSortIcon', 'suppressMultiSort', 'suppressScrollLag',
	        'singleClickEdit', 'suppressLoadingOverlay', 'suppressNoRowsOverlay', 'suppressAutoSize',
	        'suppressParentsInRowNodes', 'showToolPanel', 'suppressColumnMoveAnimation', 'suppressMovableColumns',
	        'suppressFieldDotNotation', 'enableRangeSelection', 'suppressEnterprise', 'rowGroupPanelShow',
	        'pivotPanelShow', 'suppressTouch',
	        'suppressContextMenu', 'suppressMenuFilterPanel', 'suppressMenuMainPanel', 'suppressMenuColumnPanel',
	        'enableStatusBar', 'rememberGroupStateWhenNewData', 'enableCellChangeFlash', 'suppressDragLeaveHidesColumns',
	        'suppressMiddleClickScrolls', 'suppressPreventDefaultOnMouseWheel', 'suppressUseColIdForGroups',
	        'suppressCopyRowsToClipboard', 'pivotMode', 'suppressAggFuncInHeader', 'suppressColumnVirtualisation',
	        'suppressFocusAfterRefresh', 'functionsPassive', 'functionsReadOnly', 'suppressRowHoverClass',
	        'animateRows', 'groupSelectsFiltered', 'groupRemoveSingleChildren', 'enableRtlSupport'
	    ];
	    ComponentUtil.FUNCTION_PROPERTIES = ['headerCellRenderer', 'localeTextFunc', 'groupRowInnerRenderer', 'groupRowInnerRendererFramework',
	        'groupRowRenderer', 'groupRowRendererFramework', 'isScrollLag', 'isExternalFilterPresent', 'getRowHeight',
	        'doesExternalFilterPass', 'getRowClass', 'getRowStyle', 'getHeaderCellTemplate', 'traverseNode',
	        'getContextMenuItems', 'getMainMenuItems', 'processRowPostCreate', 'processCellForClipboard',
	        'getNodeChildDetails', 'groupRowAggNodes', 'getRowNodeId', 'isFullWidthCell', 'fullWidthCellRenderer',
	        'fullWidthCellRendererFramework', 'doesDataFlower', 'processSecondaryColDef', 'processSecondaryColGroupDef',
	        'getBusinessKeyForNode', 'checkboxSelection'];
	    ComponentUtil.ALL_PROPERTIES = ComponentUtil.ARRAY_PROPERTIES
	        .concat(ComponentUtil.OBJECT_PROPERTIES)
	        .concat(ComponentUtil.STRING_PROPERTIES)
	        .concat(ComponentUtil.NUMBER_PROPERTIES)
	        .concat(ComponentUtil.FUNCTION_PROPERTIES)
	        .concat(ComponentUtil.BOOLEAN_PROPERTIES);
	    return ComponentUtil;
	})();
	exports.ComponentUtil = ComponentUtil;
	utils_1.Utils.iterateObject(events_1.Events, function (key, value) {
	    ComponentUtil.EVENTS.push(value);
	});
	function checkForDeprecated(changes) {
	    if (changes.ready || changes.onReady) {
	        console.warn('ag-grid: as of v3.3 ready event is now called gridReady, so the callback should be onGridReady');
	    }
	    if (changes.rowDeselected || changes.onRowDeselected) {
	        console.warn('ag-grid: as of v3.4 rowDeselected no longer exists. Please check the docs.');
	    }
	}


/***/ },
/* 10 */
/***/ function(module, exports) {

	/**
	 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
	 * @version v7.0.2
	 * @link http://www.ag-grid.com/
	 * @license MIT
	 */
	var Events = (function () {
	    function Events() {
	    }
	    /** A new set of columns has been entered, everything has potentially changed. */
	    Events.EVENT_COLUMN_EVERYTHING_CHANGED = 'columnEverythingChanged';
	    Events.EVENT_NEW_COLUMNS_LOADED = 'newColumnsLoaded';
	    /** The reduce flag was changed */
	    Events.EVENT_COLUMN_PIVOT_MODE_CHANGED = 'columnPivotModeChanged';
	    /** A row group column was added, removed or order changed. */
	    Events.EVENT_COLUMN_ROW_GROUP_CHANGED = 'columnRowGroupChanged';
	    /** A pivot column was added, removed or order changed. */
	    Events.EVENT_COLUMN_PIVOT_CHANGED = 'columnPivotChanged';
	    /** The list of grid columns has changed. */
	    Events.EVENT_GRID_COLUMNS_CHANGED = 'gridColumnsChanged';
	    /** A value column was added, removed or agg function was changed. */
	    Events.EVENT_COLUMN_VALUE_CHANGED = 'columnValueChanged';
	    /** A column was moved */
	    Events.EVENT_COLUMN_MOVED = 'columnMoved';
	    /** One or more columns was shown / hidden */
	    Events.EVENT_COLUMN_VISIBLE = 'columnVisible';
	    /** One or more columns was pinned / unpinned*/
	    Events.EVENT_COLUMN_PINNED = 'columnPinned';
	    /** A column group was opened / closed */
	    Events.EVENT_COLUMN_GROUP_OPENED = 'columnGroupOpened';
	    /** One or more columns was resized. If just one, the column in the event is set. */
	    Events.EVENT_COLUMN_RESIZED = 'columnResized';
	    /** The list of displayed columns has changed, can result from columns open / close, column move, pivot, group, etc */
	    Events.EVENT_DISPLAYED_COLUMNS_CHANGED = 'displayedColumnsChanged';
	    /** The list of virtual columns has changed, results from viewport changing */
	    Events.EVENT_VIRTUAL_COLUMNS_CHANGED = 'virtualColumnsChanged';
	    /** A row group was opened / closed */
	    Events.EVENT_ROW_GROUP_OPENED = 'rowGroupOpened';
	    Events.EVENT_ROW_DATA_CHANGED = 'rowDataChanged';
	    Events.EVENT_FLOATING_ROW_DATA_CHANGED = 'floatingRowDataChanged';
	    Events.EVENT_RANGE_SELECTION_CHANGED = 'rangeSelectionChanged';
	    Events.EVENT_COLUMN_ROW_GROUP_CHANGE_REQUEST = 'columnRowGroupChangeRequest';
	    Events.EVENT_COLUMN_PIVOT_CHANGE_REQUEST = 'columnPivotChangeRequest';
	    Events.EVENT_COLUMN_VALUE_CHANGE_REQUEST = 'columnValueChangeRequest';
	    Events.EVENT_COLUMN_AGG_FUNC_CHANGE_REQUEST = 'columnAggFuncChangeRequest';
	    Events.EVENT_FLASH_CELLS = 'clipboardPaste';
	    Events.EVENT_MODEL_UPDATED = 'modelUpdated';
	    Events.EVENT_CELL_CLICKED = 'cellClicked';
	    Events.EVENT_CELL_DOUBLE_CLICKED = 'cellDoubleClicked';
	    Events.EVENT_CELL_CONTEXT_MENU = 'cellContextMenu';
	    Events.EVENT_CELL_VALUE_CHANGED = 'cellValueChanged';
	    Events.EVENT_ROW_VALUE_CHANGED = 'rowValueChanged';
	    Events.EVENT_CELL_FOCUSED = 'cellFocused';
	    Events.EVENT_ROW_SELECTED = 'rowSelected';
	    Events.EVENT_SELECTION_CHANGED = 'selectionChanged';
	    Events.EVENT_BEFORE_FILTER_CHANGED = 'beforeFilterChanged';
	    Events.EVENT_FILTER_CHANGED = 'filterChanged';
	    Events.EVENT_AFTER_FILTER_CHANGED = 'afterFilterChanged';
	    Events.EVENT_FILTER_MODIFIED = 'filterModified';
	    Events.EVENT_BEFORE_SORT_CHANGED = 'beforeSortChanged';
	    Events.EVENT_SORT_CHANGED = 'sortChanged';
	    Events.EVENT_AFTER_SORT_CHANGED = 'afterSortChanged';
	    Events.EVENT_VIRTUAL_ROW_REMOVED = 'virtualRowRemoved';
	    Events.EVENT_ROW_CLICKED = 'rowClicked';
	    Events.EVENT_ROW_DOUBLE_CLICKED = 'rowDoubleClicked';
	    Events.EVENT_GRID_READY = 'gridReady';
	    Events.EVENT_GRID_SIZE_CHANGED = 'gridSizeChanged';
	    Events.EVENT_VIEWPORT_CHANGED = 'viewportChanged';
	    Events.EVENT_DRAG_STARTED = 'dragStarted';
	    Events.EVENT_DRAG_STOPPED = 'dragStopped';
	    Events.EVENT_ITEMS_ADDED = 'itemsAdded';
	    Events.EVENT_ITEMS_REMOVED = 'itemsRemoved';
	    Events.EVENT_BODY_SCROLL = 'bodyScroll';
	    return Events;
	})();
	exports.Events = Events;


/***/ },
/* 11 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
	 * @version v7.0.2
	 * @link http://www.ag-grid.com/
	 * @license MIT
	 */
	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var csvCreator_1 = __webpack_require__(12);
	var rowRenderer_1 = __webpack_require__(23);
	var headerRenderer_1 = __webpack_require__(66);
	var filterManager_1 = __webpack_require__(43);
	var columnController_1 = __webpack_require__(13);
	var selectionController_1 = __webpack_require__(28);
	var gridOptionsWrapper_1 = __webpack_require__(3);
	var gridPanel_1 = __webpack_require__(24);
	var valueService_1 = __webpack_require__(29);
	var masterSlaveService_1 = __webpack_require__(25);
	var eventService_1 = __webpack_require__(4);
	var floatingRowModel_1 = __webpack_require__(26);
	var constants_1 = __webpack_require__(8);
	var context_1 = __webpack_require__(6);
	var gridCore_1 = __webpack_require__(40);
	var sortController_1 = __webpack_require__(42);
	var paginationController_1 = __webpack_require__(41);
	var focusedCellController_1 = __webpack_require__(35);
	var gridCell_1 = __webpack_require__(33);
	var utils_1 = __webpack_require__(7);
	var cellRendererFactory_1 = __webpack_require__(55);
	var cellEditorFactory_1 = __webpack_require__(48);
	var GridApi = (function () {
	    function GridApi() {
	    }
	    GridApi.prototype.init = function () {
	        switch (this.rowModel.getType()) {
	            case constants_1.Constants.ROW_MODEL_TYPE_NORMAL:
	            case constants_1.Constants.ROW_MODEL_TYPE_PAGINATION:
	                this.inMemoryRowModel = this.rowModel;
	                break;
	            case constants_1.Constants.ROW_MODEL_TYPE_VIRTUAL:
	                this.virtualPageRowModel = this.rowModel;
	                break;
	        }
	    };
	    /** Used internally by grid. Not intended to be used by the client. Interface may change between releases. */
	    GridApi.prototype.__getMasterSlaveService = function () {
	        return this.masterSlaveService;
	    };
	    GridApi.prototype.getFirstRenderedRow = function () {
	        return this.rowRenderer.getFirstVirtualRenderedRow();
	    };
	    GridApi.prototype.getLastRenderedRow = function () {
	        return this.rowRenderer.getLastVirtualRenderedRow();
	    };
	    GridApi.prototype.getDataAsCsv = function (params) {
	        return this.csvCreator.getDataAsCsv(params);
	    };
	    GridApi.prototype.exportDataAsCsv = function (params) {
	        this.csvCreator.exportDataAsCsv(params);
	    };
	    GridApi.prototype.setDatasource = function (datasource) {
	        if (this.gridOptionsWrapper.isRowModelPagination()) {
	            this.paginationController.setDatasource(datasource);
	        }
	        else if (this.gridOptionsWrapper.isRowModelVirtual()) {
	            this.rowModel.setDatasource(datasource);
	        }
	        else {
	            console.warn("ag-Grid: you can only use a datasource when gridOptions.rowModelType is '" + constants_1.Constants.ROW_MODEL_TYPE_VIRTUAL + "' or '" + constants_1.Constants.ROW_MODEL_TYPE_PAGINATION + "'");
	        }
	    };
	    GridApi.prototype.setViewportDatasource = function (viewportDatasource) {
	        if (this.gridOptionsWrapper.isRowModelViewport()) {
	            // this is bad coding, because it's using an interface that's exposed in the enterprise.
	            // really we should create an interface in the core for viewportDatasource and let
	            // the enterprise implement it, rather than casting to 'any' here
	            this.rowModel.setViewportDatasource(viewportDatasource);
	        }
	        else {
	            console.warn("ag-Grid: you can only use a viewport datasource when gridOptions.rowModelType is '" + constants_1.Constants.ROW_MODEL_TYPE_VIEWPORT + "'");
	        }
	    };
	    GridApi.prototype.setRowData = function (rowData) {
	        if (this.gridOptionsWrapper.isRowModelDefault()) {
	            this.selectionController.reset();
	            this.inMemoryRowModel.setRowData(rowData, true);
	        }
	        else {
	            console.log('cannot call setRowData unless using normal row model');
	        }
	    };
	    GridApi.prototype.setFloatingTopRowData = function (rows) {
	        this.floatingRowModel.setFloatingTopRowData(rows);
	    };
	    GridApi.prototype.setFloatingBottomRowData = function (rows) {
	        this.floatingRowModel.setFloatingBottomRowData(rows);
	    };
	    GridApi.prototype.getFloatingTopRowCount = function () {
	        return this.floatingRowModel.getFloatingTopRowCount();
	    };
	    GridApi.prototype.getFloatingBottomRowCount = function () {
	        return this.floatingRowModel.getFloatingBottomRowCount();
	    };
	    GridApi.prototype.getFloatingTopRow = function (index) {
	        return this.floatingRowModel.getFloatingTopRow(index);
	    };
	    GridApi.prototype.getFloatingBottomRow = function (index) {
	        return this.floatingRowModel.getFloatingBottomRow(index);
	    };
	    GridApi.prototype.setColumnDefs = function (colDefs) {
	        this.columnController.setColumnDefs(colDefs);
	    };
	    GridApi.prototype.refreshRows = function (rowNodes) {
	        this.rowRenderer.refreshRows(rowNodes);
	    };
	    GridApi.prototype.refreshCells = function (rowNodes, colIds, animate) {
	        if (animate === void 0) { animate = false; }
	        this.rowRenderer.refreshCells(rowNodes, colIds, animate);
	    };
	    GridApi.prototype.rowDataChanged = function (rows) {
	        console.log('ag-Grid: rowDataChanged is deprecated, either call refreshView() to refresh everything, or call rowNode.setRowData(newData) to set value on a particular node');
	        this.refreshView();
	    };
	    GridApi.prototype.refreshView = function () {
	        this.rowRenderer.refreshView();
	    };
	    GridApi.prototype.setFunctionsReadOnly = function (readOnly) {
	        this.gridOptionsWrapper.setProperty('functionsReadOnly', readOnly);
	    };
	    GridApi.prototype.softRefreshView = function () {
	        this.rowRenderer.softRefreshView();
	    };
	    GridApi.prototype.refreshGroupRows = function () {
	        this.rowRenderer.refreshGroupRows();
	    };
	    GridApi.prototype.refreshHeader = function () {
	        // need to review this - the refreshHeader should also refresh all icons in the header
	        this.headerRenderer.refreshHeader();
	    };
	    GridApi.prototype.isAnyFilterPresent = function () {
	        return this.filterManager.isAnyFilterPresent();
	    };
	    GridApi.prototype.isAdvancedFilterPresent = function () {
	        return this.filterManager.isAdvancedFilterPresent();
	    };
	    GridApi.prototype.isQuickFilterPresent = function () {
	        return this.filterManager.isQuickFilterPresent();
	    };
	    GridApi.prototype.getModel = function () {
	        return this.rowModel;
	    };
	    GridApi.prototype.onGroupExpandedOrCollapsed = function (deprecated_refreshFromIndex) {
	        if (utils_1.Utils.missing(this.inMemoryRowModel)) {
	            console.log('ag-Grid: cannot call onGroupExpandedOrCollapsed unless using normal row model');
	        }
	        if (utils_1.Utils.exists(deprecated_refreshFromIndex)) {
	            console.log('ag-Grid: api.onGroupExpandedOrCollapsed - refreshFromIndex parameter is not longer used, the grid will refresh all rows');
	        }
	        // we don't really want the user calling this if one one rowNode was expanded, instead they should be
	        // calling rowNode.setExpanded(boolean) - this way we do a 'keepRenderedRows=false' so that the whole
	        // grid gets refreshed again - otherwise the row with the rowNodes that were changed won't get updated,
	        // and thus the expand icon in the group cell won't get 'opened' or 'closed'.
	        this.inMemoryRowModel.refreshModel({ step: constants_1.Constants.STEP_MAP });
	    };
	    GridApi.prototype.refreshInMemoryRowModel = function () {
	        if (utils_1.Utils.missing(this.inMemoryRowModel)) {
	            console.log('cannot call refreshInMemoryRowModel unless using normal row model');
	        }
	        this.inMemoryRowModel.refreshModel({ step: constants_1.Constants.STEP_EVERYTHING });
	    };
	    GridApi.prototype.expandAll = function () {
	        if (utils_1.Utils.missing(this.inMemoryRowModel)) {
	            console.log('cannot call expandAll unless using normal row model');
	        }
	        this.inMemoryRowModel.expandOrCollapseAll(true);
	    };
	    GridApi.prototype.collapseAll = function () {
	        if (utils_1.Utils.missing(this.inMemoryRowModel)) {
	            console.log('cannot call collapseAll unless using normal row model');
	        }
	        this.inMemoryRowModel.expandOrCollapseAll(false);
	    };
	    GridApi.prototype.addVirtualRowListener = function (eventName, rowIndex, callback) {
	        if (typeof eventName !== 'string') {
	            console.log('ag-Grid: addVirtualRowListener is deprecated, please use addRenderedRowListener.');
	        }
	        this.addRenderedRowListener(eventName, rowIndex, callback);
	    };
	    GridApi.prototype.addRenderedRowListener = function (eventName, rowIndex, callback) {
	        if (eventName === 'virtualRowRemoved') {
	            console.log('ag-Grid: event virtualRowRemoved is deprecated, now called renderedRowRemoved');
	            eventName = '' +
	                '';
	        }
	        if (eventName === 'virtualRowSelected') {
	            console.log('ag-Grid: event virtualRowSelected is deprecated, to register for individual row ' +
	                'selection events, add a listener directly to the row node.');
	        }
	        this.rowRenderer.addRenderedRowListener(eventName, rowIndex, callback);
	    };
	    GridApi.prototype.setQuickFilter = function (newFilter) {
	        this.filterManager.setQuickFilter(newFilter);
	    };
	    GridApi.prototype.selectIndex = function (index, tryMulti, suppressEvents) {
	        console.log('ag-Grid: do not use api for selection, call node.setSelected(value) instead');
	        if (suppressEvents) {
	            console.log('ag-Grid: suppressEvents is no longer supported, stop listening for the event if you no longer want it');
	        }
	        this.selectionController.selectIndex(index, tryMulti);
	    };
	    GridApi.prototype.deselectIndex = function (index, suppressEvents) {
	        if (suppressEvents === void 0) { suppressEvents = false; }
	        console.log('ag-Grid: do not use api for selection, call node.setSelected(value) instead');
	        if (suppressEvents) {
	            console.log('ag-Grid: suppressEvents is no longer supported, stop listening for the event if you no longer want it');
	        }
	        this.selectionController.deselectIndex(index);
	    };
	    GridApi.prototype.selectNode = function (node, tryMulti, suppressEvents) {
	        if (tryMulti === void 0) { tryMulti = false; }
	        if (suppressEvents === void 0) { suppressEvents = false; }
	        console.log('ag-Grid: API for selection is deprecated, call node.setSelected(value) instead');
	        if (suppressEvents) {
	            console.log('ag-Grid: suppressEvents is no longer supported, stop listening for the event if you no longer want it');
	        }
	        node.setSelectedParams({ newValue: true, clearSelection: !tryMulti });
	    };
	    GridApi.prototype.deselectNode = function (node, suppressEvents) {
	        if (suppressEvents === void 0) { suppressEvents = false; }
	        console.log('ag-Grid: API for selection is deprecated, call node.setSelected(value) instead');
	        if (suppressEvents) {
	            console.log('ag-Grid: suppressEvents is no longer supported, stop listening for the event if you no longer want it');
	        }
	        node.setSelectedParams({ newValue: false });
	    };
	    GridApi.prototype.selectAll = function () {
	        this.selectionController.selectAllRowNodes();
	    };
	    GridApi.prototype.deselectAll = function () {
	        this.selectionController.deselectAllRowNodes();
	    };
	    GridApi.prototype.recomputeAggregates = function () {
	        if (utils_1.Utils.missing(this.inMemoryRowModel)) {
	            console.log('cannot call recomputeAggregates unless using normal row model');
	        }
	        this.inMemoryRowModel.refreshModel({ step: constants_1.Constants.STEP_AGGREGATE });
	    };
	    GridApi.prototype.sizeColumnsToFit = function () {
	        if (this.gridOptionsWrapper.isForPrint()) {
	            console.warn('ag-grid: sizeColumnsToFit does not work when forPrint=true');
	            return;
	        }
	        this.gridPanel.sizeColumnsToFit();
	    };
	    GridApi.prototype.showLoadingOverlay = function () {
	        this.gridPanel.showLoadingOverlay();
	    };
	    GridApi.prototype.showNoRowsOverlay = function () {
	        this.gridPanel.showNoRowsOverlay();
	    };
	    GridApi.prototype.hideOverlay = function () {
	        this.gridPanel.hideOverlay();
	    };
	    GridApi.prototype.isNodeSelected = function (node) {
	        console.log('ag-Grid: no need to call api.isNodeSelected(), just call node.isSelected() instead');
	        return node.isSelected();
	    };
	    GridApi.prototype.getSelectedNodesById = function () {
	        console.error('ag-Grid: since version 3.4, getSelectedNodesById no longer exists, use getSelectedNodes() instead');
	        return null;
	    };
	    GridApi.prototype.getSelectedNodes = function () {
	        return this.selectionController.getSelectedNodes();
	    };
	    GridApi.prototype.getSelectedRows = function () {
	        return this.selectionController.getSelectedRows();
	    };
	    GridApi.prototype.getBestCostNodeSelection = function () {
	        return this.selectionController.getBestCostNodeSelection();
	    };
	    GridApi.prototype.getRenderedNodes = function () {
	        return this.rowRenderer.getRenderedNodes();
	    };
	    GridApi.prototype.ensureColIndexVisible = function (index) {
	        console.warn('ag-Grid: ensureColIndexVisible(index) no longer supported, use ensureColumnVisible(colKey) instead.');
	    };
	    GridApi.prototype.ensureColumnVisible = function (key) {
	        this.gridPanel.ensureColumnVisible(key);
	    };
	    GridApi.prototype.ensureIndexVisible = function (index) {
	        this.gridPanel.ensureIndexVisible(index);
	    };
	    GridApi.prototype.ensureNodeVisible = function (comparator) {
	        this.gridCore.ensureNodeVisible(comparator);
	    };
	    GridApi.prototype.forEachLeafNode = function (callback) {
	        if (utils_1.Utils.missing(this.inMemoryRowModel)) {
	            console.log('cannot call forEachNodeAfterFilter unless using normal row model');
	        }
	        this.inMemoryRowModel.forEachLeafNode(callback);
	    };
	    GridApi.prototype.forEachNode = function (callback) {
	        this.rowModel.forEachNode(callback);
	    };
	    GridApi.prototype.forEachNodeAfterFilter = function (callback) {
	        if (utils_1.Utils.missing(this.inMemoryRowModel)) {
	            console.log('cannot call forEachNodeAfterFilter unless using normal row model');
	        }
	        this.inMemoryRowModel.forEachNodeAfterFilter(callback);
	    };
	    GridApi.prototype.forEachNodeAfterFilterAndSort = function (callback) {
	        if (utils_1.Utils.missing(this.inMemoryRowModel)) {
	            console.log('cannot call forEachNodeAfterFilterAndSort unless using normal row model');
	        }
	        this.inMemoryRowModel.forEachNodeAfterFilterAndSort(callback);
	    };
	    GridApi.prototype.getFilterApiForColDef = function (colDef) {
	        console.warn('ag-grid API method getFilterApiForColDef deprecated, use getFilterApi instead');
	        return this.getFilterInstance(colDef);
	    };
	    GridApi.prototype.getFilterInstance = function (key) {
	        var column = this.columnController.getPrimaryColumn(key);
	        if (column) {
	            return this.filterManager.getFilterComponent(column);
	        }
	    };
	    GridApi.prototype.getFilterApi = function (key) {
	        console.warn('ag-Grid: getFilterApi is deprecated, use getFilterInstance instead');
	        return this.getFilterInstance(key);
	    };
	    GridApi.prototype.destroyFilter = function (key) {
	        var column = this.columnController.getPrimaryColumn(key);
	        if (column) {
	            return this.filterManager.destroyFilter(column);
	        }
	    };
	    GridApi.prototype.getColumnDef = function (key) {
	        var column = this.columnController.getPrimaryColumn(key);
	        if (column) {
	            return column.getColDef();
	        }
	        else {
	            return null;
	        }
	    };
	    GridApi.prototype.onFilterChanged = function () {
	        this.filterManager.onFilterChanged();
	    };
	    GridApi.prototype.setSortModel = function (sortModel) {
	        this.sortController.setSortModel(sortModel);
	    };
	    GridApi.prototype.getSortModel = function () {
	        return this.sortController.getSortModel();
	    };
	    GridApi.prototype.setFilterModel = function (model) {
	        this.filterManager.setFilterModel(model);
	    };
	    GridApi.prototype.getFilterModel = function () {
	        return this.filterManager.getFilterModel();
	    };
	    GridApi.prototype.getFocusedCell = function () {
	        return this.focusedCellController.getFocusedCell();
	    };
	    GridApi.prototype.setFocusedCell = function (rowIndex, colKey, floating) {
	        this.focusedCellController.setFocusedCell(rowIndex, colKey, floating, true);
	    };
	    GridApi.prototype.setHeaderHeight = function (headerHeight) {
	        this.gridOptionsWrapper.setProperty(gridOptionsWrapper_1.GridOptionsWrapper.PROP_HEADER_HEIGHT, headerHeight);
	    };
	    GridApi.prototype.showToolPanel = function (show) {
	        this.gridCore.showToolPanel(show);
	    };
	    GridApi.prototype.isToolPanelShowing = function () {
	        return this.gridCore.isToolPanelShowing();
	    };
	    GridApi.prototype.doLayout = function () {
	        this.gridCore.doLayout();
	    };
	    GridApi.prototype.resetRowHeights = function () {
	        if (utils_1.Utils.exists(this.inMemoryRowModel)) {
	            this.inMemoryRowModel.resetRowHeights();
	        }
	    };
	    GridApi.prototype.onRowHeightChanged = function () {
	        if (utils_1.Utils.exists(this.inMemoryRowModel)) {
	            this.inMemoryRowModel.onRowHeightChanged();
	        }
	    };
	    GridApi.prototype.getValue = function (colKey, rowNode) {
	        var column = this.columnController.getPrimaryColumn(colKey);
	        if (utils_1.Utils.missing(column)) {
	            column = this.columnController.getGridColumn(colKey);
	        }
	        if (utils_1.Utils.missing(column)) {
	            return null;
	        }
	        else {
	            return this.valueService.getValue(column, rowNode);
	        }
	    };
	    GridApi.prototype.addEventListener = function (eventType, listener) {
	        this.eventService.addEventListener(eventType, listener);
	    };
	    GridApi.prototype.addGlobalListener = function (listener) {
	        this.eventService.addGlobalListener(listener);
	    };
	    GridApi.prototype.removeEventListener = function (eventType, listener) {
	        this.eventService.removeEventListener(eventType, listener);
	    };
	    GridApi.prototype.removeGlobalListener = function (listener) {
	        this.eventService.removeGlobalListener(listener);
	    };
	    GridApi.prototype.dispatchEvent = function (eventType, event) {
	        this.eventService.dispatchEvent(eventType, event);
	    };
	    GridApi.prototype.destroy = function () {
	        this.context.destroy();
	    };
	    GridApi.prototype.resetQuickFilter = function () {
	        this.rowModel.forEachNode(function (node) { return node.quickFilterAggregateText = null; });
	    };
	    GridApi.prototype.getRangeSelections = function () {
	        if (this.rangeController) {
	            return this.rangeController.getCellRanges();
	        }
	        else {
	            console.warn('ag-Grid: cell range selection is only available in ag-Grid Enterprise');
	            return null;
	        }
	    };
	    GridApi.prototype.addRangeSelection = function (rangeSelection) {
	        if (!this.rangeController) {
	            console.warn('ag-Grid: cell range selection is only available in ag-Grid Enterprise');
	        }
	        this.rangeController.addRange(rangeSelection);
	    };
	    GridApi.prototype.clearRangeSelection = function () {
	        if (!this.rangeController) {
	            console.warn('ag-Grid: cell range selection is only available in ag-Grid Enterprise');
	        }
	        this.rangeController.clearSelection();
	    };
	    GridApi.prototype.copySelectedRowsToClipboard = function (includeHeader, columnKeys) {
	        if (!this.clipboardService) {
	            console.warn('ag-Grid: clipboard is only available in ag-Grid Enterprise');
	        }
	        var column = null;
	        this.clipboardService.copySelectedRowsToClipboard(includeHeader, columnKeys);
	    };
	    GridApi.prototype.copySelectedRangeToClipboard = function (includeHeader) {
	        if (!this.clipboardService) {
	            console.warn('ag-Grid: clipboard is only available in ag-Grid Enterprise');
	        }
	        this.clipboardService.copySelectedRangeToClipboard(includeHeader);
	    };
	    GridApi.prototype.copySelectedRangeDown = function () {
	        if (!this.clipboardService) {
	            console.warn('ag-Grid: clipboard is only available in ag-Grid Enterprise');
	        }
	        this.clipboardService.copyRangeDown();
	    };
	    GridApi.prototype.showColumnMenuAfterButtonClick = function (colKey, buttonElement) {
	        var column = this.columnController.getPrimaryColumn(colKey);
	        this.menuFactory.showMenuAfterButtonClick(column, buttonElement);
	    };
	    GridApi.prototype.showColumnMenuAfterMouseClick = function (colKey, mouseEvent) {
	        var column = this.columnController.getPrimaryColumn(colKey);
	        this.menuFactory.showMenuAfterMouseEvent(column, mouseEvent);
	    };
	    GridApi.prototype.tabToNextCell = function () {
	        return this.rowRenderer.tabToNextCell(false);
	    };
	    GridApi.prototype.tabToPreviousCell = function () {
	        return this.rowRenderer.tabToNextCell(true);
	    };
	    GridApi.prototype.stopEditing = function (cancel) {
	        if (cancel === void 0) { cancel = false; }
	        this.rowRenderer.stopEditing(cancel);
	    };
	    GridApi.prototype.startEditingCell = function (params) {
	        var column = this.columnController.getGridColumn(params.colKey);
	        var gridCell = new gridCell_1.GridCell(params.rowIndex, null, column);
	        this.rowRenderer.startEditingCell(gridCell, params.keyPress, params.charPress);
	    };
	    GridApi.prototype.addAggFunc = function (key, aggFunc) {
	        if (this.aggFuncService) {
	            this.aggFuncService.addAggFunc(key, aggFunc);
	        }
	    };
	    GridApi.prototype.addAggFuncs = function (aggFuncs) {
	        if (this.aggFuncService) {
	            this.aggFuncService.addAggFuncs(aggFuncs);
	        }
	    };
	    GridApi.prototype.clearAggFuncs = function () {
	        if (this.aggFuncService) {
	            this.aggFuncService.clear();
	        }
	    };
	    GridApi.prototype.insertItemsAtIndex = function (index, items) {
	        this.rowModel.insertItemsAtIndex(index, items);
	    };
	    GridApi.prototype.removeItems = function (rowNodes) {
	        this.rowModel.removeItems(rowNodes);
	    };
	    GridApi.prototype.addItems = function (items) {
	        this.rowModel.addItems(items);
	    };
	    GridApi.prototype.refreshVirtualPageCache = function () {
	        if (this.virtualPageRowModel) {
	            this.virtualPageRowModel.refreshVirtualPageCache();
	        }
	        else {
	            console.warn("ag-Grid: api.refreshVirtualPageCache is only available when rowModelType='virtual'.");
	        }
	    };
	    GridApi.prototype.purgeVirtualPageCache = function () {
	        if (this.virtualPageRowModel) {
	            this.virtualPageRowModel.purgeVirtualPageCache();
	        }
	        else {
	            console.warn("ag-Grid: api.refreshVirtualPageCache is only available when rowModelType='virtual'.");
	        }
	    };
	    GridApi.prototype.getVirtualRowCount = function () {
	        if (this.virtualPageRowModel) {
	            return this.virtualPageRowModel.getVirtualRowCount();
	        }
	        else {
	            console.warn("ag-Grid: api.getVirtualRowCount is only available when rowModelType='virtual'.");
	        }
	    };
	    GridApi.prototype.isMaxRowFound = function () {
	        if (this.virtualPageRowModel) {
	            return this.virtualPageRowModel.isMaxRowFound();
	        }
	        else {
	            console.warn("ag-Grid: api.isMaxRowFound is only available when rowModelType='virtual'.");
	        }
	    };
	    GridApi.prototype.setVirtualRowCount = function (rowCount, maxRowFound) {
	        if (this.virtualPageRowModel) {
	            this.virtualPageRowModel.setVirtualRowCount(rowCount, maxRowFound);
	        }
	        else {
	            console.warn("ag-Grid: api.setVirtualRowCount is only available when rowModelType='virtual'.");
	        }
	    };
	    GridApi.prototype.getVirtualPageState = function () {
	        if (this.virtualPageRowModel) {
	            return this.virtualPageRowModel.getVirtualPageState();
	        }
	        else {
	            console.warn("ag-Grid: api.getVirtualPageState is only available when rowModelType='virtual'.");
	        }
	    };
	    GridApi.prototype.checkGridSize = function () {
	        this.gridPanel.sizeHeaderAndBody();
	    };
	    __decorate([
	        context_1.Autowired('csvCreator'), 
	        __metadata('design:type', csvCreator_1.CsvCreator)
	    ], GridApi.prototype, "csvCreator", void 0);
	    __decorate([
	        context_1.Autowired('gridCore'), 
	        __metadata('design:type', gridCore_1.GridCore)
	    ], GridApi.prototype, "gridCore", void 0);
	    __decorate([
	        context_1.Autowired('rowRenderer'), 
	        __metadata('design:type', rowRenderer_1.RowRenderer)
	    ], GridApi.prototype, "rowRenderer", void 0);
	    __decorate([
	        context_1.Autowired('headerRenderer'), 
	        __metadata('design:type', headerRenderer_1.HeaderRenderer)
	    ], GridApi.prototype, "headerRenderer", void 0);
	    __decorate([
	        context_1.Autowired('filterManager'), 
	        __metadata('design:type', filterManager_1.FilterManager)
	    ], GridApi.prototype, "filterManager", void 0);
	    __decorate([
	        context_1.Autowired('columnController'), 
	        __metadata('design:type', columnController_1.ColumnController)
	    ], GridApi.prototype, "columnController", void 0);
	    __decorate([
	        context_1.Autowired('selectionController'), 
	        __metadata('design:type', selectionController_1.SelectionController)
	    ], GridApi.prototype, "selectionController", void 0);
	    __decorate([
	        context_1.Autowired('gridOptionsWrapper'), 
	        __metadata('design:type', gridOptionsWrapper_1.GridOptionsWrapper)
	    ], GridApi.prototype, "gridOptionsWrapper", void 0);
	    __decorate([
	        context_1.Autowired('gridPanel'), 
	        __metadata('design:type', gridPanel_1.GridPanel)
	    ], GridApi.prototype, "gridPanel", void 0);
	    __decorate([
	        context_1.Autowired('valueService'), 
	        __metadata('design:type', valueService_1.ValueService)
	    ], GridApi.prototype, "valueService", void 0);
	    __decorate([
	        context_1.Autowired('masterSlaveService'), 
	        __metadata('design:type', masterSlaveService_1.MasterSlaveService)
	    ], GridApi.prototype, "masterSlaveService", void 0);
	    __decorate([
	        context_1.Autowired('eventService'), 
	        __metadata('design:type', eventService_1.EventService)
	    ], GridApi.prototype, "eventService", void 0);
	    __decorate([
	        context_1.Autowired('floatingRowModel'), 
	        __metadata('design:type', floatingRowModel_1.FloatingRowModel)
	    ], GridApi.prototype, "floatingRowModel", void 0);
	    __decorate([
	        context_1.Autowired('context'), 
	        __metadata('design:type', context_1.Context)
	    ], GridApi.prototype, "context", void 0);
	    __decorate([
	        context_1.Autowired('rowModel'), 
	        __metadata('design:type', Object)
	    ], GridApi.prototype, "rowModel", void 0);
	    __decorate([
	        context_1.Autowired('sortController'), 
	        __metadata('design:type', sortController_1.SortController)
	    ], GridApi.prototype, "sortController", void 0);
	    __decorate([
	        context_1.Autowired('paginationController'), 
	        __metadata('design:type', paginationController_1.PaginationController)
	    ], GridApi.prototype, "paginationController", void 0);
	    __decorate([
	        context_1.Autowired('focusedCellController'), 
	        __metadata('design:type', focusedCellController_1.FocusedCellController)
	    ], GridApi.prototype, "focusedCellController", void 0);
	    __decorate([
	        context_1.Optional('rangeController'), 
	        __metadata('design:type', Object)
	    ], GridApi.prototype, "rangeController", void 0);
	    __decorate([
	        context_1.Optional('clipboardService'), 
	        __metadata('design:type', Object)
	    ], GridApi.prototype, "clipboardService", void 0);
	    __decorate([
	        context_1.Optional('aggFuncService'), 
	        __metadata('design:type', Object)
	    ], GridApi.prototype, "aggFuncService", void 0);
	    __decorate([
	        context_1.Autowired('menuFactory'), 
	        __metadata('design:type', Object)
	    ], GridApi.prototype, "menuFactory", void 0);
	    __decorate([
	        context_1.Autowired('cellRendererFactory'), 
	        __metadata('design:type', cellRendererFactory_1.CellRendererFactory)
	    ], GridApi.prototype, "cellRendererFactory", void 0);
	    __decorate([
	        context_1.Autowired('cellEditorFactory'), 
	        __metadata('design:type', cellEditorFactory_1.CellEditorFactory)
	    ], GridApi.prototype, "cellEditorFactory", void 0);
	    __decorate([
	        context_1.PostConstruct, 
	        __metadata('design:type', Function), 
	        __metadata('design:paramtypes', []), 
	        __metadata('design:returntype', void 0)
	    ], GridApi.prototype, "init", null);
	    GridApi = __decorate([
	        context_1.Bean('gridApi'), 
	        __metadata('design:paramtypes', [])
	    ], GridApi);
	    return GridApi;
	})();
	exports.GridApi = GridApi;


/***/ },
/* 12 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
	 * @version v7.0.2
	 * @link http://www.ag-grid.com/
	 * @license MIT
	 */
	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var columnController_1 = __webpack_require__(13);
	var valueService_1 = __webpack_require__(29);
	var context_1 = __webpack_require__(6);
	var gridOptionsWrapper_1 = __webpack_require__(3);
	var constants_1 = __webpack_require__(8);
	var floatingRowModel_1 = __webpack_require__(26);
	var utils_1 = __webpack_require__(7);
	var selectionController_1 = __webpack_require__(28);
	var LINE_SEPARATOR = '\r\n';
	var CsvCreator = (function () {
	    function CsvCreator() {
	    }
	    CsvCreator.prototype.exportDataAsCsv = function (params) {
	        var csvString = this.getDataAsCsv(params);
	        var fileNamePresent = params && params.fileName && params.fileName.length !== 0;
	        var fileName = fileNamePresent ? params.fileName : 'export.csv';
	        // for Excel, we need \ufeff at the start
	        // http://stackoverflow.com/questions/17879198/adding-utf-8-bom-to-string-blob
	        var blobObject = new Blob(["\ufeff", csvString], {
	            type: "text/csv;charset=utf-8;"
	        });
	        // Internet Explorer
	        if (window.navigator.msSaveOrOpenBlob) {
	            window.navigator.msSaveOrOpenBlob(blobObject, fileName);
	        }
	        else {
	            // Chrome
	            var downloadLink = document.createElement("a");
	            downloadLink.href = window.URL.createObjectURL(blobObject);
	            downloadLink.download = fileName;
	            document.body.appendChild(downloadLink);
	            downloadLink.click();
	            document.body.removeChild(downloadLink);
	        }
	    };
	    CsvCreator.prototype.getDataAsCsv = function (params) {
	        var skipGroups = params && params.skipGroups;
	        var skipHeader = params && params.skipHeader;
	        var skipFooters = params && params.skipFooters;
	        var skipFloatingTop = params && params.skipFloatingTop;
	        var skipFloatingBottom = params && params.skipFloatingBottom;
	        var includeCustomHeader = params && params.customHeader;
	        var includeCustomFooter = params && params.customFooter;
	        var allColumns = params && params.allColumns;
	        var onlySelected = params && params.onlySelected;
	        var columnSeparator = (params && params.columnSeparator) || ',';
	        var suppressQuotes = params && params.suppressQuotes;
	        var columnKeys = params && params.columnKeys;
	        var onlySelectedAllPages = params && params.onlySelectedAllPages;
	        var processCellCallback = params && params.processCellCallback;
	        var processHeaderCallback = params && params.processHeaderCallback;
	        // when in pivot mode, we always render cols on screen, never 'all columns'
	        var isPivotMode = this.columnController.isPivotMode();
	        var isRowGrouping = this.columnController.getRowGroupColumns().length > 0;
	        var rowModelNormal = this.rowModel.getType() === constants_1.Constants.ROW_MODEL_TYPE_NORMAL;
	        var onlySelectedNonStandardModel = !rowModelNormal && onlySelected;
	        // we can only export if it's a normal row model - unless we are exporting
	        // selected only, as this way we don't use the selected nodes rather than
	        // the row model to get the rows
	        if (!rowModelNormal && !onlySelected) {
	            console.log('ag-Grid: getDataAsCsv is only available for standard row model');
	            return '';
	        }
	        var inMemoryRowModel = this.rowModel;
	        var that = this;
	        var result = '';
	        var columnsToExport;
	        if (utils_1.Utils.existsAndNotEmpty(columnKeys)) {
	            columnsToExport = this.columnController.getGridColumns(columnKeys);
	        }
	        else if (allColumns && !isPivotMode) {
	            columnsToExport = this.columnController.getAllPrimaryColumns();
	        }
	        else {
	            columnsToExport = this.columnController.getAllDisplayedColumns();
	        }
	        if (!columnsToExport || columnsToExport.length === 0) {
	            return '';
	        }
	        if (includeCustomHeader) {
	            result += params.customHeader;
	        }
	        // first pass, put in the header names of the cols
	        if (!skipHeader) {
	            columnsToExport.forEach(processHeaderColumn);
	            result += LINE_SEPARATOR;
	        }
	        this.floatingRowModel.forEachFloatingTopRow(processRow);
	        if (isPivotMode) {
	            inMemoryRowModel.forEachPivotNode(processRow);
	        }
	        else {
	            // onlySelectedAllPages: user doing pagination and wants selected items from
	            // other pages, so cannot use the standard row model as it won't have rows from
	            // other pages.
	            // onlySelectedNonStandardModel: if user wants selected in non standard row model
	            // (eg viewport) then again rowmodel cannot be used, so need to use selected instead.
	            if (onlySelectedAllPages || onlySelectedNonStandardModel) {
	                var selectedNodes = this.selectionController.getSelectedNodes();
	                selectedNodes.forEach(processRow);
	            }
	            else {
	                // here is everything else - including standard row model and selected. we don't use
	                // the selection model even when just using selected, so that the result is the order
	                // of the rows appearing on the screen.
	                inMemoryRowModel.forEachNodeAfterFilterAndSort(processRow);
	            }
	        }
	        this.floatingRowModel.forEachFloatingBottomRow(processRow);
	        if (includeCustomFooter) {
	            result += params.customFooter;
	        }
	        function processRow(node) {
	            if (skipGroups && node.group) {
	                return;
	            }
	            if (skipFooters && node.footer) {
	                return;
	            }
	            if (onlySelected && !node.isSelected()) {
	                return;
	            }
	            if (skipFloatingTop && node.floating === 'top') {
	                return;
	            }
	            if (skipFloatingBottom && node.floating === 'bottom') {
	                return;
	            }
	            // if we are in pivotMode, then the grid will show the root node only
	            // if it's not a leaf group
	            var nodeIsRootNode = node.level === -1;
	            if (nodeIsRootNode && !node.leafGroup) {
	                return;
	            }
	            columnsToExport.forEach(function (column, index) {
	                var valueForCell;
	                if (node.group && isRowGrouping && index === 0) {
	                    valueForCell = that.createValueForGroupNode(node);
	                }
	                else {
	                    valueForCell = that.valueService.getValue(column, node);
	                }
	                valueForCell = that.processCell(node, column, valueForCell, processCellCallback);
	                if (valueForCell === null || valueForCell === undefined) {
	                    valueForCell = '';
	                }
	                if (index != 0) {
	                    result += columnSeparator;
	                }
	                result += that.putInQuotes(valueForCell, suppressQuotes);
	            });
	            result += LINE_SEPARATOR;
	        }
	        function processHeaderColumn(column, index) {
	            var nameForCol = that.getHeaderName(processHeaderCallback, column);
	            if (nameForCol === null || nameForCol === undefined) {
	                nameForCol = '';
	            }
	            if (index != 0) {
	                result += columnSeparator;
	            }
	            result += that.putInQuotes(nameForCol, suppressQuotes);
	        }
	        return result;
	    };
	    CsvCreator.prototype.getHeaderName = function (callback, column) {
	        if (callback) {
	            return callback({
	                column: column,
	                api: this.gridOptionsWrapper.getApi(),
	                columnApi: this.gridOptionsWrapper.getColumnApi(),
	                context: this.gridOptionsWrapper.getContext()
	            });
	        }
	        else {
	            return this.columnController.getDisplayNameForColumn(column, 'csv', true);
	        }
	    };
	    CsvCreator.prototype.processCell = function (rowNode, column, value, processCellCallback) {
	        if (processCellCallback) {
	            return processCellCallback({
	                column: column,
	                node: rowNode,
	                value: value,
	                api: this.gridOptionsWrapper.getApi(),
	                columnApi: this.gridOptionsWrapper.getColumnApi(),
	                context: this.gridOptionsWrapper.getContext()
	            });
	        }
	        else {
	            return value;
	        }
	    };
	    CsvCreator.prototype.createValueForGroupNode = function (node) {
	        var keys = [node.key];
	        while (node.parent) {
	            node = node.parent;
	            keys.push(node.key);
	        }
	        return keys.reverse().join(' -> ');
	    };
	    CsvCreator.prototype.putInQuotes = function (value, suppressQuotes) {
	        if (suppressQuotes) {
	            return value;
	        }
	        if (value === null || value === undefined) {
	            return '""';
	        }
	        var stringValue;
	        if (typeof value === 'string') {
	            stringValue = value;
	        }
	        else if (typeof value.toString === 'function') {
	            stringValue = value.toString();
	        }
	        else {
	            console.warn('unknown value type during csv conversion');
	            stringValue = '';
	        }
	        // replace each " with "" (ie two sets of double quotes is how to do double quotes in csv)
	        var valueEscaped = stringValue.replace(/"/g, "\"\"");
	        return '"' + valueEscaped + '"';
	    };
	    __decorate([
	        context_1.Autowired('rowModel'), 
	        __metadata('design:type', Object)
	    ], CsvCreator.prototype, "rowModel", void 0);
	    __decorate([
	        context_1.Autowired('floatingRowModel'), 
	        __metadata('design:type', floatingRowModel_1.FloatingRowModel)
	    ], CsvCreator.prototype, "floatingRowModel", void 0);
	    __decorate([
	        context_1.Autowired('columnController'), 
	        __metadata('design:type', columnController_1.ColumnController)
	    ], CsvCreator.prototype, "columnController", void 0);
	    __decorate([
	        context_1.Autowired('valueService'), 
	        __metadata('design:type', valueService_1.ValueService)
	    ], CsvCreator.prototype, "valueService", void 0);
	    __decorate([
	        context_1.Autowired('gridOptionsWrapper'), 
	        __metadata('design:type', gridOptionsWrapper_1.GridOptionsWrapper)
	    ], CsvCreator.prototype, "gridOptionsWrapper", void 0);
	    __decorate([
	        context_1.Autowired('selectionController'), 
	        __metadata('design:type', selectionController_1.SelectionController)
	    ], CsvCreator.prototype, "selectionController", void 0);
	    CsvCreator = __decorate([
	        context_1.Bean('csvCreator'), 
	        __metadata('design:paramtypes', [])
	    ], CsvCreator);
	    return CsvCreator;
	})();
	exports.CsvCreator = CsvCreator;


/***/ },
/* 13 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
	 * @version v7.0.2
	 * @link http://www.ag-grid.com/
	 * @license MIT
	 */
	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var __param = (this && this.__param) || function (paramIndex, decorator) {
	    return function (target, key) { decorator(target, key, paramIndex); }
	};
	var utils_1 = __webpack_require__(7);
	var columnGroup_1 = __webpack_require__(14);
	var column_1 = __webpack_require__(15);
	var gridOptionsWrapper_1 = __webpack_require__(3);
	var expressionService_1 = __webpack_require__(18);
	var balancedColumnTreeBuilder_1 = __webpack_require__(19);
	var displayedGroupCreator_1 = __webpack_require__(21);
	var autoWidthCalculator_1 = __webpack_require__(22);
	var eventService_1 = __webpack_require__(4);
	var columnUtils_1 = __webpack_require__(16);
	var logger_1 = __webpack_require__(5);
	var events_1 = __webpack_require__(10);
	var columnChangeEvent_1 = __webpack_require__(79);
	var originalColumnGroup_1 = __webpack_require__(17);
	var groupInstanceIdCreator_1 = __webpack_require__(80);
	var functions_1 = __webpack_require__(81);
	var context_1 = __webpack_require__(6);
	var gridPanel_1 = __webpack_require__(24);
	var ColumnApi = (function () {
	    function ColumnApi() {
	    }
	    ColumnApi.prototype.sizeColumnsToFit = function (gridWidth) { this._columnController.sizeColumnsToFit(gridWidth); };
	    ColumnApi.prototype.setColumnGroupOpened = function (group, newValue, instanceId) { this._columnController.setColumnGroupOpened(group, newValue, instanceId); };
	    ColumnApi.prototype.getColumnGroup = function (name, instanceId) { return this._columnController.getColumnGroup(name, instanceId); };
	    ColumnApi.prototype.getDisplayNameForColumn = function (column, location) { return this._columnController.getDisplayNameForColumn(column, location); };
	    ColumnApi.prototype.getDisplayNameForColumnGroup = function (columnGroup, location) { return this._columnController.getDisplayNameForColumnGroup(columnGroup, location); };
	    ColumnApi.prototype.getColumn = function (key) { return this._columnController.getPrimaryColumn(key); };
	    ColumnApi.prototype.setColumnState = function (columnState) { return this._columnController.setColumnState(columnState); };
	    ColumnApi.prototype.getColumnState = function () { return this._columnController.getColumnState(); };
	    ColumnApi.prototype.resetColumnState = function () { this._columnController.resetColumnState(); };
	    ColumnApi.prototype.isPinning = function () { return this._columnController.isPinningLeft() || this._columnController.isPinningRight(); };
	    ColumnApi.prototype.isPinningLeft = function () { return this._columnController.isPinningLeft(); };
	    ColumnApi.prototype.isPinningRight = function () { return this._columnController.isPinningRight(); };
	    ColumnApi.prototype.getDisplayedColAfter = function (col) { return this._columnController.getDisplayedColAfter(col); };
	    ColumnApi.prototype.getDisplayedColBefore = function (col) { return this._columnController.getDisplayedColBefore(col); };
	    ColumnApi.prototype.setColumnVisible = function (key, visible) { this._columnController.setColumnVisible(key, visible); };
	    ColumnApi.prototype.setColumnsVisible = function (keys, visible) { this._columnController.setColumnsVisible(keys, visible); };
	    ColumnApi.prototype.setColumnPinned = function (key, pinned) { this._columnController.setColumnPinned(key, pinned); };
	    ColumnApi.prototype.setColumnsPinned = function (keys, pinned) { this._columnController.setColumnsPinned(keys, pinned); };
	    ColumnApi.prototype.getAllColumns = function () { return this._columnController.getAllPrimaryColumns(); };
	    ColumnApi.prototype.getAllGridColumns = function () { return this._columnController.getAllGridColumns(); };
	    ColumnApi.prototype.getDisplayedLeftColumns = function () { return this._columnController.getDisplayedLeftColumns(); };
	    ColumnApi.prototype.getDisplayedCenterColumns = function () { return this._columnController.getDisplayedCenterColumns(); };
	    ColumnApi.prototype.getDisplayedRightColumns = function () { return this._columnController.getDisplayedRightColumns(); };
	    ColumnApi.prototype.getAllDisplayedColumns = function () { return this._columnController.getAllDisplayedColumns(); };
	    ColumnApi.prototype.getAllDisplayedVirtualColumns = function () { return this._columnController.getAllDisplayedVirtualColumns(); };
	    ColumnApi.prototype.moveColumn = function (key, toIndex) {
	        if (typeof key === 'number') {
	            // moveColumn used to take indexes, so this is advising user who hasn't moved to new method name
	            console.log('ag-Grid: you are using moveColumn(fromIndex, toIndex) - moveColumn takes a column key and a destination index, not two indexes, to move with indexes use moveColumnByIndex(from,to) instead');
	            this._columnController.moveColumnByIndex(key, toIndex);
	        }
	        else {
	            this._columnController.moveColumn(key, toIndex);
	        }
	    };
	    ColumnApi.prototype.moveColumnByIndex = function (fromIndex, toIndex) { this._columnController.moveColumnByIndex(fromIndex, toIndex); };
	    ColumnApi.prototype.moveColumns = function (columnsToMoveKeys, toIndex) { this._columnController.moveColumns(columnsToMoveKeys, toIndex); };
	    ColumnApi.prototype.moveRowGroupColumn = function (fromIndex, toIndex) { this._columnController.moveRowGroupColumn(fromIndex, toIndex); };
	    ColumnApi.prototype.setColumnAggFunc = function (column, aggFunc) { this._columnController.setColumnAggFunc(column, aggFunc); };
	    ColumnApi.prototype.setColumnWidth = function (key, newWidth, finished) {
	        if (finished === void 0) { finished = true; }
	        this._columnController.setColumnWidth(key, newWidth, finished);
	    };
	    ColumnApi.prototype.setPivotMode = function (pivotMode) { this._columnController.setPivotMode(pivotMode); };
	    ColumnApi.prototype.isPivotMode = function () { return this._columnController.isPivotMode(); };
	    ColumnApi.prototype.getSecondaryPivotColumn = function (pivotKeys, valueColKey) { return this._columnController.getSecondaryPivotColumn(pivotKeys, valueColKey); };
	    ColumnApi.prototype.setValueColumns = function (colKeys) { this._columnController.setValueColumns(colKeys); };
	    ColumnApi.prototype.getValueColumns = function () { return this._columnController.getValueColumns(); };
	    ColumnApi.prototype.removeValueColumn = function (colKey) { this._columnController.removeValueColumn(colKey); };
	    ColumnApi.prototype.removeValueColumns = function (colKeys) { this._columnController.removeValueColumns(colKeys); };
	    ColumnApi.prototype.addValueColumn = function (colKey) { this._columnController.addValueColumn(colKey); };
	    ColumnApi.prototype.addValueColumns = function (colKeys) { this._columnController.addValueColumns(colKeys); };
	    ColumnApi.prototype.setRowGroupColumns = function (colKeys) { this._columnController.setRowGroupColumns(colKeys); };
	    ColumnApi.prototype.removeRowGroupColumn = function (colKey) { this._columnController.removeRowGroupColumn(colKey); };
	    ColumnApi.prototype.removeRowGroupColumns = function (colKeys) { this._columnController.removeRowGroupColumns(colKeys); };
	    ColumnApi.prototype.addRowGroupColumn = function (colKey) { this._columnController.addRowGroupColumn(colKey); };
	    ColumnApi.prototype.addRowGroupColumns = function (colKeys) { this._columnController.addRowGroupColumns(colKeys); };
	    ColumnApi.prototype.getRowGroupColumns = function () { return this._columnController.getRowGroupColumns(); };
	    ColumnApi.prototype.setPivotColumns = function (colKeys) { this._columnController.setPivotColumns(colKeys); };
	    ColumnApi.prototype.removePivotColumn = function (colKey) { this._columnController.removePivotColumn(colKey); };
	    ColumnApi.prototype.removePivotColumns = function (colKeys) { this._columnController.removePivotColumns(colKeys); };
	    ColumnApi.prototype.addPivotColumn = function (colKey) { this._columnController.addPivotColumn(colKey); };
	    ColumnApi.prototype.addPivotColumns = function (colKeys) { this._columnController.addPivotColumns(colKeys); };
	    ColumnApi.prototype.getPivotColumns = function () { return this._columnController.getPivotColumns(); };
	    ColumnApi.prototype.getLeftDisplayedColumnGroups = function () { return this._columnController.getLeftDisplayedColumnGroups(); };
	    ColumnApi.prototype.getCenterDisplayedColumnGroups = function () { return this._columnController.getCenterDisplayedColumnGroups(); };
	    ColumnApi.prototype.getRightDisplayedColumnGroups = function () { return this._columnController.getRightDisplayedColumnGroups(); };
	    ColumnApi.prototype.getAllDisplayedColumnGroups = function () { return this._columnController.getAllDisplayedColumnGroups(); };
	    ColumnApi.prototype.autoSizeColumn = function (key) { return this._columnController.autoSizeColumn(key); };
	    ColumnApi.prototype.autoSizeColumns = function (keys) { return this._columnController.autoSizeColumns(keys); };
	    ColumnApi.prototype.autoSizeAllColumns = function () { this._columnController.autoSizeAllColumns(); };
	    ColumnApi.prototype.setSecondaryColumns = function (colDefs) { this._columnController.setSecondaryColumns(colDefs); };
	    // below goes through deprecated items, prints message to user, then calls the new version of the same method
	    ColumnApi.prototype.columnGroupOpened = function (group, newValue) {
	        console.error('ag-Grid: columnGroupOpened no longer exists, use setColumnGroupOpened');
	        this.setColumnGroupOpened(group, newValue);
	    };
	    ColumnApi.prototype.hideColumns = function (colIds, hide) {
	        console.error('ag-Grid: hideColumns is deprecated, use setColumnsVisible');
	        this._columnController.setColumnsVisible(colIds, !hide);
	    };
	    ColumnApi.prototype.hideColumn = function (colId, hide) {
	        console.error('ag-Grid: hideColumn is deprecated, use setColumnVisible');
	        this._columnController.setColumnVisible(colId, !hide);
	    };
	    ColumnApi.prototype.setState = function (columnState) {
	        console.error('ag-Grid: setState is deprecated, use setColumnState');
	        return this.setColumnState(columnState);
	    };
	    ColumnApi.prototype.getState = function () {
	        console.error('ag-Grid: getState is deprecated, use getColumnState');
	        return this.getColumnState();
	    };
	    ColumnApi.prototype.resetState = function () {
	        console.error('ag-Grid: resetState is deprecated, use resetColumnState');
	        this.resetColumnState();
	    };
	    ColumnApi.prototype.getAggregationColumns = function () {
	        console.error('ag-Grid: getAggregationColumns is deprecated, use getValueColumns');
	        return this._columnController.getValueColumns();
	    };
	    ColumnApi.prototype.removeAggregationColumn = function (colKey) {
	        console.error('ag-Grid: removeAggregationColumn is deprecated, use removeValueColumn');
	        this._columnController.removeValueColumn(colKey);
	    };
	    ColumnApi.prototype.removeAggregationColumns = function (colKeys) {
	        console.error('ag-Grid: removeAggregationColumns is deprecated, use removeValueColumns');
	        this._columnController.removeValueColumns(colKeys);
	    };
	    ColumnApi.prototype.addAggregationColumn = function (colKey) {
	        console.error('ag-Grid: addAggregationColumn is deprecated, use addValueColumn');
	        this._columnController.addValueColumn(colKey);
	    };
	    ColumnApi.prototype.addAggregationColumns = function (colKeys) {
	        console.error('ag-Grid: addAggregationColumns is deprecated, use addValueColumns');
	        this._columnController.addValueColumns(colKeys);
	    };
	    ColumnApi.prototype.setColumnAggFunction = function (column, aggFunc) {
	        console.error('ag-Grid: setColumnAggFunction is deprecated, use setColumnAggFunc');
	        this._columnController.setColumnAggFunc(column, aggFunc);
	    };
	    ColumnApi.prototype.getDisplayNameForCol = function (column) {
	        console.error('ag-Grid: getDisplayNameForCol is deprecated, use getDisplayNameForColumn');
	        return this.getDisplayNameForColumn(column, null);
	    };
	    __decorate([
	        context_1.Autowired('columnController'), 
	        __metadata('design:type', ColumnController)
	    ], ColumnApi.prototype, "_columnController", void 0);
	    ColumnApi = __decorate([
	        context_1.Bean('columnApi'), 
	        __metadata('design:paramtypes', [])
	    ], ColumnApi);
	    return ColumnApi;
	})();
	exports.ColumnApi = ColumnApi;
	var ColumnController = (function () {
	    function ColumnController() {
	        // header row count, based on user provided columns
	        this.primaryHeaderRowCount = 0;
	        this.secondaryHeaderRowCount = 0;
	        this.secondaryColumnsPresent = false;
	        // header row count, either above, or based on pivoting if we are pivoting
	        this.gridHeaderRowCount = 0;
	        // these are the lists used by the rowRenderer to render nodes. almost the leaf nodes of the above
	        // displayed trees, however it also takes into account if the groups are open or not.
	        this.displayedLeftColumns = [];
	        this.displayedRightColumns = [];
	        this.displayedCenterColumns = [];
	        // all three lists above combined
	        this.allDisplayedColumns = [];
	        // same as above, except trimmed down to only columns within the viewport
	        this.allDisplayedVirtualColumns = [];
	        this.rowGroupColumns = [];
	        this.valueColumns = [];
	        this.pivotColumns = [];
	        this.ready = false;
	        this.pivotMode = false;
	    }
	    ColumnController.prototype.init = function () {
	        this.pivotMode = this.gridOptionsWrapper.isPivotMode();
	        if (this.gridOptionsWrapper.getColumnDefs()) {
	            this.setColumnDefs(this.gridOptionsWrapper.getColumnDefs());
	        }
	    };
	    ColumnController.prototype.setViewportLeftAndRight = function () {
	        this.viewportLeft = this.scrollPosition;
	        this.viewportRight = this.totalWidth + this.scrollPosition;
	    };
	    // used by clipboard service, to know what columns to paste into
	    ColumnController.prototype.getDisplayedColumnsStartingAt = function (column) {
	        var currentColumn = column;
	        var result = [];
	        while (utils_1.Utils.exists(currentColumn)) {
	            result.push(currentColumn);
	            currentColumn = this.getDisplayedColAfter(currentColumn);
	        }
	        return result;
	    };
	    ColumnController.prototype.checkDisplayedCenterColumns = function () {
	        // check displayCenterColumnTree exists first, as it won't exist when grid is initialising
	        if (utils_1.Utils.exists(this.displayedCenterColumns)) {
	            var hashBefore = this.allDisplayedVirtualColumns.map(function (column) { return column.getId(); }).join('#');
	            this.updateVirtualSets();
	            var hashAfter = this.allDisplayedVirtualColumns.map(function (column) { return column.getId(); }).join('#');
	            if (hashBefore !== hashAfter) {
	                this.eventService.dispatchEvent(events_1.Events.EVENT_VIRTUAL_COLUMNS_CHANGED);
	            }
	        }
	    };
	    ColumnController.prototype.setWidthAndScrollPosition = function (totalWidth, scrollPosition) {
	        if (totalWidth !== this.totalWidth || scrollPosition !== this.scrollPosition) {
	            this.totalWidth = totalWidth;
	            this.scrollPosition = scrollPosition;
	            this.setViewportLeftAndRight();
	            if (this.ready) {
	                this.checkDisplayedCenterColumns();
	            }
	        }
	    };
	    ColumnController.prototype.isPivotMode = function () {
	        return this.pivotMode;
	    };
	    ColumnController.prototype.setPivotMode = function (pivotMode) {
	        if (pivotMode === this.pivotMode) {
	            return;
	        }
	        this.pivotMode = pivotMode;
	        this.updateDisplayedColumns();
	        var event = new columnChangeEvent_1.ColumnChangeEvent(events_1.Events.EVENT_COLUMN_PIVOT_MODE_CHANGED);
	        this.eventService.dispatchEvent(events_1.Events.EVENT_COLUMN_PIVOT_MODE_CHANGED, event);
	    };
	    ColumnController.prototype.getSecondaryPivotColumn = function (pivotKeys, valueColKey) {
	        if (!this.secondaryColumnsPresent) {
	            return null;
	        }
	        var valueColumnToFind = this.getPrimaryColumn(valueColKey);
	        var foundColumn = null;
	        this.secondaryColumns.forEach(function (column) {
	            var thisPivotKeys = column.getColDef().pivotKeys;
	            var pivotValueColumn = column.getColDef().pivotValueColumn;
	            var pivotKeyMatches = utils_1.Utils.compareArrays(thisPivotKeys, pivotKeys);
	            var pivotValueMatches = pivotValueColumn === valueColumnToFind;
	            if (pivotKeyMatches && pivotValueMatches) {
	                foundColumn = column;
	            }
	        });
	        return foundColumn;
	    };
	    ColumnController.prototype.setBeans = function (loggerFactory) {
	        this.logger = loggerFactory.create('ColumnController');
	    };
	    ColumnController.prototype.setFirstRightAndLastLeftPinned = function () {
	        var lastLeft = this.displayedLeftColumns ? this.displayedLeftColumns[this.displayedLeftColumns.length - 1] : null;
	        var firstRight = this.displayedRightColumns ? this.displayedRightColumns[0] : null;
	        this.gridColumns.forEach(function (column) {
	            column.setLastLeftPinned(column === lastLeft);
	            column.setFirstRightPinned(column === firstRight);
	        });
	    };
	    ColumnController.prototype.autoSizeColumns = function (keys) {
	        // because of column virtualisation, we can only do this function on columns that are
	        // actually rendered, as non-rendered columns (outside the viewport and not rendered
	        // due to column virtualisation) are not present. this can result in all rendered columns
	        // getting narrowed, which in turn introduces more rendered columns on the RHS which
	        // did not get autosized in the original run, leaving the visible grid with columns on
	        // the LHS sized, but RHS no. so we keep looping through teh visible columns until
	        // no more cols are available (rendered) to be resized
	        var _this = this;
	        // keep track of which cols we have resized in here
	        var columnsAutosized = [];
	        // initialise with anything except 0 so that while loop executs at least once
	        var changesThisTimeAround = -1;
	        while (changesThisTimeAround !== 0) {
	            changesThisTimeAround = 0;
	            this.actionOnGridColumns(keys, function (column) {
	                // if already autosized, skip it
	                if (columnsAutosized.indexOf(column) >= 0) {
	                    return;
	                }
	                // get how wide this col should be
	                var preferredWidth = _this.autoWidthCalculator.getPreferredWidthForColumn(column);
	                // preferredWidth = -1 if this col is not on the screen
	                if (preferredWidth > 0) {
	                    var newWidth = _this.normaliseColumnWidth(column, preferredWidth);
	                    column.setActualWidth(newWidth);
	                    columnsAutosized.push(column);
	                    changesThisTimeAround++;
	                }
	                return true;
	            }, function () {
	                return new columnChangeEvent_1.ColumnChangeEvent(events_1.Events.EVENT_COLUMN_RESIZED).withFinished(true);
	            });
	        }
	    };
	    ColumnController.prototype.autoSizeColumn = function (key) {
	        this.autoSizeColumns([key]);
	    };
	    ColumnController.prototype.autoSizeAllColumns = function () {
	        var allDisplayedColumns = this.getAllDisplayedColumns();
	        this.autoSizeColumns(allDisplayedColumns);
	    };
	    ColumnController.prototype.getColumnsFromTree = function (rootColumns) {
	        var result = [];
	        recursiveFindColumns(rootColumns);
	        return result;
	        function recursiveFindColumns(childColumns) {
	            for (var i = 0; i < childColumns.length; i++) {
	                var child = childColumns[i];
	                if (child instanceof column_1.Column) {
	                    result.push(child);
	                }
	                else if (child instanceof originalColumnGroup_1.OriginalColumnGroup) {
	                    recursiveFindColumns(child.getChildren());
	                }
	            }
	        }
	    };
	    ColumnController.prototype.getAllDisplayedColumnGroups = function () {
	        if (this.displayedLeftColumnTree && this.displayedRightColumnTree && this.displayedCentreColumnTree) {
	            return this.displayedLeftColumnTree
	                .concat(this.displayedCentreColumnTree)
	                .concat(this.displayedRightColumnTree);
	        }
	        else {
	            return null;
	        }
	    };
	    ColumnController.prototype.getPrimaryColumnTree = function () {
	        return this.primaryBalancedTree;
	    };
	    // + gridPanel -> for resizing the body and setting top margin
	    ColumnController.prototype.getHeaderRowCount = function () {
	        return this.gridHeaderRowCount;
	    };
	    // + headerRenderer -> setting pinned body width
	    ColumnController.prototype.getLeftDisplayedColumnGroups = function () {
	        return this.displayedLeftColumnTree;
	    };
	    // + headerRenderer -> setting pinned body width
	    ColumnController.prototype.getRightDisplayedColumnGroups = function () {
	        return this.displayedRightColumnTree;
	    };
	    // + headerRenderer -> setting pinned body width
	    ColumnController.prototype.getCenterDisplayedColumnGroups = function () {
	        return this.displayedCentreColumnTree;
	    };
	    ColumnController.prototype.getDisplayedColumnGroups = function (type) {
	        switch (type) {
	            case column_1.Column.PINNED_LEFT: return this.getLeftDisplayedColumnGroups();
	            case column_1.Column.PINNED_RIGHT: return this.getRightDisplayedColumnGroups();
	            default: return this.getCenterDisplayedColumnGroups();
	        }
	    };
	    // gridPanel -> ensureColumnVisible
	    ColumnController.prototype.isColumnDisplayed = function (column) {
	        return this.getAllDisplayedColumns().indexOf(column) >= 0;
	    };
	    // + csvCreator
	    ColumnController.prototype.getAllDisplayedColumns = function () {
	        return this.allDisplayedColumns;
	    };
	    // + rowRenderer
	    ColumnController.prototype.getAllDisplayedVirtualColumns = function () {
	        return this.allDisplayedVirtualColumns;
	    };
	    // used by:
	    // + angularGrid -> setting pinned body width
	    // todo: this needs to be cached
	    ColumnController.prototype.getPinnedLeftContainerWidth = function () {
	        return this.getWidthOfColsInList(this.displayedLeftColumns);
	    };
	    // todo: this needs to be cached
	    ColumnController.prototype.getPinnedRightContainerWidth = function () {
	        return this.getWidthOfColsInList(this.displayedRightColumns);
	    };
	    ColumnController.prototype.updatePrimaryColumnList = function (keys, masterList, actionIsAdd, columnCallback, eventType) {
	        var _this = this;
	        if (utils_1.Utils.missingOrEmpty(keys)) {
	            return;
	        }
	        var atLeastOne = false;
	        keys.forEach(function (key) {
	            var columnToAdd = _this.getPrimaryColumn(key);
	            if (!columnToAdd) {
	                return;
	            }
	            if (actionIsAdd) {
	                if (masterList.indexOf(columnToAdd) >= 0) {
	                    return;
	                }
	                masterList.push(columnToAdd);
	            }
	            else {
	                if (masterList.indexOf(columnToAdd) < 0) {
	                    return;
	                }
	                utils_1.Utils.removeFromArray(masterList, columnToAdd);
	            }
	            columnCallback(columnToAdd);
	            atLeastOne = true;
	        });
	        if (!atLeastOne) {
	            return;
	        }
	        this.updateDisplayedColumns();
	        var event = new columnChangeEvent_1.ColumnChangeEvent(eventType).withColumns(masterList);
	        this.eventService.dispatchEvent(event.getType(), event);
	    };
	    ColumnController.prototype.setRowGroupColumns = function (colKeys) {
	        this.setPrimaryColumnList(colKeys, this.rowGroupColumns, events_1.Events.EVENT_COLUMN_ROW_GROUP_CHANGED, this.setRowGroupActive.bind(this));
	    };
	    ColumnController.prototype.setRowGroupActive = function (active, column) {
	        if (active === column.isRowGroupActive()) {
	            return;
	        }
	        column.setRowGroupActive(active);
	        if (!active) {
	            column.setVisible(true);
	        }
	    };
	    ColumnController.prototype.addRowGroupColumn = function (key) {
	        this.addRowGroupColumns([key]);
	    };
	    ColumnController.prototype.addRowGroupColumns = function (keys) {
	        this.updatePrimaryColumnList(keys, this.rowGroupColumns, true, this.setRowGroupActive.bind(this, true), events_1.Events.EVENT_COLUMN_ROW_GROUP_CHANGED);
	    };
	    ColumnController.prototype.removeRowGroupColumns = function (keys) {
	        this.updatePrimaryColumnList(keys, this.rowGroupColumns, false, this.setRowGroupActive.bind(this, false), events_1.Events.EVENT_COLUMN_ROW_GROUP_CHANGED);
	    };
	    ColumnController.prototype.removeRowGroupColumn = function (key) {
	        this.removeRowGroupColumns([key]);
	    };
	    ColumnController.prototype.addPivotColumns = function (keys) {
	        this.updatePrimaryColumnList(keys, this.pivotColumns, true, function (column) { return column.setPivotActive(true); }, events_1.Events.EVENT_COLUMN_PIVOT_CHANGED);
	    };
	    ColumnController.prototype.setPivotColumns = function (colKeys) {
	        this.setPrimaryColumnList(colKeys, this.pivotColumns, events_1.Events.EVENT_COLUMN_PIVOT_CHANGED, function (added, column) {
	            column.setPivotActive(added);
	        });
	    };
	    ColumnController.prototype.addPivotColumn = function (key) {
	        this.addPivotColumns([key]);
	    };
	    ColumnController.prototype.removePivotColumns = function (keys) {
	        this.updatePrimaryColumnList(keys, this.pivotColumns, false, function (column) { return column.setPivotActive(false); }, events_1.Events.EVENT_COLUMN_PIVOT_CHANGED);
	    };
	    ColumnController.prototype.removePivotColumn = function (key) {
	        this.removePivotColumns([key]);
	    };
	    ColumnController.prototype.setPrimaryColumnList = function (colKeys, masterList, eventName, columnCallback) {
	        var _this = this;
	        masterList.length = 0;
	        if (utils_1.Utils.exists(colKeys)) {
	            colKeys.forEach(function (key) {
	                var column = _this.getPrimaryColumn(key);
	                masterList.push(column);
	            });
	        }
	        this.primaryColumns.forEach(function (column) {
	            var added = masterList.indexOf(column) >= 0;
	            columnCallback(added, column);
	        });
	        this.updateDisplayedColumns();
	        var event = new columnChangeEvent_1.ColumnChangeEvent(eventName)
	            .withColumns(masterList);
	        this.eventService.dispatchEvent(event.getType(), event);
	    };
	    ColumnController.prototype.setValueColumns = function (colKeys) {
	        this.setPrimaryColumnList(colKeys, this.valueColumns, events_1.Events.EVENT_COLUMN_VALUE_CHANGED, this.setValueActive.bind(this));
	    };
	    ColumnController.prototype.setValueActive = function (active, column) {
	        if (active === column.isValueActive()) {
	            return;
	        }
	        column.setValueActive(active);
	        if (active && !column.getAggFunc()) {
	            var defaultAggFunc = this.aggFuncService.getDefaultAggFunc();
	            column.setAggFunc(defaultAggFunc);
	        }
	    };
	    ColumnController.prototype.addValueColumns = function (keys) {
	        this.updatePrimaryColumnList(keys, this.valueColumns, true, this.setValueActive.bind(this, true), events_1.Events.EVENT_COLUMN_VALUE_CHANGED);
	    };
	    ColumnController.prototype.addValueColumn = function (colKey) {
	        this.addValueColumns([colKey]);
	    };
	    ColumnController.prototype.removeValueColumn = function (colKey) {
	        this.removeValueColumns([colKey]);
	    };
	    ColumnController.prototype.removeValueColumns = function (keys) {
	        this.updatePrimaryColumnList(keys, this.valueColumns, false, this.setValueActive.bind(this, false), events_1.Events.EVENT_COLUMN_VALUE_CHANGED);
	    };
	    // returns the width we can set to this col, taking into consideration min and max widths
	    ColumnController.prototype.normaliseColumnWidth = function (column, newWidth) {
	        if (newWidth < column.getMinWidth()) {
	            newWidth = column.getMinWidth();
	        }
	        if (column.isGreaterThanMax(newWidth)) {
	            newWidth = column.getMaxWidth();
	        }
	        return newWidth;
	    };
	    ColumnController.prototype.getPrimaryOrGridColumn = function (key) {
	        var column = this.getPrimaryColumn(key);
	        if (column) {
	            return column;
	        }
	        else {
	            return this.getGridColumn(key);
	        }
	    };
	    ColumnController.prototype.setColumnWidth = function (key, newWidth, finished) {
	        var column = this.getPrimaryOrGridColumn(key);
	        if (!column) {
	            return;
	        }
	        newWidth = this.normaliseColumnWidth(column, newWidth);
	        var widthChanged = column.getActualWidth() !== newWidth;
	        if (widthChanged) {
	            column.setActualWidth(newWidth);
	            this.setLeftValues();
	        }
	        // check for change first, to avoid unnecessary firing of events
	        // however we always fire 'finished' events. this is important
	        // when groups are resized, as if the group is changing slowly,
	        // eg 1 pixel at a time, then each change will fire change events
	        // in all the columns in the group, but only one with get the pixel.
	        if (finished || widthChanged) {
	            var event = new columnChangeEvent_1.ColumnChangeEvent(events_1.Events.EVENT_COLUMN_RESIZED).withColumn(column).withFinished(finished);
	            this.eventService.dispatchEvent(events_1.Events.EVENT_COLUMN_RESIZED, event);
	        }
	        this.checkDisplayedCenterColumns();
	    };
	    ColumnController.prototype.setColumnAggFunc = function (column, aggFunc) {
	        column.setAggFunc(aggFunc);
	        var event = new columnChangeEvent_1.ColumnChangeEvent(events_1.Events.EVENT_COLUMN_VALUE_CHANGED).withColumn(column);
	        this.eventService.dispatchEvent(events_1.Events.EVENT_COLUMN_VALUE_CHANGED, event);
	    };
	    ColumnController.prototype.moveRowGroupColumn = function (fromIndex, toIndex) {
	        var column = this.rowGroupColumns[fromIndex];
	        this.rowGroupColumns.splice(fromIndex, 1);
	        this.rowGroupColumns.splice(toIndex, 0, column);
	        var event = new columnChangeEvent_1.ColumnChangeEvent(events_1.Events.EVENT_COLUMN_ROW_GROUP_CHANGED);
	        this.eventService.dispatchEvent(events_1.Events.EVENT_COLUMN_ROW_GROUP_CHANGED, event);
	    };
	    ColumnController.prototype.moveColumns = function (columnsToMoveKeys, toIndex) {
	        if (toIndex > this.gridColumns.length - columnsToMoveKeys.length) {
	            console.warn('ag-Grid: tried to insert columns in invalid location, toIndex = ' + toIndex);
	            console.warn('ag-Grid: remember that you should not count the moving columns when calculating the new index');
	            return;
	        }
	        // we want to pull all the columns out first and put them into an ordered list
	        var columnsToMove = this.getGridColumns(columnsToMoveKeys);
	        var failedRules = !this.doesMovePassRules(columnsToMove, toIndex);
	        if (failedRules) {
	            return;
	        }
	        this.gridPanel.turnOnAnimationForABit();
	        utils_1.Utils.moveInArray(this.gridColumns, columnsToMove, toIndex);
	        this.updateDisplayedColumns();
	        var event = new columnChangeEvent_1.ColumnChangeEvent(events_1.Events.EVENT_COLUMN_MOVED)
	            .withToIndex(toIndex)
	            .withColumns(columnsToMove);
	        if (columnsToMove.length === 1) {
	            event.withColumn(columnsToMove[0]);
	        }
	        this.eventService.dispatchEvent(events_1.Events.EVENT_COLUMN_MOVED, event);
	    };
	    ColumnController.prototype.doesMovePassRules = function (columnsToMove, toIndex) {
	        var allColumnsCopy = this.gridColumns.slice();
	        utils_1.Utils.moveInArray(allColumnsCopy, columnsToMove, toIndex);
	        // look for broken groups, ie stray columns from groups that should be married
	        for (var index = 0; index < (allColumnsCopy.length - 1); index++) {
	            var thisColumn = allColumnsCopy[index];
	            var nextColumn = allColumnsCopy[index + 1];
	            // skip hidden columns
	            if (!nextColumn.isVisible()) {
	                continue;
	            }
	            var thisPath = this.columnUtils.getOriginalPathForColumn(thisColumn, this.gridBalancedTree);
	            var nextPath = this.columnUtils.getOriginalPathForColumn(nextColumn, this.gridBalancedTree);
	            if (!nextPath || !thisPath) {
	                console.log('next path is missing');
	            }
	            // start at the top of the path and work down
	            for (var dept = 0; dept < thisPath.length; dept++) {
	                var thisOriginalGroup = thisPath[dept];
	                var nextOriginalGroup = nextPath[dept];
	                var lastColInGroup = thisOriginalGroup !== nextOriginalGroup;
	                // a runaway is a column from this group that left the group, and the group has it's children marked as married
	                var colGroupDef = thisOriginalGroup.getColGroupDef();
	                var marryChildren = colGroupDef && colGroupDef.marryChildren;
	                var needToCheckForRunaways = lastColInGroup && marryChildren;
	                if (needToCheckForRunaways) {
	                    for (var tailIndex = index + 1; tailIndex < allColumnsCopy.length; tailIndex++) {
	                        var tailColumn = allColumnsCopy[tailIndex];
	                        var tailPath = this.columnUtils.getOriginalPathForColumn(tailColumn, this.gridBalancedTree);
	                        var tailOriginalGroup = tailPath[dept];
	                        if (tailOriginalGroup === thisOriginalGroup) {
	                            return false;
	                        }
	                    }
	                }
	            }
	        }
	        return true;
	    };
	    ColumnController.prototype.moveColumn = function (key, toIndex) {
	        this.moveColumns([key], toIndex);
	    };
	    ColumnController.prototype.moveColumnByIndex = function (fromIndex, toIndex) {
	        var column = this.gridColumns[fromIndex];
	        this.moveColumn(column, toIndex);
	    };
	    // used by:
	    // + angularGrid -> for setting body width
	    // + rowController -> setting main row widths (when inserting and resizing)
	    // need to cache this
	    ColumnController.prototype.getBodyContainerWidth = function () {
	        var result = this.getWidthOfColsInList(this.displayedCenterColumns);
	        return result;
	    };
	    // + rowController
	    ColumnController.prototype.getValueColumns = function () {
	        return this.valueColumns ? this.valueColumns : [];
	    };
	    // + rowController
	    ColumnController.prototype.getPivotColumns = function () {
	        return this.pivotColumns ? this.pivotColumns : [];
	    };
	    // + inMemoryRowModel
	    ColumnController.prototype.isPivotActive = function () {
	        return this.pivotColumns && this.pivotColumns.length > 0 && this.pivotMode;
	    };
	    // + toolPanel
	    ColumnController.prototype.getRowGroupColumns = function () {
	        return this.rowGroupColumns ? this.rowGroupColumns : [];
	    };
	    // + rowController -> while inserting rows
	    ColumnController.prototype.getDisplayedCenterColumns = function () {
	        return this.displayedCenterColumns.slice(0);
	    };
	    // + rowController -> while inserting rows
	    ColumnController.prototype.getDisplayedLeftColumns = function () {
	        return this.displayedLeftColumns.slice(0);
	    };
	    ColumnController.prototype.getDisplayedRightColumns = function () {
	        return this.displayedRightColumns.slice(0);
	    };
	    ColumnController.prototype.getDisplayedColumns = function (type) {
	        switch (type) {
	            case column_1.Column.PINNED_LEFT: return this.getDisplayedLeftColumns();
	            case column_1.Column.PINNED_RIGHT: return this.getDisplayedRightColumns();
	            default: return this.getDisplayedCenterColumns();
	        }
	    };
	    // used by:
	    // + inMemoryRowController -> sorting, building quick filter text
	    // + headerRenderer -> sorting (clearing icon)
	    ColumnController.prototype.getAllPrimaryColumns = function () {
	        return this.primaryColumns;
	    };
	    // + moveColumnController
	    ColumnController.prototype.getAllGridColumns = function () {
	        return this.gridColumns;
	    };
	    ColumnController.prototype.isEmpty = function () {
	        return utils_1.Utils.missingOrEmpty(this.gridColumns);
	    };
	    ColumnController.prototype.isRowGroupEmpty = function () {
	        return utils_1.Utils.missingOrEmpty(this.rowGroupColumns);
	    };
	    ColumnController.prototype.setColumnVisible = function (key, visible) {
	        this.setColumnsVisible([key], visible);
	    };
	    ColumnController.prototype.setColumnsVisible = function (keys, visible) {
	        this.gridPanel.turnOnAnimationForABit();
	        this.actionOnGridColumns(keys, function (column) {
	            column.setVisible(visible);
	            return true;
	        }, function () {
	            return new columnChangeEvent_1.ColumnChangeEvent(events_1.Events.EVENT_COLUMN_VISIBLE).withVisible(visible);
	        });
	    };
	    ColumnController.prototype.setColumnPinned = function (key, pinned) {
	        this.setColumnsPinned([key], pinned);
	    };
	    ColumnController.prototype.setColumnsPinned = function (keys, pinned) {
	        this.gridPanel.turnOnAnimationForABit();
	        var actualPinned;
	        if (pinned === true || pinned === column_1.Column.PINNED_LEFT) {
	            actualPinned = column_1.Column.PINNED_LEFT;
	        }
	        else if (pinned === column_1.Column.PINNED_RIGHT) {
	            actualPinned = column_1.Column.PINNED_RIGHT;
	        }
	        else {
	            actualPinned = null;
	        }
	        this.actionOnGridColumns(keys, function (column) {
	            column.setPinned(actualPinned);
	            return true;
	        }, function () {
	            return new columnChangeEvent_1.ColumnChangeEvent(events_1.Events.EVENT_COLUMN_PINNED).withPinned(actualPinned);
	        });
	    };
	    // does an action on a set of columns. provides common functionality for looking up the
	    // columns based on key, getting a list of effected columns, and then updated the event
	    // with either one column (if it was just one col) or a list of columns
	    // used by: autoResize, setVisible, setPinned
	    ColumnController.prototype.actionOnGridColumns = function (// the column keys this action will be on
	        keys, 
	        // the action to do - if this returns false, the column was skipped
	        // and won't be included in the event
	        action, 
	        // should return back a column event of the right type
	        createEvent) {
	        var _this = this;
	        if (utils_1.Utils.missingOrEmpty(keys)) {
	            return;
	        }
	        var updatedColumns = [];
	        keys.forEach(function (key) {
	            var column = _this.getGridColumn(key);
	            if (!column) {
	                return;
	            }
	            // need to check for false with type (ie !== instead of !=)
	            // as not returning anything (undefined) would also be false
	            var resultOfAction = action(column);
	            if (resultOfAction !== false) {
	                updatedColumns.push(column);
	            }
	        });
	        if (updatedColumns.length === 0) {
	            return;
	        }
	        this.updateDisplayedColumns();
	        var event = createEvent();
	        event.withColumns(updatedColumns);
	        if (updatedColumns.length === 1) {
	            event.withColumn(updatedColumns[0]);
	        }
	        this.eventService.dispatchEvent(event.getType(), event);
	    };
	    ColumnController.prototype.getDisplayedColBefore = function (col) {
	        var allDisplayedColumns = this.getAllDisplayedColumns();
	        var oldIndex = allDisplayedColumns.indexOf(col);
	        if (oldIndex > 0) {
	            return allDisplayedColumns[oldIndex - 1];
	        }
	        else {
	            return null;
	        }
	    };
	    // used by:
	    // + rowRenderer -> for navigation
	    ColumnController.prototype.getDisplayedColAfter = function (col) {
	        var allDisplayedColumns = this.getAllDisplayedColumns();
	        var oldIndex = allDisplayedColumns.indexOf(col);
	        if (oldIndex < (allDisplayedColumns.length - 1)) {
	            return allDisplayedColumns[oldIndex + 1];
	        }
	        else {
	            return null;
	        }
	    };
	    ColumnController.prototype.isPinningLeft = function () {
	        return this.displayedLeftColumns.length > 0;
	    };
	    ColumnController.prototype.isPinningRight = function () {
	        return this.displayedRightColumns.length > 0;
	    };
	    ColumnController.prototype.getPrimaryAndSecondaryAndAutoColumns = function () {
	        var result = this.primaryColumns ? this.primaryColumns.slice(0) : [];
	        if (this.groupAutoColumnActive) {
	            result.push(this.groupAutoColumn);
	        }
	        if (this.secondaryColumnsPresent) {
	            this.secondaryColumns.forEach(function (column) { return result.push(column); });
	        }
	        return result;
	    };
	    ColumnController.prototype.createStateItemFromColumn = function (column) {
	        var rowGroupIndex = column.isRowGroupActive() ? this.rowGroupColumns.indexOf(column) : null;
	        var pivotIndex = column.isPivotActive() ? this.pivotColumns.indexOf(column) : null;
	        var aggFunc = column.isValueActive() ? column.getAggFunc() : null;
	        var resultItem = {
	            colId: column.getColId(),
	            hide: !column.isVisible(),
	            aggFunc: aggFunc,
	            width: column.getActualWidth(),
	            pivotIndex: pivotIndex,
	            pinned: column.getPinned(),
	            rowGroupIndex: rowGroupIndex
	        };
	        return resultItem;
	    };
	    ColumnController.prototype.getColumnState = function () {
	        if (utils_1.Utils.missing(this.primaryColumns)) {
	            return [];
	        }
	        var columnStateList = this.primaryColumns.map(this.createStateItemFromColumn.bind(this));
	        if (!this.pivotMode) {
	            this.orderColumnStateList(columnStateList);
	        }
	        return columnStateList;
	    };
	    ColumnController.prototype.orderColumnStateList = function (columnStateList) {
	        var gridColumnIds = this.gridColumns.map(function (column) { return column.getColId(); });
	        columnStateList.sort(function (itemA, itemB) {
	            var posA = gridColumnIds.indexOf(itemA.colId);
	            var posB = gridColumnIds.indexOf(itemB.colId);
	            return posA - posB;
	        });
	    };
	    ColumnController.prototype.resetColumnState = function () {
	        // we can't use 'allColumns' as the order might of messed up, so get the primary ordered list
	        var primaryColumns = this.getColumnsFromTree(this.primaryBalancedTree);
	        var state = [];
	        if (primaryColumns) {
	            primaryColumns.forEach(function (column) {
	                state.push({
	                    colId: column.getColId(),
	                    aggFunc: column.getColDef().aggFunc,
	                    hide: column.getColDef().hide,
	                    pinned: column.getColDef().pinned,
	                    rowGroupIndex: column.getColDef().rowGroupIndex,
	                    pivotIndex: column.getColDef().pivotIndex,
	                    width: column.getColDef().width
	                });
	            });
	        }
	        this.setColumnState(state);
	    };
	    ColumnController.prototype.setColumnState = function (columnState) {
	        var _this = this;
	        if (utils_1.Utils.missingOrEmpty(this.primaryColumns)) {
	            return false;
	        }
	        // at the end below, this list will have all columns we got no state for
	        var columnsWithNoState = this.primaryColumns.slice();
	        this.rowGroupColumns = [];
	        this.valueColumns = [];
	        this.pivotColumns = [];
	        var success = true;
	        var rowGroupIndexes = {};
	        var pivotIndexes = {};
	        if (columnState) {
	            columnState.forEach(function (stateItem) {
	                var column = _this.getPrimaryColumn(stateItem.colId);
	                if (!column) {
	                    console.warn('ag-grid: column ' + stateItem.colId + ' not found');
	                    success = false;
	                }
	                else {
	                    _this.syncColumnWithStateItem(column, stateItem, rowGroupIndexes, pivotIndexes);
	                    utils_1.Utils.removeFromArray(columnsWithNoState, column);
	                }
	            });
	        }
	        // anything left over, we got no data for, so add in the column as non-value, non-rowGroup and hidden
	        columnsWithNoState.forEach(this.syncColumnWithNoState.bind(this));
	        // sort the lists according to the indexes that were provided
	        this.rowGroupColumns.sort(this.sortColumnListUsingIndexes.bind(this, rowGroupIndexes));
	        this.pivotColumns.sort(this.sortColumnListUsingIndexes.bind(this, pivotIndexes));
	        this.copyDownGridColumns();
	        var orderOfColIds = columnState.map(function (stateItem) { return stateItem.colId; });
	        this.gridColumns.sort(function (colA, colB) {
	            var indexA = orderOfColIds.indexOf(colA.getId());
	            var indexB = orderOfColIds.indexOf(colB.getId());
	            return indexA - indexB;
	        });
	        this.updateDisplayedColumns();
	        var event = new columnChangeEvent_1.ColumnChangeEvent(events_1.Events.EVENT_COLUMN_EVERYTHING_CHANGED);
	        this.eventService.dispatchEvent(events_1.Events.EVENT_COLUMN_EVERYTHING_CHANGED, event);
	        return success;
	    };
	    ColumnController.prototype.sortColumnListUsingIndexes = function (indexes, colA, colB) {
	        var indexA = indexes[colA.getId()];
	        var indexB = indexes[colB.getId()];
	        return indexA - indexB;
	    };
	    ColumnController.prototype.syncColumnWithNoState = function (column) {
	        column.setVisible(false);
	        column.setAggFunc(null);
	        column.setPinned(null);
	        column.setRowGroupActive(false);
	        column.setPivotActive(false);
	        column.setValueActive(false);
	    };
	    ColumnController.prototype.syncColumnWithStateItem = function (column, stateItem, rowGroupIndexes, pivotIndexes) {
	        // following ensures we are left with boolean true or false, eg converts (null, undefined, 0) all to true
	        column.setVisible(!stateItem.hide);
	        // sets pinned to 'left' or 'right'
	        column.setPinned(stateItem.pinned);
	        // if width provided and valid, use it, otherwise stick with the old width
	        if (stateItem.width >= this.gridOptionsWrapper.getMinColWidth()) {
	            column.setActualWidth(stateItem.width);
	        }
	        if (typeof stateItem.aggFunc === 'string') {
	            column.setAggFunc(stateItem.aggFunc);
	            column.setValueActive(true);
	            this.valueColumns.push(column);
	        }
	        else {
	            column.setAggFunc(null);
	            column.setValueActive(false);
	        }
	        if (typeof stateItem.rowGroupIndex === 'number') {
	            this.rowGroupColumns.push(column);
	            column.setRowGroupActive(true);
	            rowGroupIndexes[column.getId()] = stateItem.rowGroupIndex;
	        }
	        else {
	            column.setRowGroupActive(false);
	        }
	        if (typeof stateItem.pivotIndex === 'number') {
	            this.pivotColumns.push(column);
	            column.setPivotActive(true);
	            pivotIndexes[column.getId()] = stateItem.pivotIndex;
	        }
	        else {
	            column.setPivotActive(false);
	        }
	    };
	    ColumnController.prototype.getGridColumns = function (keys) {
	        return this.getColumns(keys, this.getGridColumn.bind(this));
	    };
	    ColumnController.prototype.getColumns = function (keys, columnLookupCallback) {
	        var foundColumns = [];
	        if (keys) {
	            keys.forEach(function (key) {
	                var column = columnLookupCallback(key);
	                if (column) {
	                    foundColumns.push(column);
	                }
	            });
	        }
	        return foundColumns;
	    };
	    // used by growGroupPanel
	    ColumnController.prototype.getColumnWithValidation = function (key) {
	        var column = this.getPrimaryColumn(key);
	        if (!column) {
	            console.warn('ag-Grid: could not find column ' + column);
	        }
	        return column;
	    };
	    ColumnController.prototype.getPrimaryColumn = function (key) {
	        return this.getColumn(key, this.primaryColumns);
	    };
	    ColumnController.prototype.getGridColumn = function (key) {
	        return this.getColumn(key, this.gridColumns);
	    };
	    ColumnController.prototype.getColumn = function (key, columnList) {
	        if (!key) {
	            return null;
	        }
	        for (var i = 0; i < columnList.length; i++) {
	            if (colMatches(columnList[i])) {
	                return columnList[i];
	            }
	        }
	        if (this.groupAutoColumnActive && colMatches(this.groupAutoColumn)) {
	            return this.groupAutoColumn;
	        }
	        function colMatches(column) {
	            var columnMatches = column === key;
	            var colDefMatches = column.getColDef() === key;
	            var idMatches = column.getColId() == key;
	            return columnMatches || colDefMatches || idMatches;
	        }
	        return null;
	    };
	    ColumnController.prototype.getDisplayNameForColumn = function (column, location, includeAggFunc) {
	        if (includeAggFunc === void 0) { includeAggFunc = false; }
	        var headerName = this.getHeaderName(column.getColDef(), column, null, location);
	        if (includeAggFunc) {
	            return this.wrapHeaderNameWithAggFunc(column, headerName);
	        }
	        else {
	            return headerName;
	        }
	    };
	    ColumnController.prototype.getDisplayNameForColumnGroup = function (columnGroup, location) {
	        var colGroupDef = columnGroup.getOriginalColumnGroup().getColGroupDef();
	        if (colGroupDef) {
	            return this.getHeaderName(colGroupDef, null, columnGroup, location);
	        }
	        else {
	            return null;
	        }
	    };
	    // location is where the column is going to appear, ie who is calling us
	    ColumnController.prototype.getHeaderName = function (colDef, column, columnGroup, location) {
	        var headerValueGetter = colDef.headerValueGetter;
	        if (headerValueGetter) {
	            var params = {
	                colDef: colDef,
	                column: column,
	                columnGroup: columnGroup,
	                location: location,
	                api: this.gridOptionsWrapper.getApi(),
	                context: this.gridOptionsWrapper.getContext()
	            };
	            if (typeof headerValueGetter === 'function') {
	                // valueGetter is a function, so just call it
	                return headerValueGetter(params);
	            }
	            else if (typeof headerValueGetter === 'string') {
	                // valueGetter is an expression, so execute the expression
	                return this.expressionService.evaluate(headerValueGetter, params);
	            }
	            else {
	                console.warn('ag-grid: headerValueGetter must be a function or a string');
	                return '';
	            }
	        }
	        else {
	            return colDef.headerName;
	        }
	    };
	    /*
	        private getHeaderGroupName(columnGroup: ColumnGroup): string {
	            var colGroupDef = columnGroup.getOriginalColumnGroup().getColGroupDef();
	            var headerValueGetter = colGroupDef.headerValueGetter;

	            if (headerValueGetter) {
	                var params = {
	                    columnGroup: columnGroup,
	                    colDef: colGroupDef,
	                    api: this.gridOptionsWrapper.getApi(),
	                    context: this.gridOptionsWrapper.getContext()
	                };

	                if (typeof headerValueGetter === 'function') {
	                    // valueGetter is a function, so just call it
	                    return headerValueGetter(params);
	                } else if (typeof headerValueGetter === 'string') {
	                    // valueGetter is an expression, so execute the expression
	                    return this.expressionService.evaluate(headerValueGetter, params);
	                } else {
	                    console.warn('ag-grid: headerValueGetter must be a function or a string');
	                    return '';
	                }
	            } else {
	                return colGroupDef.headerName;
	            }
	        }
	    */
	    ColumnController.prototype.wrapHeaderNameWithAggFunc = function (column, headerName) {
	        if (this.gridOptionsWrapper.isSuppressAggFuncInHeader()) {
	            return headerName;
	        }
	        // only columns with aggregation active can have aggregations
	        var pivotValueColumn = column.getColDef().pivotValueColumn;
	        var pivotActiveOnThisColumn = utils_1.Utils.exists(pivotValueColumn);
	        var aggFunc = null;
	        var aggFuncFound;
	        // otherwise we have a measure that is active, and we are doing aggregation on it
	        if (pivotActiveOnThisColumn) {
	            aggFunc = pivotValueColumn.getAggFunc();
	            aggFuncFound = true;
	        }
	        else {
	            var measureActive = column.isValueActive();
	            var aggregationPresent = this.pivotMode || !this.isRowGroupEmpty();
	            if (measureActive && aggregationPresent) {
	                aggFunc = column.getAggFunc();
	                aggFuncFound = true;
	            }
	            else {
	                aggFuncFound = false;
	            }
	        }
	        if (aggFuncFound) {
	            var aggFuncString = (typeof aggFunc === 'string') ? aggFunc : 'func';
	            return aggFuncString + "(" + headerName + ")";
	        }
	        else {
	            return headerName;
	        }
	    };
	    // returns the group with matching colId and instanceId. If instanceId is missing,
	    // matches only on the colId.
	    ColumnController.prototype.getColumnGroup = function (colId, instanceId) {
	        if (!colId) {
	            return null;
	        }
	        if (colId instanceof columnGroup_1.ColumnGroup) {
	            return colId;
	        }
	        var allColumnGroups = this.getAllDisplayedColumnGroups();
	        var checkInstanceId = typeof instanceId === 'number';
	        var result = null;
	        this.columnUtils.depthFirstAllColumnTreeSearch(allColumnGroups, function (child) {
	            if (child instanceof columnGroup_1.ColumnGroup) {
	                var columnGroup = child;
	                var matched;
	                if (checkInstanceId) {
	                    matched = colId === columnGroup.getGroupId() && instanceId === columnGroup.getInstanceId();
	                }
	                else {
	                    matched = colId === columnGroup.getGroupId();
	                }
	                if (matched) {
	                    result = columnGroup;
	                }
	            }
	        });
	        return result;
	    };
	    ColumnController.prototype.setColumnDefs = function (columnDefs) {
	        var balancedTreeResult = this.balancedColumnTreeBuilder.createBalancedColumnGroups(columnDefs, true);
	        this.primaryBalancedTree = balancedTreeResult.balancedTree;
	        this.primaryHeaderRowCount = balancedTreeResult.treeDept + 1;
	        this.primaryColumns = this.getColumnsFromTree(this.primaryBalancedTree);
	        this.extractRowGroupColumns();
	        this.extractPivotColumns();
	        this.createValueColumns();
	        this.copyDownGridColumns();
	        this.updateDisplayedColumns();
	        this.ready = true;
	        var event = new columnChangeEvent_1.ColumnChangeEvent(events_1.Events.EVENT_COLUMN_EVERYTHING_CHANGED);
	        this.eventService.dispatchEvent(events_1.Events.EVENT_COLUMN_EVERYTHING_CHANGED, event);
	        this.eventService.dispatchEvent(events_1.Events.EVENT_NEW_COLUMNS_LOADED);
	    };
	    ColumnController.prototype.isReady = function () {
	        return this.ready;
	    };
	    ColumnController.prototype.extractRowGroupColumns = function () {
	        var _this = this;
	        this.rowGroupColumns.forEach(function (column) { return column.setRowGroupActive(false); });
	        this.rowGroupColumns = [];
	        // pull out the columns
	        this.primaryColumns.forEach(function (column) {
	            if (typeof column.getColDef().rowGroupIndex === 'number') {
	                _this.rowGroupColumns.push(column);
	                column.setRowGroupActive(true);
	            }
	        });
	        // then sort them
	        this.rowGroupColumns.sort(function (colA, colB) {
	            return colA.getColDef().rowGroupIndex - colB.getColDef().rowGroupIndex;
	        });
	    };
	    ColumnController.prototype.extractPivotColumns = function () {
	        var _this = this;
	        this.pivotColumns.forEach(function (column) { return column.setPivotActive(false); });
	        this.pivotColumns = [];
	        // pull out the columns
	        this.primaryColumns.forEach(function (column) {
	            if (typeof column.getColDef().pivotIndex === 'number') {
	                _this.pivotColumns.push(column);
	                column.setPivotActive(true);
	            }
	        });
	        // then sort them
	        this.pivotColumns.sort(function (colA, colB) {
	            return colA.getColDef().pivotIndex - colB.getColDef().pivotIndex;
	        });
	    };
	    // called by headerRenderer - when a header is opened or closed
	    ColumnController.prototype.setColumnGroupOpened = function (passedGroup, newValue, instanceId) {
	        var groupToUse = this.getColumnGroup(passedGroup, instanceId);
	        if (!groupToUse) {
	            return;
	        }
	        this.logger.log('columnGroupOpened(' + groupToUse.getGroupId() + ',' + newValue + ')');
	        groupToUse.setExpanded(newValue);
	        this.gridPanel.turnOnAnimationForABit();
	        this.updateGroupsAndDisplayedColumns();
	        var event = new columnChangeEvent_1.ColumnChangeEvent(events_1.Events.EVENT_COLUMN_GROUP_OPENED).withColumnGroup(groupToUse);
	        this.eventService.dispatchEvent(events_1.Events.EVENT_COLUMN_GROUP_OPENED, event);
	    };
	    // used by updateModel
	    ColumnController.prototype.getColumnGroupState = function () {
	        var groupState = {};
	        this.columnUtils.depthFirstDisplayedColumnTreeSearch(this.getAllDisplayedColumnGroups(), function (child) {
	            if (child instanceof columnGroup_1.ColumnGroup) {
	                var columnGroup = child;
	                var key = columnGroup.getGroupId();
	                // if more than one instance of the group, we only record the state of the first item
	                if (!groupState.hasOwnProperty(key)) {
	                    groupState[key] = columnGroup.isExpanded();
	                }
	            }
	        });
	        return groupState;
	    };
	    // used by updateModel
	    ColumnController.prototype.setColumnGroupState = function (groupState) {
	        this.columnUtils.depthFirstDisplayedColumnTreeSearch(this.getAllDisplayedColumnGroups(), function (child) {
	            if (child instanceof columnGroup_1.ColumnGroup) {
	                var columnGroup = child;
	                var key = columnGroup.getGroupId();
	                var shouldExpandGroup = groupState[key] === true && columnGroup.isExpandable();
	                if (shouldExpandGroup) {
	                    columnGroup.setExpanded(true);
	                }
	            }
	        });
	    };
	    ColumnController.prototype.calculateColumnsForDisplay = function () {
	        var columnsForDisplay;
	        if (this.pivotMode && !this.secondaryColumnsPresent) {
	            // pivot mode is on, but we are not pivoting, so we only
	            // show columns we are aggregating on
	            columnsForDisplay = this.createColumnsToDisplayFromValueColumns();
	        }
	        else {
	            // otherwise continue as normal. this can be working on the primary
	            // or secondary columns, whatever the gridColumns are set to
	            columnsForDisplay = utils_1.Utils.filter(this.gridColumns, function (column) { return column.isVisible(); });
	        }
	        this.createGroupAutoColumn();
	        if (this.groupAutoColumnActive) {
	            columnsForDisplay.unshift(this.groupAutoColumn);
	        }
	        return columnsForDisplay;
	    };
	    ColumnController.prototype.createColumnsToDisplayFromValueColumns = function () {
	        var _this = this;
	        // make a copy of the value columns, so we have to side effects
	        var result = this.valueColumns.slice();
	        // order the columns as per the grid columns. having the order is
	        // important as without it, reordering of columns would have no impact
	        result.sort(function (colA, colB) {
	            return _this.gridColumns.indexOf(colA) - _this.gridColumns.indexOf(colB);
	        });
	        return result;
	    };
	    ColumnController.prototype.updateDisplayedColumns = function () {
	        // save opened / closed state
	        var oldGroupState = this.getColumnGroupState();
	        var columnsForDisplay = this.calculateColumnsForDisplay();
	        this.buildDisplayedTrees(columnsForDisplay);
	        // restore opened / closed state
	        this.setColumnGroupState(oldGroupState);
	        // this is also called when a group is opened or closed
	        this.updateGroupsAndDisplayedColumns();
	        this.setFirstRightAndLastLeftPinned();
	    };
	    ColumnController.prototype.isSecondaryColumnsPresent = function () {
	        return this.secondaryColumnsPresent;
	    };
	    ColumnController.prototype.setSecondaryColumns = function (colDefs) {
	        var newColsPresent = colDefs && colDefs.length > 0;
	        // if not cols passed, and we had to cols anyway, then do nothing
	        if (!newColsPresent && !this.secondaryColumnsPresent) {
	            return;
	        }
	        if (newColsPresent) {
	            this.processSecondaryColumnDefinitions(colDefs);
	            var balancedTreeResult = this.balancedColumnTreeBuilder.createBalancedColumnGroups(colDefs, false);
	            this.secondaryBalancedTree = balancedTreeResult.balancedTree;
	            this.secondaryHeaderRowCount = balancedTreeResult.treeDept + 1;
	            this.secondaryColumns = this.getColumnsFromTree(this.secondaryBalancedTree);
	            this.secondaryColumnsPresent = true;
	        }
	        else {
	            this.secondaryBalancedTree = null;
	            this.secondaryHeaderRowCount = -1;
	            this.secondaryColumns = null;
	            this.secondaryColumnsPresent = false;
	        }
	        this.copyDownGridColumns();
	        this.updateDisplayedColumns();
	    };
	    ColumnController.prototype.processSecondaryColumnDefinitions = function (colDefs) {
	        var columnCallback = this.gridOptionsWrapper.getProcessSecondaryColDefFunc();
	        var groupCallback = this.gridOptionsWrapper.getProcessSecondaryColGroupDefFunc();
	        if (!columnCallback && !groupCallback) {
	            return;
	        }
	        searchForColDefs(colDefs);
	        function searchForColDefs(colDefs2) {
	            colDefs2.forEach(function (abstractColDef) {
	                var isGroup = utils_1.Utils.exists(abstractColDef.children);
	                if (isGroup) {
	                    var colGroupDef = abstractColDef;
	                    if (groupCallback) {
	                        groupCallback(colGroupDef);
	                    }
	                    searchForColDefs(colGroupDef.children);
	                }
	                else {
	                    var colDef = abstractColDef;
	                    if (columnCallback) {
	                        columnCallback(colDef);
	                    }
	                }
	            });
	        }
	    };
	    // called from: setColumnState, setColumnDefs, setAlternativeColumnDefs
	    ColumnController.prototype.copyDownGridColumns = function () {
	        if (this.secondaryColumns) {
	            this.gridBalancedTree = this.secondaryBalancedTree.slice();
	            this.gridHeaderRowCount = this.secondaryHeaderRowCount;
	            this.gridColumns = this.secondaryColumns.slice();
	        }
	        else {
	            this.gridBalancedTree = this.primaryBalancedTree.slice();
	            this.gridHeaderRowCount = this.primaryHeaderRowCount;
	            this.gridColumns = this.primaryColumns.slice();
	        }
	        this.clearDisplayedColumns();
	        var event = new columnChangeEvent_1.ColumnChangeEvent(events_1.Events.EVENT_GRID_COLUMNS_CHANGED);
	        this.eventService.dispatchEvent(events_1.Events.EVENT_GRID_COLUMNS_CHANGED, event);
	    };
	    // gets called after we copy down grid columns, to make sure any part of the gui
	    // that tries to draw, eg the header, it will get empty lists of columns rather
	    // than stale columns. for example, the header will received gridColumnsChanged
	    // event, so will try and draw, but it will draw successfully when it acts on the
	    // virtualColumnsChanged event
	    ColumnController.prototype.clearDisplayedColumns = function () {
	        this.displayedLeftColumnTree = [];
	        this.displayedRightColumnTree = [];
	        this.displayedCentreColumnTree = [];
	        this.displayedLeftHeaderRows = {};
	        this.displayedRightHeaderRows = {};
	        this.displayedCentreHeaderRows = {};
	        this.displayedLeftColumns = [];
	        this.displayedRightColumns = [];
	        this.displayedCenterColumns = [];
	        this.allDisplayedColumns = [];
	        this.allDisplayedVirtualColumns = [];
	    };
	    ColumnController.prototype.updateGroupsAndDisplayedColumns = function () {
	        this.updateGroups();
	        this.updateDisplayedColumnsFromTrees();
	        this.updateVirtualSets();
	        // this event is picked up by the gui, headerRenderer and rowRenderer, to recalculate what columns to display
	        var event = new columnChangeEvent_1.ColumnChangeEvent(events_1.Events.EVENT_DISPLAYED_COLUMNS_CHANGED);
	        this.eventService.dispatchEvent(events_1.Events.EVENT_DISPLAYED_COLUMNS_CHANGED, event);
	    };
	    ColumnController.prototype.updateDisplayedColumnsFromTrees = function () {
	        this.addToDisplayedColumns(this.displayedLeftColumnTree, this.displayedLeftColumns);
	        this.addToDisplayedColumns(this.displayedCentreColumnTree, this.displayedCenterColumns);
	        this.addToDisplayedColumns(this.displayedRightColumnTree, this.displayedRightColumns);
	        // order we add the arrays together is important, so the result
	        // has the columns left to right, as they appear on the screen.
	        this.allDisplayedColumns = this.displayedLeftColumns
	            .concat(this.displayedCenterColumns)
	            .concat(this.displayedRightColumns);
	        this.setLeftValues();
	    };
	    // sets the left pixel position of each column
	    ColumnController.prototype.setLeftValues = function () {
	        this.setLeftValuesOfColumns();
	        this.setLeftValuesOfGroups();
	    };
	    ColumnController.prototype.setLeftValuesOfColumns = function () {
	        // go through each list of displayed columns
	        var allColumns = this.primaryColumns.slice(0);
	        [this.displayedLeftColumns, this.displayedRightColumns, this.displayedCenterColumns].forEach(function (columns) {
	            var left = 0;
	            columns.forEach(function (column) {
	                column.setLeft(left);
	                left += column.getActualWidth();
	                utils_1.Utils.removeFromArray(allColumns, column);
	            });
	        });
	        // items left in allColumns are columns not displayed, so remove the left position. this is
	        // important for the rows, as if a col is made visible, then taken out, then made visible again,
	        // we don't want the animation of the cell floating in from the old position, whatever that was.
	        allColumns.forEach(function (column) {
	            column.setLeft(null);
	        });
	    };
	    ColumnController.prototype.setLeftValuesOfGroups = function () {
	        // a groups left value is the lest left value of it's children
	        [this.displayedLeftColumnTree, this.displayedRightColumnTree, this.displayedCentreColumnTree].forEach(function (columns) {
	            columns.forEach(function (column) {
	                if (column instanceof columnGroup_1.ColumnGroup) {
	                    var columnGroup = column;
	                    columnGroup.checkLeft();
	                }
	            });
	        });
	    };
	    ColumnController.prototype.addToDisplayedColumns = function (displayedColumnTree, displayedColumns) {
	        displayedColumns.length = 0;
	        this.columnUtils.depthFirstDisplayedColumnTreeSearch(displayedColumnTree, function (child) {
	            if (child instanceof column_1.Column) {
	                displayedColumns.push(child);
	            }
	        });
	    };
	    ColumnController.prototype.updateDisplayedCenterVirtualColumns = function () {
	        var filteredCenterColumns;
	        var skipVirtualisation = this.gridOptionsWrapper.isSuppressColumnVirtualisation() || this.gridOptionsWrapper.isForPrint();
	        if (skipVirtualisation) {
	            // no virtualisation, so don't filter
	            filteredCenterColumns = this.displayedCenterColumns;
	        }
	        else {
	            // filter out what should be visible
	            filteredCenterColumns = this.filterOutColumnsWithinViewport(this.displayedCenterColumns);
	        }
	        this.allDisplayedVirtualColumns = filteredCenterColumns
	            .concat(this.displayedLeftColumns)
	            .concat(this.displayedRightColumns);
	        // return map of virtual col id's, for easy lookup when building the groups.
	        // the map will be colId=>true, ie col id's mapping to 'true'.
	        var result = {};
	        this.allDisplayedVirtualColumns.forEach(function (col) {
	            result[col.getId()] = true;
	        });
	        return result;
	    };
	    ColumnController.prototype.getVirtualHeaderGroupRow = function (type, dept) {
	        var result;
	        switch (type) {
	            case column_1.Column.PINNED_LEFT:
	                result = this.displayedLeftHeaderRows[dept];
	                break;
	            case column_1.Column.PINNED_RIGHT:
	                result = this.displayedRightHeaderRows[dept];
	                break;
	            default:
	                result = this.displayedCentreHeaderRows[dept];
	                break;
	        }
	        if (utils_1.Utils.missing(result)) {
	            result = [];
	        }
	        return result;
	    };
	    ColumnController.prototype.updateDisplayedVirtualGroups = function (virtualColIds) {
	        // go through each group, see if any of it's cols are displayed, and if yes,
	        // then this group is included
	        this.displayedLeftHeaderRows = {};
	        this.displayedRightHeaderRows = {};
	        this.displayedCentreHeaderRows = {};
	        testGroup(this.displayedLeftColumnTree, this.displayedLeftHeaderRows, 0);
	        testGroup(this.displayedRightColumnTree, this.displayedRightHeaderRows, 0);
	        testGroup(this.displayedCentreColumnTree, this.displayedCentreHeaderRows, 0);
	        function testGroup(children, result, dept) {
	            var returnValue = false;
	            for (var i = 0; i < children.length; i++) {
	                // see if this item is within viewport
	                var child = children[i];
	                var addThisItem;
	                if (child instanceof column_1.Column) {
	                    // for column, test if column is included
	                    addThisItem = virtualColIds[child.getId()] === true;
	                }
	                else {
	                    // if group, base decision on children
	                    var columnGroup = child;
	                    addThisItem = testGroup(columnGroup.getDisplayedChildren(), result, dept + 1);
	                }
	                if (addThisItem) {
	                    returnValue = true;
	                    if (!result[dept]) {
	                        result[dept] = [];
	                    }
	                    result[dept].push(child);
	                }
	            }
	            return returnValue;
	        }
	    };
	    ColumnController.prototype.updateVirtualSets = function () {
	        var virtualColIds = this.updateDisplayedCenterVirtualColumns();
	        this.updateDisplayedVirtualGroups(virtualColIds);
	    };
	    ColumnController.prototype.filterOutColumnsWithinViewport = function (columns) {
	        var _this = this;
	        var result = utils_1.Utils.filter(columns, function (column) {
	            // only out if both sides of columns are to the left or to the right of the boundary
	            var columnLeft = column.getLeft();
	            var columnRight = column.getLeft() + column.getActualWidth();
	            var columnToMuchLeft = columnLeft < _this.viewportLeft && columnRight < _this.viewportLeft;
	            var columnToMuchRight = columnLeft > _this.viewportRight && columnRight > _this.viewportRight;
	            var includeThisCol = !columnToMuchLeft && !columnToMuchRight;
	            return includeThisCol;
	        });
	        return result;
	    };
	    // called from api
	    ColumnController.prototype.sizeColumnsToFit = function (gridWidth) {
	        var _this = this;
	        // avoid divide by zero
	        var allDisplayedColumns = this.getAllDisplayedColumns();
	        if (gridWidth <= 0 || allDisplayedColumns.length === 0) {
	            return;
	        }
	        var colsToNotSpread = utils_1.Utils.filter(allDisplayedColumns, function (column) {
	            return column.getColDef().suppressSizeToFit === true;
	        });
	        var colsToSpread = utils_1.Utils.filter(allDisplayedColumns, function (column) {
	            return column.getColDef().suppressSizeToFit !== true;
	        });
	        // make a copy of the cols that are going to be resized
	        var colsToFireEventFor = colsToSpread.slice(0);
	        var finishedResizing = false;
	        while (!finishedResizing) {
	            finishedResizing = true;
	            var availablePixels = gridWidth - getTotalWidth(colsToNotSpread);
	            if (availablePixels <= 0) {
	                // no width, set everything to minimum
	                colsToSpread.forEach(function (column) {
	                    column.setMinimum();
	                });
	            }
	            else {
	                var scale = availablePixels / getTotalWidth(colsToSpread);
	                // we set the pixels for the last col based on what's left, as otherwise
	                // we could be a pixel or two short or extra because of rounding errors.
	                var pixelsForLastCol = availablePixels;
	                // backwards through loop, as we are removing items as we go
	                for (var i = colsToSpread.length - 1; i >= 0; i--) {
	                    var column = colsToSpread[i];
	                    var newWidth = Math.round(column.getActualWidth() * scale);
	                    if (newWidth < column.getMinWidth()) {
	                        column.setMinimum();
	                        moveToNotSpread(column);
	                        finishedResizing = false;
	                    }
	                    else if (column.isGreaterThanMax(newWidth)) {
	                        column.setActualWidth(column.getMaxWidth());
	                        moveToNotSpread(column);
	                        finishedResizing = false;
	                    }
	                    else {
	                        var onLastCol = i === 0;
	                        if (onLastCol) {
	                            column.setActualWidth(pixelsForLastCol);
	                        }
	                        else {
	                            column.setActualWidth(newWidth);
	                        }
	                    }
	                    pixelsForLastCol -= newWidth;
	                }
	            }
	        }
	        this.setLeftValues();
	        // widths set, refresh the gui
	        colsToFireEventFor.forEach(function (column) {
	            var event = new columnChangeEvent_1.ColumnChangeEvent(events_1.Events.EVENT_COLUMN_RESIZED).withColumn(column);
	            _this.eventService.dispatchEvent(events_1.Events.EVENT_COLUMN_RESIZED, event);
	        });
	        this.checkDisplayedCenterColumns();
	        function moveToNotSpread(column) {
	            utils_1.Utils.removeFromArray(colsToSpread, column);
	            colsToNotSpread.push(column);
	        }
	        function getTotalWidth(columns) {
	            var result = 0;
	            for (var i = 0; i < columns.length; i++) {
	                result += columns[i].getActualWidth();
	            }
	            return result;
	        }
	    };
	    ColumnController.prototype.buildDisplayedTrees = function (visibleColumns) {
	        var leftVisibleColumns = utils_1.Utils.filter(visibleColumns, function (column) {
	            return column.getPinned() === 'left';
	        });
	        var rightVisibleColumns = utils_1.Utils.filter(visibleColumns, function (column) {
	            return column.getPinned() === 'right';
	        });
	        var centerVisibleColumns = utils_1.Utils.filter(visibleColumns, function (column) {
	            return column.getPinned() !== 'left' && column.getPinned() !== 'right';
	        });
	        var groupInstanceIdCreator = new groupInstanceIdCreator_1.GroupInstanceIdCreator();
	        this.displayedLeftColumnTree = this.displayedGroupCreator.createDisplayedGroups(leftVisibleColumns, this.gridBalancedTree, groupInstanceIdCreator);
	        this.displayedRightColumnTree = this.displayedGroupCreator.createDisplayedGroups(rightVisibleColumns, this.gridBalancedTree, groupInstanceIdCreator);
	        this.displayedCentreColumnTree = this.displayedGroupCreator.createDisplayedGroups(centerVisibleColumns, this.gridBalancedTree, groupInstanceIdCreator);
	    };
	    ColumnController.prototype.updateGroups = function () {
	        var allGroups = this.getAllDisplayedColumnGroups();
	        this.columnUtils.depthFirstAllColumnTreeSearch(allGroups, function (child) {
	            if (child instanceof columnGroup_1.ColumnGroup) {
	                var group = child;
	                group.calculateDisplayedColumns();
	            }
	        });
	    };
	    ColumnController.prototype.createGroupAutoColumn = function () {
	        // see if we need to insert the default grouping column
	        var needAGroupColumn = this.rowGroupColumns.length > 0
	            && !this.gridOptionsWrapper.isGroupSuppressAutoColumn()
	            && !this.gridOptionsWrapper.isGroupUseEntireRow()
	            && !this.gridOptionsWrapper.isGroupSuppressRow();
	        this.groupAutoColumnActive = needAGroupColumn;
	        // lazy create group auto-column
	        if (needAGroupColumn && !this.groupAutoColumn) {
	            // if one provided by user, use it, otherwise create one
	            var autoColDef = this.gridOptionsWrapper.getGroupColumnDef();
	            if (!autoColDef) {
	                var localeTextFunc = this.gridOptionsWrapper.getLocaleTextFunc();
	                autoColDef = {
	                    headerName: localeTextFunc('group', 'Group'),
	                    comparator: functions_1.defaultGroupComparator,
	                    valueGetter: function (params) {
	                        if (params.node.group) {
	                            return params.node.key;
	                        }
	                        else if (params.data && params.colDef.field) {
	                            return params.data[params.colDef.field];
	                        }
	                        else {
	                            return null;
	                        }
	                    },
	                    cellRenderer: 'group'
	                };
	            }
	            // we never allow moving the group column
	            autoColDef.suppressMovable = true;
	            var colId = ColumnController.GROUP_AUTO_COLUMN_ID;
	            this.groupAutoColumn = new column_1.Column(autoColDef, colId, true);
	            this.context.wireBean(this.groupAutoColumn);
	        }
	    };
	    ColumnController.prototype.createValueColumns = function () {
	        this.valueColumns.forEach(function (column) { return column.setValueActive(false); });
	        this.valueColumns = [];
	        // override with columns that have the aggFunc specified explicitly
	        for (var i = 0; i < this.primaryColumns.length; i++) {
	            var column = this.primaryColumns[i];
	            if (column.getColDef().aggFunc) {
	                column.setAggFunc(column.getColDef().aggFunc);
	                this.valueColumns.push(column);
	                column.setValueActive(true);
	            }
	        }
	    };
	    ColumnController.prototype.getWidthOfColsInList = function (columnList) {
	        var result = 0;
	        for (var i = 0; i < columnList.length; i++) {
	            result += columnList[i].getActualWidth();
	        }
	        return result;
	    };
	    ColumnController.GROUP_AUTO_COLUMN_ID = 'ag-Grid-AutoColumn';
	    __decorate([
	        context_1.Autowired('gridOptionsWrapper'), 
	        __metadata('design:type', gridOptionsWrapper_1.GridOptionsWrapper)
	    ], ColumnController.prototype, "gridOptionsWrapper", void 0);
	    __decorate([
	        context_1.Autowired('expressionService'), 
	        __metadata('design:type', expressionService_1.ExpressionService)
	    ], ColumnController.prototype, "expressionService", void 0);
	    __decorate([
	        context_1.Autowired('balancedColumnTreeBuilder'), 
	        __metadata('design:type', balancedColumnTreeBuilder_1.BalancedColumnTreeBuilder)
	    ], ColumnController.prototype, "balancedColumnTreeBuilder", void 0);
	    __decorate([
	        context_1.Autowired('displayedGroupCreator'), 
	        __metadata('design:type', displayedGroupCreator_1.DisplayedGroupCreator)
	    ], ColumnController.prototype, "displayedGroupCreator", void 0);
	    __decorate([
	        context_1.Autowired('autoWidthCalculator'), 
	        __metadata('design:type', autoWidthCalculator_1.AutoWidthCalculator)
	    ], ColumnController.prototype, "autoWidthCalculator", void 0);
	    __decorate([
	        context_1.Autowired('eventService'), 
	        __metadata('design:type', eventService_1.EventService)
	    ], ColumnController.prototype, "eventService", void 0);
	    __decorate([
	        context_1.Autowired('columnUtils'), 
	        __metadata('design:type', columnUtils_1.ColumnUtils)
	    ], ColumnController.prototype, "columnUtils", void 0);
	    __decorate([
	        context_1.Autowired('gridPanel'), 
	        __metadata('design:type', gridPanel_1.GridPanel)
	    ], ColumnController.prototype, "gridPanel", void 0);
	    __decorate([
	        context_1.Autowired('context'), 
	        __metadata('design:type', context_1.Context)
	    ], ColumnController.prototype, "context", void 0);
	    __decorate([
	        context_1.Optional('aggFuncService'), 
	        __metadata('design:type', Object)
	    ], ColumnController.prototype, "aggFuncService", void 0);
	    __decorate([
	        context_1.PostConstruct, 
	        __metadata('design:type', Function), 
	        __metadata('design:paramtypes', []), 
	        __metadata('design:returntype', void 0)
	    ], ColumnController.prototype, "init", null);
	    __decorate([
	        __param(0, context_1.Qualifier('loggerFactory')), 
	        __metadata('design:type', Function), 
	        __metadata('design:paramtypes', [logger_1.LoggerFactory]), 
	        __metadata('design:returntype', void 0)
	    ], ColumnController.prototype, "setBeans", null);
	    ColumnController = __decorate([
	        context_1.Bean('columnController'), 
	        __metadata('design:paramtypes', [])
	    ], ColumnController);
	    return ColumnController;
	})();
	exports.ColumnController = ColumnController;


/***/ },
/* 14 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
	 * @version v7.0.2
	 * @link http://www.ag-grid.com/
	 * @license MIT
	 */
	var column_1 = __webpack_require__(15);
	var eventService_1 = __webpack_require__(4);
	var ColumnGroup = (function () {
	    function ColumnGroup(originalColumnGroup, groupId, instanceId) {
	        // depends on the open/closed state of the group, only displaying columns are stored here
	        this.displayedChildren = [];
	        this.moving = false;
	        this.eventService = new eventService_1.EventService();
	        this.groupId = groupId;
	        this.instanceId = instanceId;
	        this.originalColumnGroup = originalColumnGroup;
	    }
	    ColumnGroup.prototype.getParent = function () {
	        return this.parent;
	    };
	    ColumnGroup.prototype.setParent = function (parent) {
	        this.parent = parent;
	    };
	    ColumnGroup.prototype.getUniqueId = function () {
	        return this.groupId + '_' + this.instanceId;
	    };
	    ColumnGroup.prototype.checkLeft = function () {
	        // first get all children to setLeft, as it impacts our decision below
	        this.displayedChildren.forEach(function (child) {
	            if (child instanceof ColumnGroup) {
	                child.checkLeft();
	            }
	        });
	        // set our left based on first displayed column
	        if (this.displayedChildren.length > 0) {
	            var firstChildLeft = this.displayedChildren[0].getLeft();
	            this.setLeft(firstChildLeft);
	        }
	        else {
	            // this should never happen, as if we have no displayed columns, then
	            // this groups should not even exist.
	            this.setLeft(null);
	        }
	    };
	    ColumnGroup.prototype.getLeft = function () {
	        return this.left;
	    };
	    ColumnGroup.prototype.setLeft = function (left) {
	        if (this.left !== left) {
	            this.left = left;
	            this.eventService.dispatchEvent(ColumnGroup.EVENT_LEFT_CHANGED);
	        }
	    };
	    ColumnGroup.prototype.addEventListener = function (eventType, listener) {
	        this.eventService.addEventListener(eventType, listener);
	    };
	    ColumnGroup.prototype.removeEventListener = function (eventType, listener) {
	        this.eventService.removeEventListener(eventType, listener);
	    };
	    ColumnGroup.prototype.setMoving = function (moving) {
	        this.getDisplayedLeafColumns().forEach(function (column) { return column.setMoving(moving); });
	    };
	    ColumnGroup.prototype.isMoving = function () {
	        return this.moving;
	    };
	    ColumnGroup.prototype.getGroupId = function () {
	        return this.groupId;
	    };
	    ColumnGroup.prototype.getInstanceId = function () {
	        return this.instanceId;
	    };
	    ColumnGroup.prototype.isChildInThisGroupDeepSearch = function (wantedChild) {
	        var result = false;
	        this.children.forEach(function (foundChild) {
	            if (wantedChild === foundChild) {
	                result = true;
	            }
	            if (foundChild instanceof ColumnGroup) {
	                if (foundChild.isChildInThisGroupDeepSearch(wantedChild)) {
	                    result = true;
	                }
	            }
	        });
	        return result;
	    };
	    ColumnGroup.prototype.getActualWidth = function () {
	        var groupActualWidth = 0;
	        if (this.displayedChildren) {
	            this.displayedChildren.forEach(function (child) {
	                groupActualWidth += child.getActualWidth();
	            });
	        }
	        return groupActualWidth;
	    };
	    ColumnGroup.prototype.getMinWidth = function () {
	        var result = 0;
	        this.displayedChildren.forEach(function (groupChild) {
	            result += groupChild.getMinWidth();
	        });
	        return result;
	    };
	    ColumnGroup.prototype.addChild = function (child) {
	        if (!this.children) {
	            this.children = [];
	        }
	        this.children.push(child);
	    };
	    ColumnGroup.prototype.getDisplayedChildren = function () {
	        return this.displayedChildren;
	    };
	    ColumnGroup.prototype.getLeafColumns = function () {
	        var result = [];
	        this.addLeafColumns(result);
	        return result;
	    };
	    ColumnGroup.prototype.getDisplayedLeafColumns = function () {
	        var result = [];
	        this.addDisplayedLeafColumns(result);
	        return result;
	    };
	    // why two methods here doing the same thing?
	    ColumnGroup.prototype.getDefinition = function () {
	        return this.originalColumnGroup.getColGroupDef();
	    };
	    ColumnGroup.prototype.getColGroupDef = function () {
	        return this.originalColumnGroup.getColGroupDef();
	    };
	    ColumnGroup.prototype.isPadding = function () {
	        return this.originalColumnGroup.isPadding();
	    };
	    ColumnGroup.prototype.isExpandable = function () {
	        return this.originalColumnGroup.isExpandable();
	    };
	    ColumnGroup.prototype.isExpanded = function () {
	        return this.originalColumnGroup.isExpanded();
	    };
	    ColumnGroup.prototype.setExpanded = function (expanded) {
	        this.originalColumnGroup.setExpanded(expanded);
	    };
	    ColumnGroup.prototype.addDisplayedLeafColumns = function (leafColumns) {
	        this.displayedChildren.forEach(function (child) {
	            if (child instanceof column_1.Column) {
	                leafColumns.push(child);
	            }
	            else if (child instanceof ColumnGroup) {
	                child.addDisplayedLeafColumns(leafColumns);
	            }
	        });
	    };
	    ColumnGroup.prototype.addLeafColumns = function (leafColumns) {
	        this.children.forEach(function (child) {
	            if (child instanceof column_1.Column) {
	                leafColumns.push(child);
	            }
	            else if (child instanceof ColumnGroup) {
	                child.addLeafColumns(leafColumns);
	            }
	        });
	    };
	    ColumnGroup.prototype.getChildren = function () {
	        return this.children;
	    };
	    ColumnGroup.prototype.getColumnGroupShow = function () {
	        return this.originalColumnGroup.getColumnGroupShow();
	    };
	    ColumnGroup.prototype.getOriginalColumnGroup = function () {
	        return this.originalColumnGroup;
	    };
	    ColumnGroup.prototype.calculateDisplayedColumns = function () {
	        // clear out last time we calculated
	        this.displayedChildren = [];
	        // it not expandable, everything is visible
	        if (!this.originalColumnGroup.isExpandable()) {
	            this.displayedChildren = this.children;
	            return;
	        }
	        // and calculate again
	        for (var i = 0, j = this.children.length; i < j; i++) {
	            var abstractColumn = this.children[i];
	            var headerGroupShow = abstractColumn.getColumnGroupShow();
	            switch (headerGroupShow) {
	                case ColumnGroup.HEADER_GROUP_SHOW_OPEN:
	                    // when set to open, only show col if group is open
	                    if (this.originalColumnGroup.isExpanded()) {
	                        this.displayedChildren.push(abstractColumn);
	                    }
	                    break;
	                case ColumnGroup.HEADER_GROUP_SHOW_CLOSED:
	                    // when set to open, only show col if group is open
	                    if (!this.originalColumnGroup.isExpanded()) {
	                        this.displayedChildren.push(abstractColumn);
	                    }
	                    break;
	                default:
	                    // default is always show the column
	                    this.displayedChildren.push(abstractColumn);
	                    break;
	            }
	        }
	    };
	    ColumnGroup.HEADER_GROUP_SHOW_OPEN = 'open';
	    ColumnGroup.HEADER_GROUP_SHOW_CLOSED = 'closed';
	    ColumnGroup.EVENT_LEFT_CHANGED = 'leftChanged';
	    return ColumnGroup;
	})();
	exports.ColumnGroup = ColumnGroup;


/***/ },
/* 15 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
	 * @version v7.0.2
	 * @link http://www.ag-grid.com/
	 * @license MIT
	 */
	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var eventService_1 = __webpack_require__(4);
	var utils_1 = __webpack_require__(7);
	var context_1 = __webpack_require__(6);
	var gridOptionsWrapper_1 = __webpack_require__(3);
	var columnUtils_1 = __webpack_require__(16);
	// Wrapper around a user provide column definition. The grid treats the column definition as ready only.
	// This class contains all the runtime information about a column, plus some logic (the definition has no logic).
	// This class implements both interfaces ColumnGroupChild and OriginalColumnGroupChild as the class can
	// appear as a child of either the original tree or the displayed tree. However the relevant group classes
	// for each type only implements one, as each group can only appear in it's associated tree (eg OriginalColumnGroup
	// can only appear in OriginalColumn tree).
	var Column = (function () {
	    function Column(colDef, colId, primary) {
	        this.moving = false;
	        this.filterActive = false;
	        this.eventService = new eventService_1.EventService();
	        this.rowGroupActive = false;
	        this.pivotActive = false;
	        this.aggregationActive = false;
	        this.colDef = colDef;
	        this.visible = !colDef.hide;
	        this.sort = colDef.sort;
	        this.sortedAt = colDef.sortedAt;
	        this.colId = colId;
	        this.primary = primary;
	    }
	    Column.prototype.setParent = function (parent) {
	        this.parent = parent;
	    };
	    Column.prototype.getParent = function () {
	        return this.parent;
	    };
	    // this is done after constructor as it uses gridOptionsWrapper
	    Column.prototype.initialise = function () {
	        this.floatingCellRenderer = this.frameworkFactory.colDefFloatingCellRenderer(this.colDef);
	        this.cellRenderer = this.frameworkFactory.colDefCellRenderer(this.colDef);
	        this.cellEditor = this.frameworkFactory.colDefCellEditor(this.colDef);
	        this.filter = this.frameworkFactory.colDefFilter(this.colDef);
	        this.setPinned(this.colDef.pinned);
	        var minColWidth = this.gridOptionsWrapper.getMinColWidth();
	        var maxColWidth = this.gridOptionsWrapper.getMaxColWidth();
	        if (this.colDef.minWidth) {
	            this.minWidth = this.colDef.minWidth;
	        }
	        else {
	            this.minWidth = minColWidth;
	        }
	        if (this.colDef.maxWidth) {
	            this.maxWidth = this.colDef.maxWidth;
	        }
	        else {
	            this.maxWidth = maxColWidth;
	        }
	        this.actualWidth = this.columnUtils.calculateColInitialWidth(this.colDef);
	        var suppressDotNotation = this.gridOptionsWrapper.isSuppressFieldDotNotation();
	        this.fieldContainsDots = utils_1.Utils.exists(this.colDef.field) && this.colDef.field.indexOf('.') >= 0 && !suppressDotNotation;
	        this.tooltipFieldContainsDots = utils_1.Utils.exists(this.colDef.tooltipField) && this.colDef.tooltipField.indexOf('.') >= 0 && !suppressDotNotation;
	        this.validate();
	    };
	    Column.prototype.getCellRenderer = function () {
	        return this.cellRenderer;
	    };
	    Column.prototype.getCellEditor = function () {
	        return this.cellEditor;
	    };
	    Column.prototype.getFloatingCellRenderer = function () {
	        return this.floatingCellRenderer;
	    };
	    Column.prototype.getFilter = function () {
	        return this.filter;
	    };
	    Column.prototype.getUniqueId = function () {
	        return this.getId();
	    };
	    Column.prototype.isPrimary = function () {
	        return this.primary;
	    };
	    Column.prototype.isFilterAllowed = function () {
	        return this.primary && !this.colDef.suppressFilter;
	    };
	    Column.prototype.isFieldContainsDots = function () {
	        return this.fieldContainsDots;
	    };
	    Column.prototype.isTooltipFieldContainsDots = function () {
	        return this.tooltipFieldContainsDots;
	    };
	    Column.prototype.validate = function () {
	        if (!this.gridOptionsWrapper.isEnterprise()) {
	            if (utils_1.Utils.exists(this.colDef.aggFunc)) {
	                console.warn('ag-Grid: aggFunc is only valid in ag-Grid-Enterprise');
	            }
	            if (utils_1.Utils.exists(this.colDef.rowGroupIndex)) {
	                console.warn('ag-Grid: rowGroupIndex is only valid in ag-Grid-Enterprise');
	            }
	        }
	        if (utils_1.Utils.exists(this.colDef.width) && typeof this.colDef.width !== 'number') {
	            console.warn('ag-Grid: colDef.width should be a number, not ' + typeof this.colDef.width);
	        }
	    };
	    Column.prototype.addEventListener = function (eventType, listener) {
	        this.eventService.addEventListener(eventType, listener);
	    };
	    Column.prototype.removeEventListener = function (eventType, listener) {
	        this.eventService.removeEventListener(eventType, listener);
	    };
	    Column.prototype.createIsColumnFuncParams = function (rowNode) {
	        return {
	            node: rowNode,
	            column: this,
	            colDef: this.colDef,
	            context: this.gridOptionsWrapper.getContext(),
	            api: this.gridOptionsWrapper.getApi(),
	            columnApi: this.gridOptionsWrapper.getColumnApi()
	        };
	    };
	    Column.prototype.isSuppressNavigable = function (rowNode) {
	        // if boolean set, then just use it
	        if (typeof this.colDef.suppressNavigable === 'boolean') {
	            return this.colDef.suppressNavigable;
	        }
	        // if function, then call the function to find out
	        if (typeof this.colDef.suppressNavigable === 'function') {
	            var params = this.createIsColumnFuncParams(rowNode);
	            var suppressNaviableFunc = this.colDef.suppressNavigable;
	            return suppressNaviableFunc(params);
	        }
	        return false;
	    };
	    Column.prototype.isCellEditable = function (rowNode) {
	        // if boolean set, then just use it
	        if (typeof this.colDef.editable === 'boolean') {
	            return this.colDef.editable;
	        }
	        // if function, then call the function to find out
	        if (typeof this.colDef.editable === 'function') {
	            var params = this.createIsColumnFuncParams(rowNode);
	            var editableFunc = this.colDef.editable;
	            return editableFunc(params);
	        }
	        return false;
	    };
	    Column.prototype.setMoving = function (moving) {
	        this.moving = moving;
	        this.eventService.dispatchEvent(Column.EVENT_MOVING_CHANGED);
	    };
	    Column.prototype.isMoving = function () {
	        return this.moving;
	    };
	    Column.prototype.getSort = function () {
	        return this.sort;
	    };
	    Column.prototype.setSort = function (sort) {
	        if (this.sort !== sort) {
	            this.sort = sort;
	            this.eventService.dispatchEvent(Column.EVENT_SORT_CHANGED);
	        }
	    };
	    Column.prototype.isSortAscending = function () {
	        return this.sort === Column.SORT_ASC;
	    };
	    Column.prototype.isSortDescending = function () {
	        return this.sort === Column.SORT_DESC;
	    };
	    Column.prototype.isSortNone = function () {
	        return utils_1.Utils.missing(this.sort);
	    };
	    Column.prototype.getSortedAt = function () {
	        return this.sortedAt;
	    };
	    Column.prototype.setSortedAt = function (sortedAt) {
	        this.sortedAt = sortedAt;
	    };
	    Column.prototype.setAggFunc = function (aggFunc) {
	        this.aggFunc = aggFunc;
	    };
	    Column.prototype.getAggFunc = function () {
	        return this.aggFunc;
	    };
	    Column.prototype.getLeft = function () {
	        return this.left;
	    };
	    Column.prototype.getRight = function () {
	        return this.left + this.actualWidth;
	    };
	    Column.prototype.setLeft = function (left) {
	        if (this.left !== left) {
	            this.left = left;
	            this.eventService.dispatchEvent(Column.EVENT_LEFT_CHANGED);
	        }
	    };
	    Column.prototype.isFilterActive = function () {
	        return this.filterActive;
	    };
	    Column.prototype.setFilterActive = function (active) {
	        if (this.filterActive !== active) {
	            this.filterActive = active;
	            this.eventService.dispatchEvent(Column.EVENT_FILTER_CHANGED);
	        }
	    };
	    Column.prototype.setPinned = function (pinned) {
	        // pinning is not allowed when doing 'forPrint'
	        if (this.gridOptionsWrapper.isForPrint()) {
	            return;
	        }
	        if (pinned === true || pinned === Column.PINNED_LEFT) {
	            this.pinned = Column.PINNED_LEFT;
	        }
	        else if (pinned === Column.PINNED_RIGHT) {
	            this.pinned = Column.PINNED_RIGHT;
	        }
	        else {
	            this.pinned = null;
	        }
	        // console.log(`setColumnsPinned ${this.getColId()} ${this.pinned}`);
	    };
	    Column.prototype.setFirstRightPinned = function (firstRightPinned) {
	        if (this.firstRightPinned !== firstRightPinned) {
	            this.firstRightPinned = firstRightPinned;
	            this.eventService.dispatchEvent(Column.EVENT_FIRST_RIGHT_PINNED_CHANGED);
	        }
	    };
	    Column.prototype.setLastLeftPinned = function (lastLeftPinned) {
	        if (this.lastLeftPinned !== lastLeftPinned) {
	            this.lastLeftPinned = lastLeftPinned;
	            this.eventService.dispatchEvent(Column.EVENT_LAST_LEFT_PINNED_CHANGED);
	        }
	    };
	    Column.prototype.isFirstRightPinned = function () {
	        return this.firstRightPinned;
	    };
	    Column.prototype.isLastLeftPinned = function () {
	        return this.lastLeftPinned;
	    };
	    Column.prototype.isPinned = function () {
	        return this.pinned === Column.PINNED_LEFT || this.pinned === Column.PINNED_RIGHT;
	    };
	    Column.prototype.isPinnedLeft = function () {
	        return this.pinned === Column.PINNED_LEFT;
	    };
	    Column.prototype.isPinnedRight = function () {
	        return this.pinned === Column.PINNED_RIGHT;
	    };
	    Column.prototype.getPinned = function () {
	        return this.pinned;
	    };
	    Column.prototype.setVisible = function (visible) {
	        var newValue = visible === true;
	        if (this.visible !== newValue) {
	            this.visible = newValue;
	            this.eventService.dispatchEvent(Column.EVENT_VISIBLE_CHANGED);
	        }
	    };
	    Column.prototype.isVisible = function () {
	        return this.visible;
	    };
	    Column.prototype.getColDef = function () {
	        return this.colDef;
	    };
	    Column.prototype.getColumnGroupShow = function () {
	        return this.colDef.columnGroupShow;
	    };
	    Column.prototype.getColId = function () {
	        return this.colId;
	    };
	    Column.prototype.getId = function () {
	        return this.getColId();
	    };
	    Column.prototype.getDefinition = function () {
	        return this.colDef;
	    };
	    Column.prototype.getActualWidth = function () {
	        return this.actualWidth;
	    };
	    Column.prototype.setActualWidth = function (actualWidth) {
	        if (this.actualWidth !== actualWidth) {
	            this.actualWidth = actualWidth;
	            this.eventService.dispatchEvent(Column.EVENT_WIDTH_CHANGED);
	        }
	    };
	    Column.prototype.isGreaterThanMax = function (width) {
	        if (this.maxWidth) {
	            return width > this.maxWidth;
	        }
	        else {
	            return false;
	        }
	    };
	    Column.prototype.getMinWidth = function () {
	        return this.minWidth;
	    };
	    Column.prototype.getMaxWidth = function () {
	        return this.maxWidth;
	    };
	    Column.prototype.setMinimum = function () {
	        this.setActualWidth(this.minWidth);
	    };
	    Column.prototype.setRowGroupActive = function (rowGroup) {
	        if (this.rowGroupActive !== rowGroup) {
	            this.rowGroupActive = rowGroup;
	            this.eventService.dispatchEvent(Column.EVENT_ROW_GROUP_CHANGED, this);
	        }
	    };
	    Column.prototype.isRowGroupActive = function () {
	        return this.rowGroupActive;
	    };
	    Column.prototype.setPivotActive = function (pivot) {
	        if (this.pivotActive !== pivot) {
	            this.pivotActive = pivot;
	            this.eventService.dispatchEvent(Column.EVENT_PIVOT_CHANGED, this);
	        }
	    };
	    Column.prototype.isPivotActive = function () {
	        return this.pivotActive;
	    };
	    Column.prototype.isAnyFunctionActive = function () {
	        return this.isPivotActive() || this.isRowGroupActive() || this.isValueActive();
	    };
	    Column.prototype.isAnyFunctionAllowed = function () {
	        return this.isAllowPivot() || this.isAllowRowGroup() || this.isAllowValue();
	    };
	    Column.prototype.setValueActive = function (value) {
	        if (this.aggregationActive !== value) {
	            this.aggregationActive = value;
	            this.eventService.dispatchEvent(Column.EVENT_VALUE_CHANGED, this);
	        }
	    };
	    Column.prototype.isValueActive = function () {
	        return this.aggregationActive;
	    };
	    Column.prototype.isAllowPivot = function () {
	        return this.colDef.enablePivot === true;
	    };
	    Column.prototype.isAllowValue = function () {
	        return this.colDef.enableValue === true;
	    };
	    Column.prototype.isAllowRowGroup = function () {
	        return this.colDef.enableRowGroup === true;
	    };
	    // + renderedHeaderCell - for making header cell transparent when moving
	    Column.EVENT_MOVING_CHANGED = 'movingChanged';
	    // + renderedCell - changing left position
	    Column.EVENT_LEFT_CHANGED = 'leftChanged';
	    // + renderedCell - changing width
	    Column.EVENT_WIDTH_CHANGED = 'widthChanged';
	    // + renderedCell - for changing pinned classes
	    Column.EVENT_LAST_LEFT_PINNED_CHANGED = 'lastLeftPinnedChanged';
	    Column.EVENT_FIRST_RIGHT_PINNED_CHANGED = 'firstRightPinnedChanged';
	    // + renderedColumn - for changing visibility icon
	    Column.EVENT_VISIBLE_CHANGED = 'visibleChanged';
	    // + renderedHeaderCell - marks the header with filter icon
	    Column.EVENT_FILTER_CHANGED = 'filterChanged';
	    // + renderedHeaderCell - marks the header with sort icon
	    Column.EVENT_SORT_CHANGED = 'sortChanged';
	    // + toolpanel, for gui updates
	    Column.EVENT_ROW_GROUP_CHANGED = 'columnRowGroupChanged';
	    // + toolpanel, for gui updates
	    Column.EVENT_PIVOT_CHANGED = 'columnPivotChanged';
	    // + toolpanel, for gui updates
	    Column.EVENT_VALUE_CHANGED = 'columnValueChanged';
	    Column.PINNED_RIGHT = 'right';
	    Column.PINNED_LEFT = 'left';
	    Column.SORT_ASC = 'asc';
	    Column.SORT_DESC = 'desc';
	    __decorate([
	        context_1.Autowired('gridOptionsWrapper'), 
	        __metadata('design:type', gridOptionsWrapper_1.GridOptionsWrapper)
	    ], Column.prototype, "gridOptionsWrapper", void 0);
	    __decorate([
	        context_1.Autowired('columnUtils'), 
	        __metadata('design:type', columnUtils_1.ColumnUtils)
	    ], Column.prototype, "columnUtils", void 0);
	    __decorate([
	        context_1.Autowired('frameworkFactory'), 
	        __metadata('design:type', Object)
	    ], Column.prototype, "frameworkFactory", void 0);
	    __decorate([
	        context_1.PostConstruct, 
	        __metadata('design:type', Function), 
	        __metadata('design:paramtypes', []), 
	        __metadata('design:returntype', void 0)
	    ], Column.prototype, "initialise", null);
	    return Column;
	})();
	exports.Column = Column;


/***/ },
/* 16 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
	 * @version v7.0.2
	 * @link http://www.ag-grid.com/
	 * @license MIT
	 */
	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var gridOptionsWrapper_1 = __webpack_require__(3);
	var columnGroup_1 = __webpack_require__(14);
	var originalColumnGroup_1 = __webpack_require__(17);
	var context_1 = __webpack_require__(6);
	var context_2 = __webpack_require__(6);
	// takes in a list of columns, as specified by the column definitions, and returns column groups
	var ColumnUtils = (function () {
	    function ColumnUtils() {
	    }
	    ColumnUtils.prototype.calculateColInitialWidth = function (colDef) {
	        if (!colDef.width) {
	            // if no width defined in colDef, use default
	            return this.gridOptionsWrapper.getColWidth();
	        }
	        else if (colDef.width < this.gridOptionsWrapper.getMinColWidth()) {
	            // if width in col def to small, set to min width
	            return this.gridOptionsWrapper.getMinColWidth();
	        }
	        else {
	            // otherwise use the provided width
	            return colDef.width;
	        }
	    };
	    ColumnUtils.prototype.getOriginalPathForColumn = function (column, originalBalancedTree) {
	        var result = [];
	        var found = false;
	        recursePath(originalBalancedTree, 0);
	        // we should always find the path, but in case there is a bug somewhere, returning null
	        // will make it fail rather than provide a 'hard to track down' bug
	        if (found) {
	            return result;
	        }
	        else {
	            return null;
	        }
	        function recursePath(balancedColumnTree, dept) {
	            for (var i = 0; i < balancedColumnTree.length; i++) {
	                if (found) {
	                    // quit the search, so 'result' is kept with the found result
	                    return;
	                }
	                var node = balancedColumnTree[i];
	                if (node instanceof originalColumnGroup_1.OriginalColumnGroup) {
	                    var nextNode = node;
	                    recursePath(nextNode.getChildren(), dept + 1);
	                    result[dept] = node;
	                }
	                else {
	                    if (node === column) {
	                        found = true;
	                    }
	                }
	            }
	        }
	    };
	    /*    public getPathForColumn(column: Column, allDisplayedColumnGroups: ColumnGroupChild[]): ColumnGroup[] {
	            var result: ColumnGroup[] = [];
	            var found = false;
	    
	            recursePath(allDisplayedColumnGroups, 0);
	    
	            // we should always find the path, but in case there is a bug somewhere, returning null
	            // will make it fail rather than provide a 'hard to track down' bug
	            if (found) {
	                return result;
	            } else {
	                return null;
	            }
	    
	            function recursePath(balancedColumnTree: ColumnGroupChild[], dept: number): void {
	    
	                for (var i = 0; i<balancedColumnTree.length; i++) {
	                    if (found) {
	                        // quit the search, so 'result' is kept with the found result
	                        return;
	                    }
	                    var node = balancedColumnTree[i];
	                    if (node instanceof ColumnGroup) {
	                        var nextNode = <ColumnGroup> node;
	                        recursePath(nextNode.getChildren(), dept+1);
	                        result[dept] = node;
	                    } else {
	                        if (node === column) {
	                            found = true;
	                        }
	                    }
	                }
	            }
	        }*/
	    ColumnUtils.prototype.depthFirstOriginalTreeSearch = function (tree, callback) {
	        var _this = this;
	        if (!tree) {
	            return;
	        }
	        tree.forEach(function (child) {
	            if (child instanceof originalColumnGroup_1.OriginalColumnGroup) {
	                _this.depthFirstOriginalTreeSearch(child.getChildren(), callback);
	            }
	            callback(child);
	        });
	    };
	    ColumnUtils.prototype.depthFirstAllColumnTreeSearch = function (tree, callback) {
	        var _this = this;
	        if (!tree) {
	            return;
	        }
	        tree.forEach(function (child) {
	            if (child instanceof columnGroup_1.ColumnGroup) {
	                _this.depthFirstAllColumnTreeSearch(child.getChildren(), callback);
	            }
	            callback(child);
	        });
	    };
	    ColumnUtils.prototype.depthFirstDisplayedColumnTreeSearch = function (tree, callback) {
	        var _this = this;
	        if (!tree) {
	            return;
	        }
	        tree.forEach(function (child) {
	            if (child instanceof columnGroup_1.ColumnGroup) {
	                _this.depthFirstDisplayedColumnTreeSearch(child.getDisplayedChildren(), callback);
	            }
	            callback(child);
	        });
	    };
	    __decorate([
	        context_2.Autowired('gridOptionsWrapper'), 
	        __metadata('design:type', gridOptionsWrapper_1.GridOptionsWrapper)
	    ], ColumnUtils.prototype, "gridOptionsWrapper", void 0);
	    ColumnUtils = __decorate([
	        context_1.Bean('columnUtils'), 
	        __metadata('design:paramtypes', [])
	    ], ColumnUtils);
	    return ColumnUtils;
	})();
	exports.ColumnUtils = ColumnUtils;


/***/ },
/* 17 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
	 * @version v7.0.2
	 * @link http://www.ag-grid.com/
	 * @license MIT
	 */
	var columnGroup_1 = __webpack_require__(14);
	var column_1 = __webpack_require__(15);
	var OriginalColumnGroup = (function () {
	    function OriginalColumnGroup(colGroupDef, groupId, padding) {
	        this.expandable = false;
	        this.colGroupDef = colGroupDef;
	        this.groupId = groupId;
	        this.expanded = colGroupDef && !!colGroupDef.openByDefault;
	        this.padding = padding;
	    }
	    OriginalColumnGroup.prototype.isPadding = function () {
	        return this.padding;
	    };
	    OriginalColumnGroup.prototype.setExpanded = function (expanded) {
	        this.expanded = expanded;
	    };
	    OriginalColumnGroup.prototype.isExpandable = function () {
	        return this.expandable;
	    };
	    OriginalColumnGroup.prototype.isExpanded = function () {
	        return this.expanded;
	    };
	    OriginalColumnGroup.prototype.getGroupId = function () {
	        return this.groupId;
	    };
	    OriginalColumnGroup.prototype.getId = function () {
	        return this.getGroupId();
	    };
	    OriginalColumnGroup.prototype.setChildren = function (children) {
	        this.children = children;
	    };
	    OriginalColumnGroup.prototype.getChildren = function () {
	        return this.children;
	    };
	    OriginalColumnGroup.prototype.getColGroupDef = function () {
	        return this.colGroupDef;
	    };
	    OriginalColumnGroup.prototype.getLeafColumns = function () {
	        var result = [];
	        this.addLeafColumns(result);
	        return result;
	    };
	    OriginalColumnGroup.prototype.addLeafColumns = function (leafColumns) {
	        this.children.forEach(function (child) {
	            if (child instanceof column_1.Column) {
	                leafColumns.push(child);
	            }
	            else if (child instanceof OriginalColumnGroup) {
	                child.addLeafColumns(leafColumns);
	            }
	        });
	    };
	    OriginalColumnGroup.prototype.getColumnGroupShow = function () {
	        if (!this.padding) {
	            return this.colGroupDef.columnGroupShow;
	        }
	        else {
	            // if this is padding we have exactly only child. we then
	            // take the value from the child and push it up, making
	            // this group 'invisible'.
	            return this.children[0].getColumnGroupShow();
	        }
	    };
	    // need to check that this group has at least one col showing when both expanded and contracted.
	    // if not, then we don't allow expanding and contracting on this group
	    OriginalColumnGroup.prototype.calculateExpandable = function () {
	        // want to make sure the group doesn't disappear when it's open
	        var atLeastOneShowingWhenOpen = false;
	        // want to make sure the group doesn't disappear when it's closed
	        var atLeastOneShowingWhenClosed = false;
	        // want to make sure the group has something to show / hide
	        var atLeastOneChangeable = false;
	        for (var i = 0, j = this.children.length; i < j; i++) {
	            var abstractColumn = this.children[i];
	            // if the abstractColumn is a grid generated group, there will be no colDef
	            var headerGroupShow = abstractColumn.getColumnGroupShow();
	            if (headerGroupShow === columnGroup_1.ColumnGroup.HEADER_GROUP_SHOW_OPEN) {
	                atLeastOneShowingWhenOpen = true;
	                atLeastOneChangeable = true;
	            }
	            else if (headerGroupShow === columnGroup_1.ColumnGroup.HEADER_GROUP_SHOW_CLOSED) {
	                atLeastOneShowingWhenClosed = true;
	                atLeastOneChangeable = true;
	            }
	            else {
	                atLeastOneShowingWhenOpen = true;
	                atLeastOneShowingWhenClosed = true;
	            }
	        }
	        this.expandable = atLeastOneShowingWhenOpen && atLeastOneShowingWhenClosed && atLeastOneChangeable;
	    };
	    return OriginalColumnGroup;
	})();
	exports.OriginalColumnGroup = OriginalColumnGroup;


/***/ },
/* 18 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
	 * @version v7.0.2
	 * @link http://www.ag-grid.com/
	 * @license MIT
	 */
	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var __param = (this && this.__param) || function (paramIndex, decorator) {
	    return function (target, key) { decorator(target, key, paramIndex); }
	};
	var logger_1 = __webpack_require__(5);
	var context_1 = __webpack_require__(6);
	var context_2 = __webpack_require__(6);
	var ExpressionService = (function () {
	    function ExpressionService() {
	        this.expressionToFunctionCache = {};
	    }
	    ExpressionService.prototype.setBeans = function (loggerFactory) {
	        this.logger = loggerFactory.create('ExpressionService');
	    };
	    ExpressionService.prototype.evaluate = function (expression, params) {
	        try {
	            var javaScriptFunction = this.createExpressionFunction(expression);
	            var result = javaScriptFunction(params.value, params.context, params.node, params.data, params.colDef, params.rowIndex, params.api, params.getValue, params.column, params.columnGroup);
	            return result;
	        }
	        catch (e) {
	            // the expression failed, which can happen, as it's the client that
	            // provides the expression. so print a nice message
	            this.logger.log('Processing of the expression failed');
	            this.logger.log('Expression = ' + expression);
	            this.logger.log('Exception = ' + e);
	            return null;
	        }
	    };
	    ExpressionService.prototype.createExpressionFunction = function (expression) {
	        // check cache first
	        if (this.expressionToFunctionCache[expression]) {
	            return this.expressionToFunctionCache[expression];
	        }
	        // if not found in cache, return the function
	        var functionBody = this.createFunctionBody(expression);
	        var theFunction = new Function('x, ctx, node, data, colDef, rowIndex, api, getValue, column, columnGroup', functionBody);
	        // store in cache
	        this.expressionToFunctionCache[expression] = theFunction;
	        return theFunction;
	    };
	    ExpressionService.prototype.createFunctionBody = function (expression) {
	        // if the expression has the 'return' word in it, then use as is,
	        // if not, then wrap it with return and ';' to make a function
	        if (expression.indexOf('return') >= 0) {
	            return expression;
	        }
	        else {
	            return 'return ' + expression + ';';
	        }
	    };
	    __decorate([
	        __param(0, context_2.Qualifier('loggerFactory')), 
	        __metadata('design:type', Function), 
	        __metadata('design:paramtypes', [logger_1.LoggerFactory]), 
	        __metadata('design:returntype', void 0)
	    ], ExpressionService.prototype, "setBeans", null);
	    ExpressionService = __decorate([
	        context_1.Bean('expressionService'), 
	        __metadata('design:paramtypes', [])
	    ], ExpressionService);
	    return ExpressionService;
	})();
	exports.ExpressionService = ExpressionService;


/***/ },
/* 19 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
	 * @version v7.0.2
	 * @link http://www.ag-grid.com/
	 * @license MIT
	 */
	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var __param = (this && this.__param) || function (paramIndex, decorator) {
	    return function (target, key) { decorator(target, key, paramIndex); }
	};
	var gridOptionsWrapper_1 = __webpack_require__(3);
	var logger_1 = __webpack_require__(5);
	var columnUtils_1 = __webpack_require__(16);
	var columnKeyCreator_1 = __webpack_require__(20);
	var originalColumnGroup_1 = __webpack_require__(17);
	var column_1 = __webpack_require__(15);
	var context_1 = __webpack_require__(6);
	var context_2 = __webpack_require__(6);
	var context_3 = __webpack_require__(6);
	var context_4 = __webpack_require__(6);
	var utils_1 = __webpack_require__(7);
	// takes in a list of columns, as specified by the column definitions, and returns column groups
	var BalancedColumnTreeBuilder = (function () {
	    function BalancedColumnTreeBuilder() {
	    }
	    BalancedColumnTreeBuilder.prototype.setBeans = function (loggerFactory) {
	        this.logger = loggerFactory.create('BalancedColumnTreeBuilder');
	    };
	    BalancedColumnTreeBuilder.prototype.createBalancedColumnGroups = function (abstractColDefs, primaryColumns) {
	        // column key creator dishes out unique column id's in a deterministic way,
	        // so if we have two grids (that cold be master/slave) with same column definitions,
	        // then this ensures the two grids use identical id's.
	        var columnKeyCreator = new columnKeyCreator_1.ColumnKeyCreator();
	        // create am unbalanced tree that maps the provided definitions
	        var unbalancedTree = this.recursivelyCreateColumns(abstractColDefs, 0, columnKeyCreator, primaryColumns);
	        var treeDept = this.findMaxDept(unbalancedTree, 0);
	        this.logger.log('Number of levels for grouped columns is ' + treeDept);
	        var balancedTree = this.balanceColumnTree(unbalancedTree, 0, treeDept, columnKeyCreator);
	        this.columnUtils.depthFirstOriginalTreeSearch(balancedTree, function (child) {
	            if (child instanceof originalColumnGroup_1.OriginalColumnGroup) {
	                child.calculateExpandable();
	            }
	        });
	        return {
	            balancedTree: balancedTree,
	            treeDept: treeDept
	        };
	    };
	    BalancedColumnTreeBuilder.prototype.balanceColumnTree = function (unbalancedTree, currentDept, columnDept, columnKeyCreator) {
	        var _this = this;
	        var result = [];
	        // go through each child, for groups, recurse a level deeper,
	        // for columns we need to pad
	        unbalancedTree.forEach(function (child) {
	            if (child instanceof originalColumnGroup_1.OriginalColumnGroup) {
	                var originalGroup = child;
	                var newChildren = _this.balanceColumnTree(originalGroup.getChildren(), currentDept + 1, columnDept, columnKeyCreator);
	                originalGroup.setChildren(newChildren);
	                result.push(originalGroup);
	            }
	            else {
	                var newChild = child;
	                for (var i = columnDept - 1; i >= currentDept; i--) {
	                    var newColId = columnKeyCreator.getUniqueKey(null, null);
	                    var colGroupDefMerged = _this.createMergedColGroupDef(null);
	                    var paddedGroup = new originalColumnGroup_1.OriginalColumnGroup(colGroupDefMerged, newColId, true);
	                    paddedGroup.setChildren([newChild]);
	                    newChild = paddedGroup;
	                }
	                result.push(newChild);
	            }
	        });
	        return result;
	    };
	    BalancedColumnTreeBuilder.prototype.findMaxDept = function (treeChildren, dept) {
	        var maxDeptThisLevel = dept;
	        for (var i = 0; i < treeChildren.length; i++) {
	            var abstractColumn = treeChildren[i];
	            if (abstractColumn instanceof originalColumnGroup_1.OriginalColumnGroup) {
	                var originalGroup = abstractColumn;
	                var newDept = this.findMaxDept(originalGroup.getChildren(), dept + 1);
	                if (maxDeptThisLevel < newDept) {
	                    maxDeptThisLevel = newDept;
	                }
	            }
	        }
	        return maxDeptThisLevel;
	    };
	    BalancedColumnTreeBuilder.prototype.recursivelyCreateColumns = function (abstractColDefs, level, columnKeyCreator, primaryColumns) {
	        var _this = this;
	        var result = [];
	        if (!abstractColDefs) {
	            return result;
	        }
	        abstractColDefs.forEach(function (abstractColDef) {
	            var newGroupOrColumn;
	            if (_this.isColumnGroup(abstractColDef)) {
	                newGroupOrColumn = _this.createColumnGroup(columnKeyCreator, primaryColumns, abstractColDef, level);
	            }
	            else {
	                newGroupOrColumn = _this.createColumn(columnKeyCreator, primaryColumns, abstractColDef);
	            }
	            result.push(newGroupOrColumn);
	        });
	        return result;
	    };
	    BalancedColumnTreeBuilder.prototype.createColumnGroup = function (columnKeyCreator, primaryColumns, colGroupDef, level) {
	        var colGroupDefMerged = this.createMergedColGroupDef(colGroupDef);
	        var groupId = columnKeyCreator.getUniqueKey(colGroupDefMerged.groupId, null);
	        var originalGroup = new originalColumnGroup_1.OriginalColumnGroup(colGroupDefMerged, groupId, false);
	        var children = this.recursivelyCreateColumns(colGroupDefMerged.children, level + 1, columnKeyCreator, primaryColumns);
	        originalGroup.setChildren(children);
	        return originalGroup;
	    };
	    BalancedColumnTreeBuilder.prototype.createMergedColGroupDef = function (colGroupDef) {
	        var colGroupDefMerged = {};
	        utils_1.Utils.assign(colGroupDefMerged, this.gridOptionsWrapper.getDefaultColGroupDef());
	        utils_1.Utils.assign(colGroupDefMerged, colGroupDef);
	        this.checkForDeprecatedItems(colGroupDefMerged);
	        return colGroupDefMerged;
	    };
	    BalancedColumnTreeBuilder.prototype.createColumn = function (columnKeyCreator, primaryColumns, colDef3) {
	        var colDefMerged = {};
	        utils_1.Utils.assign(colDefMerged, this.gridOptionsWrapper.getDefaultColDef());
	        utils_1.Utils.assign(colDefMerged, colDef3);
	        this.checkForDeprecatedItems(colDefMerged);
	        var colId = columnKeyCreator.getUniqueKey(colDefMerged.colId, colDefMerged.field);
	        var column = new column_1.Column(colDefMerged, colId, primaryColumns);
	        this.context.wireBean(column);
	        return column;
	    };
	    BalancedColumnTreeBuilder.prototype.checkForDeprecatedItems = function (colDef) {
	        if (colDef) {
	            var colDefNoType = colDef; // take out the type, so we can access attributes not defined in the type
	            if (colDefNoType.group !== undefined) {
	                console.warn('ag-grid: colDef.group is invalid, please check documentation on how to do grouping as it changed in version 3');
	            }
	            if (colDefNoType.headerGroup !== undefined) {
	                console.warn('ag-grid: colDef.headerGroup is invalid, please check documentation on how to do grouping as it changed in version 3');
	            }
	            if (colDefNoType.headerGroupShow !== undefined) {
	                console.warn('ag-grid: colDef.headerGroupShow is invalid, should be columnGroupShow, please check documentation on how to do grouping as it changed in version 3');
	            }
	            if (colDefNoType.suppressRowGroup !== undefined) {
	                console.warn('ag-grid: colDef.suppressRowGroup is deprecated, please use colDef.type instead');
	            }
	            if (colDefNoType.suppressAggregation !== undefined) {
	                console.warn('ag-grid: colDef.suppressAggregation is deprecated, please use colDef.type instead');
	            }
	            if (colDefNoType.suppressRowGroup || colDefNoType.suppressAggregation) {
	                console.warn('ag-grid: colDef.suppressAggregation and colDef.suppressRowGroup are deprecated, use allowRowGroup, allowPivot and allowValue instead');
	            }
	            if (colDefNoType.displayName) {
	                console.warn("ag-grid: Found displayName " + colDefNoType.displayName + ", please use headerName instead, displayName is deprecated.");
	                colDefNoType.headerName = colDefNoType.displayName;
	            }
	        }
	    };
	    // if object has children, we assume it's a group
	    BalancedColumnTreeBuilder.prototype.isColumnGroup = function (abstractColDef) {
	        return abstractColDef.children !== undefined;
	    };
	    __decorate([
	        context_3.Autowired('gridOptionsWrapper'), 
	        __metadata('design:type', gridOptionsWrapper_1.GridOptionsWrapper)
	    ], BalancedColumnTreeBuilder.prototype, "gridOptionsWrapper", void 0);
	    __decorate([
	        context_3.Autowired('columnUtils'), 
	        __metadata('design:type', columnUtils_1.ColumnUtils)
	    ], BalancedColumnTreeBuilder.prototype, "columnUtils", void 0);
	    __decorate([
	        context_3.Autowired('context'), 
	        __metadata('design:type', context_4.Context)
	    ], BalancedColumnTreeBuilder.prototype, "context", void 0);
	    __decorate([
	        __param(0, context_2.Qualifier('loggerFactory')), 
	        __metadata('design:type', Function), 
	        __metadata('design:paramtypes', [logger_1.LoggerFactory]), 
	        __metadata('design:returntype', void 0)
	    ], BalancedColumnTreeBuilder.prototype, "setBeans", null);
	    BalancedColumnTreeBuilder = __decorate([
	        context_1.Bean('balancedColumnTreeBuilder'), 
	        __metadata('design:paramtypes', [])
	    ], BalancedColumnTreeBuilder);
	    return BalancedColumnTreeBuilder;
	})();
	exports.BalancedColumnTreeBuilder = BalancedColumnTreeBuilder;


/***/ },
/* 20 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
	 * @version v7.0.2
	 * @link http://www.ag-grid.com/
	 * @license MIT
	 */
	// class returns a unique id to use for the column. it checks the existing columns, and if the requested
	// id is already taken, it will start appending numbers until it gets a unique id.
	// eg, if the col field is 'name', it will try ids: {name, name_1, name_2...}
	// if no field or id provided in the col, it will try the ids of natural numbers
	var utils_1 = __webpack_require__(7);
	var ColumnKeyCreator = (function () {
	    function ColumnKeyCreator() {
	        this.existingKeys = [];
	    }
	    ColumnKeyCreator.prototype.getUniqueKey = function (colId, colField) {
	        // in case user passed in number for colId, convert to string
	        colId = utils_1.Utils.toStringOrNull(colId);
	        var count = 0;
	        while (true) {
	            var idToTry;
	            if (colId) {
	                idToTry = colId;
	                if (count !== 0) {
	                    idToTry += '_' + count;
	                }
	            }
	            else if (colField) {
	                idToTry = colField;
	                if (count !== 0) {
	                    idToTry += '_' + count;
	                }
	            }
	            else {
	                idToTry = '' + count;
	            }
	            if (this.existingKeys.indexOf(idToTry) < 0) {
	                this.existingKeys.push(idToTry);
	                return idToTry;
	            }
	            count++;
	        }
	    };
	    return ColumnKeyCreator;
	})();
	exports.ColumnKeyCreator = ColumnKeyCreator;


/***/ },
/* 21 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
	 * @version v7.0.2
	 * @link http://www.ag-grid.com/
	 * @license MIT
	 */
	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var columnUtils_1 = __webpack_require__(16);
	var columnGroup_1 = __webpack_require__(14);
	var originalColumnGroup_1 = __webpack_require__(17);
	var context_1 = __webpack_require__(6);
	var context_2 = __webpack_require__(6);
	// takes in a list of columns, as specified by the column definitions, and returns column groups
	var DisplayedGroupCreator = (function () {
	    function DisplayedGroupCreator() {
	    }
	    DisplayedGroupCreator.prototype.createDisplayedGroups = function (sortedVisibleColumns, balancedColumnTree, groupInstanceIdCreator) {
	        var _this = this;
	        var result = [];
	        var previousRealPath;
	        var previousOriginalPath;
	        // go through each column, then do a bottom up comparison to the previous column, and start
	        // to share groups if they converge at any point.
	        sortedVisibleColumns.forEach(function (currentColumn) {
	            var currentOriginalPath = _this.getOriginalPathForColumn(balancedColumnTree, currentColumn);
	            var currentRealPath = [];
	            var firstColumn = !previousOriginalPath;
	            for (var i = 0; i < currentOriginalPath.length; i++) {
	                if (firstColumn || currentOriginalPath[i] !== previousOriginalPath[i]) {
	                    // new group needed
	                    var originalGroup = currentOriginalPath[i];
	                    var groupId = originalGroup.getGroupId();
	                    var instanceId = groupInstanceIdCreator.getInstanceIdForKey(groupId);
	                    var newGroup = new columnGroup_1.ColumnGroup(originalGroup, groupId, instanceId);
	                    currentRealPath[i] = newGroup;
	                    // if top level, add to result, otherwise add to parent
	                    if (i == 0) {
	                        result.push(newGroup);
	                    }
	                    else {
	                        currentRealPath[i - 1].addChild(newGroup);
	                    }
	                }
	                else {
	                    // reuse old group
	                    currentRealPath[i] = previousRealPath[i];
	                }
	            }
	            var noColumnGroups = currentRealPath.length === 0;
	            if (noColumnGroups) {
	                // if we are not grouping, then the result of the above is an empty
	                // path (no groups), and we just add the column to the root list.
	                result.push(currentColumn);
	            }
	            else {
	                var leafGroup = currentRealPath[currentRealPath.length - 1];
	                leafGroup.addChild(currentColumn);
	            }
	            previousRealPath = currentRealPath;
	            previousOriginalPath = currentOriginalPath;
	        });
	        this.setupParentsIntoColumns(result, null);
	        return result;
	    };
	    DisplayedGroupCreator.prototype.setupParentsIntoColumns = function (columnsOrGroups, parent) {
	        var _this = this;
	        columnsOrGroups.forEach(function (columnsOrGroup) {
	            columnsOrGroup.setParent(parent);
	            if (columnsOrGroup instanceof columnGroup_1.ColumnGroup) {
	                var columnGroup = columnsOrGroup;
	                _this.setupParentsIntoColumns(columnGroup.getChildren(), columnGroup);
	            }
	        });
	    };
	    DisplayedGroupCreator.prototype.createFakePath = function (balancedColumnTree) {
	        var result = [];
	        var currentChildren = balancedColumnTree;
	        // this while look does search on the balanced tree, so our result is the right length
	        var index = 0;
	        while (currentChildren && currentChildren[0] && currentChildren[0] instanceof originalColumnGroup_1.OriginalColumnGroup) {
	            // putting in a deterministic fake id, in case the API in the future needs to reference the col
	            result.push(new originalColumnGroup_1.OriginalColumnGroup(null, 'FAKE_PATH_' + index, true));
	            currentChildren = currentChildren[0].getChildren();
	            index++;
	        }
	        return result;
	    };
	    DisplayedGroupCreator.prototype.getOriginalPathForColumn = function (balancedColumnTree, column) {
	        var result = [];
	        var found = false;
	        recursePath(balancedColumnTree, 0);
	        // it's possible we didn't find a path. this happens if the column is generated
	        // by the grid, in that the definition didn't come from the client. in this case,
	        // we create a fake original path.
	        if (found) {
	            return result;
	        }
	        else {
	            return this.createFakePath(balancedColumnTree);
	        }
	        function recursePath(balancedColumnTree, dept) {
	            for (var i = 0; i < balancedColumnTree.length; i++) {
	                if (found) {
	                    // quit the search, so 'result' is kept with the found result
	                    return;
	                }
	                var node = balancedColumnTree[i];
	                if (node instanceof originalColumnGroup_1.OriginalColumnGroup) {
	                    var nextNode = node;
	                    recursePath(nextNode.getChildren(), dept + 1);
	                    result[dept] = node;
	                }
	                else {
	                    if (node === column) {
	                        found = true;
	                    }
	                }
	            }
	        }
	    };
	    __decorate([
	        context_2.Autowired('columnUtils'), 
	        __metadata('design:type', columnUtils_1.ColumnUtils)
	    ], DisplayedGroupCreator.prototype, "columnUtils", void 0);
	    DisplayedGroupCreator = __decorate([
	        context_1.Bean('displayedGroupCreator'), 
	        __metadata('design:paramtypes', [])
	    ], DisplayedGroupCreator);
	    return DisplayedGroupCreator;
	})();
	exports.DisplayedGroupCreator = DisplayedGroupCreator;


/***/ },
/* 22 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
	 * @version v7.0.2
	 * @link http://www.ag-grid.com/
	 * @license MIT
	 */
	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var rowRenderer_1 = __webpack_require__(23);
	var gridPanel_1 = __webpack_require__(24);
	var context_1 = __webpack_require__(6);
	var context_2 = __webpack_require__(6);
	var headerRenderer_1 = __webpack_require__(66);
	var renderedHeaderCell_1 = __webpack_require__(74);
	var gridOptionsWrapper_1 = __webpack_require__(3);
	var AutoWidthCalculator = (function () {
	    function AutoWidthCalculator() {
	    }
	    // this is the trick: we create a dummy container and clone all the cells
	    // into the dummy, then check the dummy's width. then destroy the dummy
	    // as we don't need it any more.
	    // drawback: only the cells visible on the screen are considered
	    AutoWidthCalculator.prototype.getPreferredWidthForColumn = function (column) {
	        var renderedHeaderCell = this.getHeaderCellForColumn(column);
	        // cell isn't visible
	        if (!renderedHeaderCell) {
	            return -1;
	        }
	        var eDummyContainer = document.createElement('span');
	        // position fixed, so it isn't restricted to the boundaries of the parent
	        eDummyContainer.style.position = 'fixed';
	        // we put the dummy into the body container, so it will inherit all the
	        // css styles that the real cells are inheriting
	        var eBodyContainer = this.gridPanel.getBodyContainer();
	        eBodyContainer.appendChild(eDummyContainer);
	        // get all the cells that are currently displayed (this only brings back
	        // rendered cells, rows not rendered due to row visualisation will not be here)
	        this.putRowCellsIntoDummyContainer(column, eDummyContainer);
	        // also put header cell in
	        // we only consider the lowest level cell, not the group cell. in 99% of the time, this
	        // will be enough. if we consider groups, then it gets to complicated for what it's worth,
	        // as the groups can span columns and this class only considers one column at a time.
	        this.cloneItemIntoDummy(renderedHeaderCell.getGui(), eDummyContainer);
	        // at this point, all the clones are lined up vertically with natural widths. the dummy
	        // container will have a width wide enough just to fit the largest.
	        var dummyContainerWidth = eDummyContainer.offsetWidth;
	        // we are finished with the dummy container, so get rid of it
	        eBodyContainer.removeChild(eDummyContainer);
	        // we add padding as I found without it, the gui still put '...' after some of the texts
	        var autoSizePadding = this.gridOptionsWrapper.getAutoSizePadding();
	        if (typeof autoSizePadding !== 'number' || autoSizePadding < 0) {
	            autoSizePadding = 4;
	        }
	        return dummyContainerWidth + autoSizePadding;
	    };
	    AutoWidthCalculator.prototype.getHeaderCellForColumn = function (column) {
	        var renderedHeaderCell = null;
	        // find the rendered header cell
	        this.headerRenderer.forEachHeaderElement(function (headerElement) {
	            if (headerElement instanceof renderedHeaderCell_1.RenderedHeaderCell) {
	                var currentCell = headerElement;
	                if (currentCell.getColumn() === column) {
	                    renderedHeaderCell = currentCell;
	                }
	            }
	        });
	        return renderedHeaderCell;
	    };
	    AutoWidthCalculator.prototype.putRowCellsIntoDummyContainer = function (column, eDummyContainer) {
	        var _this = this;
	        var eOriginalCells = this.rowRenderer.getAllCellsForColumn(column);
	        eOriginalCells.forEach(function (eCell, index) {
	            _this.cloneItemIntoDummy(eCell, eDummyContainer);
	        });
	    };
	    AutoWidthCalculator.prototype.cloneItemIntoDummy = function (eCell, eDummyContainer) {
	        // make a deep clone of the cell
	        var eCellClone = eCell.cloneNode(true);
	        // the original has a fixed width, we remove this to allow the natural width based on content
	        eCellClone.style.width = '';
	        // the original has position = absolute, we need to remove this so it's positioned normally
	        eCellClone.style.position = 'static';
	        eCellClone.style.left = '';
	        // we put the cell into a containing div, as otherwise the cells would just line up
	        // on the same line, standard flow layout, by putting them into divs, they are laid
	        // out one per line
	        var eCloneParent = document.createElement('div');
	        // table-row, so that each cell is on a row. i also tried display='block', but this
	        // didn't work in IE
	        eCloneParent.style.display = 'table-row';
	        // the twig on the branch, the branch on the tree, the tree in the hole,
	        // the hole in the bog, the bog in the clone, the clone in the parent,
	        // the parent in the dummy, and the dummy down in the vall-e-ooo, OOOOOOOOO! Oh row the rattling bog....
	        eCloneParent.appendChild(eCellClone);
	        eDummyContainer.appendChild(eCloneParent);
	    };
	    __decorate([
	        context_2.Autowired('rowRenderer'), 
	        __metadata('design:type', rowRenderer_1.RowRenderer)
	    ], AutoWidthCalculator.prototype, "rowRenderer", void 0);
	    __decorate([
	        context_2.Autowired('headerRenderer'), 
	        __metadata('design:type', headerRenderer_1.HeaderRenderer)
	    ], AutoWidthCalculator.prototype, "headerRenderer", void 0);
	    __decorate([
	        context_2.Autowired('gridPanel'), 
	        __metadata('design:type', gridPanel_1.GridPanel)
	    ], AutoWidthCalculator.prototype, "gridPanel", void 0);
	    __decorate([
	        context_2.Autowired('gridOptionsWrapper'), 
	        __metadata('design:type', gridOptionsWrapper_1.GridOptionsWrapper)
	    ], AutoWidthCalculator.prototype, "gridOptionsWrapper", void 0);
	    AutoWidthCalculator = __decorate([
	        context_1.Bean('autoWidthCalculator'), 
	        __metadata('design:paramtypes', [])
	    ], AutoWidthCalculator);
	    return AutoWidthCalculator;
	})();
	exports.AutoWidthCalculator = AutoWidthCalculator;


/***/ },
/* 23 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
	 * @version v7.0.2
	 * @link http://www.ag-grid.com/
	 * @license MIT
	 */
	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var __param = (this && this.__param) || function (paramIndex, decorator) {
	    return function (target, key) { decorator(target, key, paramIndex); }
	};
	var utils_1 = __webpack_require__(7);
	var gridOptionsWrapper_1 = __webpack_require__(3);
	var gridPanel_1 = __webpack_require__(24);
	var expressionService_1 = __webpack_require__(18);
	var templateService_1 = __webpack_require__(36);
	var valueService_1 = __webpack_require__(29);
	var eventService_1 = __webpack_require__(4);
	var floatingRowModel_1 = __webpack_require__(26);
	var renderedRow_1 = __webpack_require__(37);
	var events_1 = __webpack_require__(10);
	var constants_1 = __webpack_require__(8);
	var context_1 = __webpack_require__(6);
	var gridCore_1 = __webpack_require__(40);
	var columnController_1 = __webpack_require__(13);
	var logger_1 = __webpack_require__(5);
	var focusedCellController_1 = __webpack_require__(35);
	var cellNavigationService_1 = __webpack_require__(65);
	var gridCell_1 = __webpack_require__(33);
	var RowRenderer = (function () {
	    function RowRenderer() {
	        // map of row ids to row objects. keeps track of which elements
	        // are rendered for which rows in the dom.
	        this.renderedRows = {};
	        this.renderedTopFloatingRows = [];
	        this.renderedBottomFloatingRows = [];
	        // we only allow one refresh at a time, otherwise the internal memory structure here
	        // will get messed up. this can happen if the user has a cellRenderer, and inside the
	        // renderer they call an API method that results in another pass of the refresh,
	        // then it will be trying to draw rows in the middle of a refresh.
	        this.refreshInProgress = false;
	        this.destroyFunctions = [];
	    }
	    RowRenderer.prototype.agWire = function (loggerFactory) {
	        this.logger = this.loggerFactory.create('RowRenderer');
	        this.logger = loggerFactory.create('BalancedColumnTreeBuilder');
	    };
	    RowRenderer.prototype.setupDocumentFragments = function () {
	        var usingDocumentFragments = !!document.createDocumentFragment;
	        if (usingDocumentFragments) {
	            this.eBodyContainerDF = document.createDocumentFragment();
	            if (!this.gridOptionsWrapper.isForPrint()) {
	                this.ePinnedLeftColsContainerDF = document.createDocumentFragment();
	                this.ePinnedRightColsContainerDF = document.createDocumentFragment();
	            }
	        }
	    };
	    RowRenderer.prototype.init = function () {
	        var _this = this;
	        this.getContainersFromGridPanel();
	        this.setupDocumentFragments();
	        var columnListener = this.onColumnEvent.bind(this);
	        var modelUpdatedListener = this.onModelUpdated.bind(this);
	        var floatingRowDataChangedListener = this.onFloatingRowDataChanged.bind(this);
	        this.eventService.addEventListener(events_1.Events.EVENT_DISPLAYED_COLUMNS_CHANGED, columnListener);
	        this.eventService.addEventListener(events_1.Events.EVENT_COLUMN_RESIZED, columnListener);
	        this.eventService.addEventListener(events_1.Events.EVENT_MODEL_UPDATED, modelUpdatedListener);
	        this.eventService.addEventListener(events_1.Events.EVENT_FLOATING_ROW_DATA_CHANGED, floatingRowDataChangedListener);
	        this.destroyFunctions.push(function () {
	            _this.eventService.removeEventListener(events_1.Events.EVENT_DISPLAYED_COLUMNS_CHANGED, columnListener);
	            _this.eventService.removeEventListener(events_1.Events.EVENT_COLUMN_RESIZED, columnListener);
	            _this.eventService.removeEventListener(events_1.Events.EVENT_MODEL_UPDATED, modelUpdatedListener);
	            _this.eventService.removeEventListener(events_1.Events.EVENT_FLOATING_ROW_DATA_CHANGED, floatingRowDataChangedListener);
	        });
	        this.refreshView();
	    };
	    RowRenderer.prototype.onColumnEvent = function (event) {
	        this.setMainRowWidths();
	    };
	    RowRenderer.prototype.getContainersFromGridPanel = function () {
	        this.eFullWidthContainer = this.gridPanel.getFullWidthCellContainer();
	        this.eBodyContainer = this.gridPanel.getBodyContainer();
	        this.ePinnedLeftColsContainer = this.gridPanel.getPinnedLeftColsContainer();
	        this.ePinnedRightColsContainer = this.gridPanel.getPinnedRightColsContainer();
	        this.eFloatingTopContainer = this.gridPanel.getFloatingTopContainer();
	        this.eFloatingTopPinnedLeftContainer = this.gridPanel.getPinnedLeftFloatingTop();
	        this.eFloatingTopPinnedRightContainer = this.gridPanel.getPinnedRightFloatingTop();
	        this.eFloatingTopFullWidthContainer = this.gridPanel.getFloatingTopFullWidthCellContainer();
	        this.eFloatingBottomContainer = this.gridPanel.getFloatingBottomContainer();
	        this.eFloatingBottomPinnedLeftContainer = this.gridPanel.getPinnedLeftFloatingBottom();
	        this.eFloatingBottomPinnedRightContainer = this.gridPanel.getPinnedRightFloatingBottom();
	        this.eFloatingBottomFullWithContainer = this.gridPanel.getFloatingBottomFullWidthCellContainer();
	        this.eBodyViewport = this.gridPanel.getBodyViewport();
	        this.eAllBodyContainers = [this.eBodyContainer, this.eFloatingBottomContainer,
	            this.eFloatingTopContainer];
	        this.eAllPinnedLeftContainers = [
	            this.ePinnedLeftColsContainer,
	            this.eFloatingBottomPinnedLeftContainer,
	            this.eFloatingTopPinnedLeftContainer];
	        this.eAllPinnedRightContainers = [
	            this.ePinnedRightColsContainer,
	            this.eFloatingBottomPinnedRightContainer,
	            this.eFloatingTopPinnedRightContainer];
	    };
	    RowRenderer.prototype.setRowModel = function (rowModel) {
	        this.rowModel = rowModel;
	    };
	    RowRenderer.prototype.getAllCellsForColumn = function (column) {
	        var eCells = [];
	        utils_1.Utils.iterateObject(this.renderedRows, callback);
	        utils_1.Utils.iterateObject(this.renderedBottomFloatingRows, callback);
	        utils_1.Utils.iterateObject(this.renderedTopFloatingRows, callback);
	        function callback(key, renderedRow) {
	            var eCell = renderedRow.getCellForCol(column);
	            if (eCell) {
	                eCells.push(eCell);
	            }
	        }
	        return eCells;
	    };
	    RowRenderer.prototype.setMainRowWidths = function () {
	        var mainRowWidth = this.columnController.getBodyContainerWidth() + "px";
	        this.eAllBodyContainers.forEach(function (container) {
	            var unpinnedRows = container.querySelectorAll(".ag-row");
	            for (var i = 0; i < unpinnedRows.length; i++) {
	                unpinnedRows[i].style.width = mainRowWidth;
	            }
	        });
	    };
	    RowRenderer.prototype.refreshAllFloatingRows = function () {
	        this.refreshFloatingRows(this.renderedTopFloatingRows, this.floatingRowModel.getFloatingTopRowData(), this.eFloatingTopPinnedLeftContainer, this.eFloatingTopPinnedRightContainer, this.eFloatingTopContainer, this.eFloatingTopFullWidthContainer);
	        this.refreshFloatingRows(this.renderedBottomFloatingRows, this.floatingRowModel.getFloatingBottomRowData(), this.eFloatingBottomPinnedLeftContainer, this.eFloatingBottomPinnedRightContainer, this.eFloatingBottomContainer, this.eFloatingBottomFullWithContainer);
	    };
	    RowRenderer.prototype.refreshFloatingRows = function (renderedRows, rowNodes, ePinnedLeftContainer, ePinnedRightContainer, eBodyContainer, eFullWidthContainer) {
	        var _this = this;
	        renderedRows.forEach(function (row) {
	            row.destroy();
	        });
	        renderedRows.length = 0;
	        // if no cols, don't draw row - can we get rid of this???
	        var columns = this.columnController.getAllDisplayedColumns();
	        if (utils_1.Utils.missingOrEmpty(columns)) {
	            return;
	        }
	        if (rowNodes) {
	            rowNodes.forEach(function (node) {
	                var renderedRow = new renderedRow_1.RenderedRow(_this.$scope, _this, eBodyContainer, null, eFullWidthContainer, ePinnedLeftContainer, null, ePinnedRightContainer, null, node, false);
	                _this.context.wireBean(renderedRow);
	                renderedRows.push(renderedRow);
	            });
	        }
	    };
	    RowRenderer.prototype.onFloatingRowDataChanged = function () {
	        this.refreshView();
	    };
	    RowRenderer.prototype.onModelUpdated = function (refreshEvent) {
	        this.refreshView(refreshEvent.keepRenderedRows, refreshEvent.animate);
	    };
	    // if the row nodes are not rendered, no index is returned
	    RowRenderer.prototype.getRenderedIndexesForRowNodes = function (rowNodes) {
	        var result = [];
	        if (utils_1.Utils.missing(rowNodes)) {
	            return result;
	        }
	        utils_1.Utils.iterateObject(this.renderedRows, function (key, renderedRow) {
	            var rowNode = renderedRow.getRowNode();
	            if (rowNodes.indexOf(rowNode) >= 0) {
	                result.push(key);
	            }
	        });
	        return result;
	    };
	    RowRenderer.prototype.refreshRows = function (rowNodes) {
	        if (!rowNodes || rowNodes.length == 0) {
	            return;
	        }
	        // we only need to be worried about rendered rows, as this method is
	        // called to whats rendered. if the row isn't rendered, we don't care
	        var indexesToRemove = this.getRenderedIndexesForRowNodes(rowNodes);
	        // remove the rows
	        this.removeVirtualRows(indexesToRemove);
	        // add draw them again
	        this.refreshView(true, false);
	    };
	    RowRenderer.prototype.refreshView = function (keepRenderedRows, animate) {
	        if (keepRenderedRows === void 0) { keepRenderedRows = false; }
	        if (animate === void 0) { animate = false; }
	        this.logger.log('refreshView');
	        this.getLockOnRefresh();
	        var focusedCell = this.focusedCellController.getFocusCellToUseAfterRefresh();
	        if (!this.gridOptionsWrapper.isForPrint()) {
	            var containerHeight = this.rowModel.getRowCombinedHeight();
	            this.eBodyContainer.style.height = containerHeight + "px";
	            this.eFullWidthContainer.style.height = containerHeight + "px";
	            this.ePinnedLeftColsContainer.style.height = containerHeight + "px";
	            this.ePinnedRightColsContainer.style.height = containerHeight + "px";
	        }
	        this.refreshAllVirtualRows(keepRenderedRows, animate);
	        this.refreshAllFloatingRows();
	        this.restoreFocusedCell(focusedCell);
	        this.releaseLockOnRefresh();
	    };
	    RowRenderer.prototype.getLockOnRefresh = function () {
	        if (this.refreshInProgress) {
	            throw 'ag-Grid: cannot get grid to draw rows when it is in the middle of drawing rows. ' +
	                'Your code probably called a grid API method while the grid was in the render stage. To overcome ' +
	                'this, put the API call into a timeout, eg instead of api.refreshView(), ' +
	                'call setTimeout(function(){api.refreshView(),0}). To see what part of your code ' +
	                'that caused the refresh check this stacktrace.';
	        }
	        this.refreshInProgress = true;
	    };
	    RowRenderer.prototype.releaseLockOnRefresh = function () {
	        this.refreshInProgress = false;
	    };
	    // sets the focus to the provided cell, if the cell is provided. this way, the user can call refresh without
	    // worry about the focus been lost. this is important when the user is using keyboard navigation to do edits
	    // and the cellEditor is calling 'refresh' to get other cells to update (as other cells might depend on the
	    // edited cell).
	    RowRenderer.prototype.restoreFocusedCell = function (gridCell) {
	        if (gridCell) {
	            this.focusedCellController.setFocusedCell(gridCell.rowIndex, gridCell.column, gridCell.floating, true);
	        }
	    };
	    RowRenderer.prototype.softRefreshView = function () {
	        var focusedCell = this.focusedCellController.getFocusCellToUseAfterRefresh();
	        this.forEachRenderedCell(function (renderedCell) {
	            if (renderedCell.isVolatile()) {
	                renderedCell.refreshCell();
	            }
	        });
	        this.restoreFocusedCell(focusedCell);
	    };
	    RowRenderer.prototype.stopEditing = function (cancel) {
	        if (cancel === void 0) { cancel = false; }
	        this.forEachRenderedRow(function (key, renderedRow) {
	            renderedRow.stopEditing(cancel);
	        });
	    };
	    RowRenderer.prototype.forEachRenderedCell = function (callback) {
	        utils_1.Utils.iterateObject(this.renderedRows, function (key, renderedRow) {
	            renderedRow.forEachRenderedCell(callback);
	        });
	    };
	    RowRenderer.prototype.forEachRenderedRow = function (callback) {
	        utils_1.Utils.iterateObject(this.renderedRows, callback);
	        utils_1.Utils.iterateObject(this.renderedTopFloatingRows, callback);
	        utils_1.Utils.iterateObject(this.renderedBottomFloatingRows, callback);
	    };
	    RowRenderer.prototype.addRenderedRowListener = function (eventName, rowIndex, callback) {
	        var renderedRow = this.renderedRows[rowIndex];
	        renderedRow.addEventListener(eventName, callback);
	    };
	    RowRenderer.prototype.refreshCells = function (rowNodes, colIds, animate) {
	        if (animate === void 0) { animate = false; }
	        if (!rowNodes || rowNodes.length == 0) {
	            return;
	        }
	        // we only need to be worried about rendered rows, as this method is
	        // called to whats rendered. if the row isn't rendered, we don't care
	        utils_1.Utils.iterateObject(this.renderedRows, function (key, renderedRow) {
	            var rowNode = renderedRow.getRowNode();
	            if (rowNodes.indexOf(rowNode) >= 0) {
	                renderedRow.refreshCells(colIds, animate);
	            }
	        });
	    };
	    RowRenderer.prototype.destroy = function () {
	        this.destroyFunctions.forEach(function (func) { return func(); });
	        var rowsToRemove = Object.keys(this.renderedRows);
	        this.removeVirtualRows(rowsToRemove);
	    };
	    RowRenderer.prototype.refreshAllVirtualRows = function (keepRenderedRows, animate) {
	        var _this = this;
	        var rowsToRemove;
	        var oldRowsByNodeId = {};
	        if (keepRenderedRows) {
	            rowsToRemove = [];
	            utils_1.Utils.iterateObject(this.renderedRows, function (index, renderedRow) {
	                var rowNode = renderedRow.getRowNode();
	                if (utils_1.Utils.exists(rowNode.id)) {
	                    oldRowsByNodeId[rowNode.id] = renderedRow;
	                    delete _this.renderedRows[index];
	                }
	                else {
	                    rowsToRemove.push(index);
	                }
	            });
	        }
	        else {
	            rowsToRemove = Object.keys(this.renderedRows);
	        }
	        this.removeVirtualRows(rowsToRemove);
	        this.drawVirtualRows(oldRowsByNodeId, animate);
	    };
	    // public - removes the group rows and then redraws them again
	    RowRenderer.prototype.refreshGroupRows = function () {
	        var _this = this;
	        // find all the group rows
	        var rowsToRemove = [];
	        Object.keys(this.renderedRows).forEach(function (index) {
	            var renderedRow = _this.renderedRows[index];
	            if (renderedRow.isGroup()) {
	                rowsToRemove.push(index);
	            }
	        });
	        // remove the rows
	        this.removeVirtualRows(rowsToRemove);
	        // and draw them back again
	        this.ensureRowsRendered();
	    };
	    // takes array of row indexes
	    RowRenderer.prototype.removeVirtualRows = function (rowsToRemove) {
	        var _this = this;
	        // if no fromIndex then set to -1, which will refresh everything
	        // var realFromIndex = -1;
	        rowsToRemove.forEach(function (indexToRemove) {
	            var renderedRow = _this.renderedRows[indexToRemove];
	            renderedRow.destroy();
	            delete _this.renderedRows[indexToRemove];
	        });
	    };
	    // gets called when rows don't change, but viewport does, so after:
	    // 1) size of grid changed
	    // 2) grid scrolled to new position
	    // 3) ensure index visible (which is a scroll)
	    RowRenderer.prototype.drawVirtualRowsWithLock = function () {
	        this.getLockOnRefresh();
	        this.drawVirtualRows();
	        this.releaseLockOnRefresh();
	    };
	    RowRenderer.prototype.drawVirtualRows = function (oldRowsByNodeId, animate) {
	        if (animate === void 0) { animate = false; }
	        this.workOutFirstAndLastRowsToRender();
	        this.ensureRowsRendered(oldRowsByNodeId, animate);
	    };
	    RowRenderer.prototype.workOutFirstAndLastRowsToRender = function () {
	        var newFirst;
	        var newLast;
	        if (!this.rowModel.isRowsToRender()) {
	            newFirst = 0;
	            newLast = -1; // setting to -1 means nothing in range
	        }
	        else {
	            var rowCount = this.rowModel.getRowCount();
	            if (this.gridOptionsWrapper.isForPrint()) {
	                newFirst = 0;
	                newLast = rowCount;
	            }
	            else {
	                var topPixel = this.gridPanel.getBodyTopPixel();
	                var bottomPixel = this.gridPanel.getBodyBottomPixel();
	                var first = this.rowModel.getRowIndexAtPixel(topPixel);
	                var last = this.rowModel.getRowIndexAtPixel(bottomPixel);
	                //add in buffer
	                var buffer = this.gridOptionsWrapper.getRowBuffer();
	                first = first - buffer;
	                last = last + buffer;
	                // adjust, in case buffer extended actual size
	                if (first < 0) {
	                    first = 0;
	                }
	                if (last > rowCount - 1) {
	                    last = rowCount - 1;
	                }
	                newFirst = first;
	                newLast = last;
	            }
	        }
	        var firstDiffers = newFirst !== this.firstRenderedRow;
	        var lastDiffers = newLast !== this.lastRenderedRow;
	        if (firstDiffers || lastDiffers) {
	            this.firstRenderedRow = newFirst;
	            this.lastRenderedRow = newLast;
	            var event = { firstRow: newFirst, lastRow: newLast };
	            this.eventService.dispatchEvent(events_1.Events.EVENT_VIEWPORT_CHANGED, event);
	        }
	    };
	    RowRenderer.prototype.getFirstVirtualRenderedRow = function () {
	        return this.firstRenderedRow;
	    };
	    RowRenderer.prototype.getLastVirtualRenderedRow = function () {
	        return this.lastRenderedRow;
	    };
	    RowRenderer.prototype.ensureRowsRendered = function (oldRenderedRowsByNodeId, animate) {
	        // var timer = new Timer();
	        var _this = this;
	        if (animate === void 0) { animate = false; }
	        // at the end, this array will contain the items we need to remove
	        var rowsToRemove = Object.keys(this.renderedRows);
	        // add in new rows
	        var delayedCreateFunctions = [];
	        for (var rowIndex = this.firstRenderedRow; rowIndex <= this.lastRenderedRow; rowIndex++) {
	            // see if item already there, and if yes, take it out of the 'to remove' array
	            if (rowsToRemove.indexOf(rowIndex.toString()) >= 0) {
	                rowsToRemove.splice(rowsToRemove.indexOf(rowIndex.toString()), 1);
	                continue;
	            }
	            // check this row actually exists (in case overflow buffer window exceeds real data)
	            var node = this.rowModel.getRow(rowIndex);
	            if (node) {
	                var renderedRow = this.getOrCreateRenderedRow(node, oldRenderedRowsByNodeId, animate);
	                utils_1.Utils.pushAll(delayedCreateFunctions, renderedRow.getAndClearNextVMTurnFunctions());
	                this.renderedRows[rowIndex] = renderedRow;
	            }
	        }
	        setTimeout(function () {
	            delayedCreateFunctions.forEach(function (func) { return func(); });
	        }, 0);
	        // timer.print('creating template');
	        // at this point, everything in our 'rowsToRemove' is an old index that needs to be removed
	        this.removeVirtualRows(rowsToRemove);
	        // and everything in our oldRenderedRowsByNodeId is an old row that is no longer used
	        var delayedDestroyFunctions = [];
	        utils_1.Utils.iterateObject(oldRenderedRowsByNodeId, function (nodeId, renderedRow) {
	            renderedRow.destroy(animate);
	            renderedRow.getAndClearDelayedDestroyFunctions().forEach(function (func) { return delayedDestroyFunctions.push(func); });
	            delete oldRenderedRowsByNodeId[nodeId];
	        });
	        setTimeout(function () {
	            delayedDestroyFunctions.forEach(function (func) { return func(); });
	        }, 400);
	        // timer.print('removing');
	        // we prepend rather than append so that new rows appear under current rows. this way the new
	        // rows are not over the current rows which will get animation as they slid to new position
	        if (this.eBodyContainerDF) {
	            utils_1.Utils.prependDC(this.eBodyContainer, this.eBodyContainerDF);
	            if (!this.gridOptionsWrapper.isForPrint()) {
	                utils_1.Utils.prependDC(this.ePinnedLeftColsContainer, this.ePinnedLeftColsContainerDF);
	                utils_1.Utils.prependDC(this.ePinnedRightColsContainer, this.ePinnedRightColsContainerDF);
	            }
	        }
	        // if we are doing angular compiling, then do digest the scope here
	        if (this.gridOptionsWrapper.isAngularCompileRows()) {
	            // we do it in a timeout, in case we are already in an apply
	            setTimeout(function () { _this.$scope.$apply(); }, 0);
	        }
	        // timer.print('total');
	    };
	    RowRenderer.prototype.getOrCreateRenderedRow = function (rowNode, oldRowsByNodeId, animate) {
	        var renderedRow;
	        if (utils_1.Utils.exists(oldRowsByNodeId) && oldRowsByNodeId[rowNode.id]) {
	            renderedRow = oldRowsByNodeId[rowNode.id];
	            delete oldRowsByNodeId[rowNode.id];
	        }
	        else {
	            renderedRow = new renderedRow_1.RenderedRow(this.$scope, this, this.eBodyContainer, this.eBodyContainerDF, this.eFullWidthContainer, this.ePinnedLeftColsContainer, this.ePinnedLeftColsContainerDF, this.ePinnedRightColsContainer, this.ePinnedRightColsContainerDF, rowNode, animate);
	            this.context.wireBean(renderedRow);
	        }
	        return renderedRow;
	    };
	    RowRenderer.prototype.getRenderedNodes = function () {
	        var renderedRows = this.renderedRows;
	        return Object.keys(renderedRows).map(function (key) {
	            return renderedRows[key].getRowNode();
	        });
	    };
	    // we use index for rows, but column object for columns, as the next column (by index) might not
	    // be visible (header grouping) so it's not reliable, so using the column object instead.
	    RowRenderer.prototype.navigateToNextCell = function (key, rowIndex, column, floating) {
	        var nextCell = new gridCell_1.GridCell(rowIndex, floating, column);
	        // we keep searching for a next cell until we find one. this is how the group rows get skipped
	        while (true) {
	            nextCell = this.cellNavigationService.getNextCellToFocus(key, nextCell);
	            if (utils_1.Utils.missing(nextCell)) {
	                break;
	            }
	            var skipGroupRows = this.gridOptionsWrapper.isGroupUseEntireRow();
	            if (skipGroupRows) {
	                var rowNode = this.rowModel.getRow(nextCell.rowIndex);
	                if (!rowNode.group) {
	                    break;
	                }
	            }
	            else {
	                break;
	            }
	        }
	        // no next cell means we have reached a grid boundary, eg left, right, top or bottom of grid
	        if (!nextCell) {
	            return;
	        }
	        // this scrolls the row into view
	        if (utils_1.Utils.missing(nextCell.floating)) {
	            this.gridPanel.ensureIndexVisible(nextCell.rowIndex);
	        }
	        if (!nextCell.column.isPinned()) {
	            this.gridPanel.ensureColumnVisible(nextCell.column);
	        }
	        // need to nudge the scrolls for the floating items. otherwise when we set focus on a non-visible
	        // floating cell, the scrolls get out of sync
	        this.gridPanel.horizontallyScrollHeaderCenterAndFloatingCenter();
	        this.focusedCellController.setFocusedCell(nextCell.rowIndex, nextCell.column, nextCell.floating, true);
	        if (this.rangeController) {
	            this.rangeController.setRangeToCell(new gridCell_1.GridCell(nextCell.rowIndex, nextCell.floating, nextCell.column));
	        }
	    };
	    RowRenderer.prototype.startEditingCell = function (gridCell, keyPress, charPress) {
	        var cell = this.getComponentForCell(gridCell);
	        cell.startRowOrCellEdit(keyPress, charPress);
	    };
	    RowRenderer.prototype.getComponentForCell = function (gridCell) {
	        var rowComponent;
	        switch (gridCell.floating) {
	            case constants_1.Constants.FLOATING_TOP:
	                rowComponent = this.renderedTopFloatingRows[gridCell.rowIndex];
	                break;
	            case constants_1.Constants.FLOATING_BOTTOM:
	                rowComponent = this.renderedBottomFloatingRows[gridCell.rowIndex];
	                break;
	            default:
	                rowComponent = this.renderedRows[gridCell.rowIndex];
	                break;
	        }
	        if (!rowComponent) {
	            return null;
	        }
	        var cellComponent = rowComponent.getRenderedCellForColumn(gridCell.column);
	        return cellComponent;
	    };
	    RowRenderer.prototype.onTabKeyDown = function (previousRenderedCell, keyboardEvent) {
	        var backwards = keyboardEvent.shiftKey;
	        var success = this.moveToCellAfter(previousRenderedCell, backwards);
	        if (success) {
	            keyboardEvent.preventDefault();
	        }
	    };
	    RowRenderer.prototype.tabToNextCell = function (backwards) {
	        var focusedCell = this.focusedCellController.getFocusedCell();
	        // if no focus, then cannot navigate
	        if (utils_1.Utils.missing(focusedCell)) {
	            return false;
	        }
	        var renderedCell = this.getComponentForCell(focusedCell);
	        // if cell is not rendered, means user has scrolled away from the cell
	        if (utils_1.Utils.missing(renderedCell)) {
	            return false;
	        }
	        var result = this.moveToCellAfter(renderedCell, backwards);
	        return result;
	    };
	    // returns true if moving to next cell was successful
	    RowRenderer.prototype.moveToCellAfter = function (previousRenderedCell, backwards) {
	        var editing = previousRenderedCell.isEditing();
	        var gridCell = previousRenderedCell.getGridCell();
	        // find the next cell to start editing
	        var nextRenderedCell = this.findNextCellToFocusOn(gridCell, backwards, editing);
	        var foundCell = utils_1.Utils.exists(nextRenderedCell);
	        // only prevent default if we found a cell. so if user is on last cell and hits tab, then we default
	        // to the normal tabbing so user can exit the grid.
	        if (foundCell) {
	            if (editing) {
	                if (this.gridOptionsWrapper.isFullRowEdit()) {
	                    this.moveEditToNextRow(previousRenderedCell, nextRenderedCell);
	                }
	                else {
	                    this.moveEditToNextCell(previousRenderedCell, nextRenderedCell);
	                }
	            }
	            else {
	                nextRenderedCell.focusCell(true);
	            }
	            return true;
	        }
	        else {
	            return false;
	        }
	    };
	    RowRenderer.prototype.moveEditToNextCell = function (previousRenderedCell, nextRenderedCell) {
	        previousRenderedCell.stopEditing();
	        nextRenderedCell.startEditingIfEnabled(null, null, true);
	        nextRenderedCell.focusCell(false);
	    };
	    RowRenderer.prototype.moveEditToNextRow = function (previousRenderedCell, nextRenderedCell) {
	        var pGridCell = previousRenderedCell.getGridCell();
	        var nGridCell = nextRenderedCell.getGridCell();
	        var rowsMatch = (pGridCell.rowIndex === nGridCell.rowIndex)
	            && (pGridCell.floating === nGridCell.floating);
	        if (rowsMatch) {
	            // same row, so we don't start / stop editing, we just move the focus along
	            previousRenderedCell.setFocusOutOnEditor();
	            nextRenderedCell.setFocusInOnEditor();
	        }
	        else {
	            var pRow = previousRenderedCell.getRenderedRow();
	            var nRow = nextRenderedCell.getRenderedRow();
	            previousRenderedCell.setFocusOutOnEditor();
	            pRow.stopEditing();
	            nRow.startRowEditing();
	            nextRenderedCell.setFocusInOnEditor();
	        }
	        nextRenderedCell.focusCell();
	    };
	    // called by the cell, when tab is pressed while editing.
	    // @return: RenderedCell when navigation successful, otherwise null
	    RowRenderer.prototype.findNextCellToFocusOn = function (gridCell, backwards, startEditing) {
	        var nextCell = gridCell;
	        while (true) {
	            nextCell = this.cellNavigationService.getNextTabbedCell(nextCell, backwards);
	            // if no 'next cell', means we have got to last cell of grid, so nothing to move to,
	            // so bottom right cell going forwards, or top left going backwards
	            if (!nextCell) {
	                return null;
	            }
	            // this scrolls the row into view
	            var cellIsNotFloating = utils_1.Utils.missing(nextCell.floating);
	            if (cellIsNotFloating) {
	                this.gridPanel.ensureIndexVisible(nextCell.rowIndex);
	            }
	            this.gridPanel.ensureColumnVisible(nextCell.column);
	            // need to nudge the scrolls for the floating items. otherwise when we set focus on a non-visible
	            // floating cell, the scrolls get out of sync
	            this.gridPanel.horizontallyScrollHeaderCenterAndFloatingCenter();
	            // we have to call this after ensureColumnVisible - otherwise it could be a virtual column
	            // or row that is not currently in view, hence the renderedCell would not exist
	            var nextRenderedCell = this.getComponentForCell(nextCell);
	            // if editing, but cell not editable, skip cell
	            if (startEditing && !nextRenderedCell.isCellEditable()) {
	                continue;
	            }
	            if (nextRenderedCell.isSuppressNavigable()) {
	                continue;
	            }
	            // by default, when we click a cell, it gets selected into a range, so to keep keyboard navigation
	            // consistent, we set into range here also.
	            if (this.rangeController) {
	                this.rangeController.setRangeToCell(new gridCell_1.GridCell(nextCell.rowIndex, nextCell.floating, nextCell.column));
	            }
	            // we successfully tabbed onto a grid cell, so return true
	            return nextRenderedCell;
	        }
	    };
	    __decorate([
	        context_1.Autowired('columnController'), 
	        __metadata('design:type', columnController_1.ColumnController)
	    ], RowRenderer.prototype, "columnController", void 0);
	    __decorate([
	        context_1.Autowired('gridOptionsWrapper'), 
	        __metadata('design:type', gridOptionsWrapper_1.GridOptionsWrapper)
	    ], RowRenderer.prototype, "gridOptionsWrapper", void 0);
	    __decorate([
	        context_1.Autowired('gridCore'), 
	        __metadata('design:type', gridCore_1.GridCore)
	    ], RowRenderer.prototype, "gridCore", void 0);
	    __decorate([
	        context_1.Autowired('gridPanel'), 
	        __metadata('design:type', gridPanel_1.GridPanel)
	    ], RowRenderer.prototype, "gridPanel", void 0);
	    __decorate([
	        context_1.Autowired('$compile'), 
	        __metadata('design:type', Object)
	    ], RowRenderer.prototype, "$compile", void 0);
	    __decorate([
	        context_1.Autowired('$scope'), 
	        __metadata('design:type', Object)
	    ], RowRenderer.prototype, "$scope", void 0);
	    __decorate([
	        context_1.Autowired('expressionService'), 
	        __metadata('design:type', expressionService_1.ExpressionService)
	    ], RowRenderer.prototype, "expressionService", void 0);
	    __decorate([
	        context_1.Autowired('templateService'), 
	        __metadata('design:type', templateService_1.TemplateService)
	    ], RowRenderer.prototype, "templateService", void 0);
	    __decorate([
	        context_1.Autowired('valueService'), 
	        __metadata('design:type', valueService_1.ValueService)
	    ], RowRenderer.prototype, "valueService", void 0);
	    __decorate([
	        context_1.Autowired('eventService'), 
	        __metadata('design:type', eventService_1.EventService)
	    ], RowRenderer.prototype, "eventService", void 0);
	    __decorate([
	        context_1.Autowired('floatingRowModel'), 
	        __metadata('design:type', floatingRowModel_1.FloatingRowModel)
	    ], RowRenderer.prototype, "floatingRowModel", void 0);
	    __decorate([
	        context_1.Autowired('context'), 
	        __metadata('design:type', context_1.Context)
	    ], RowRenderer.prototype, "context", void 0);
	    __decorate([
	        context_1.Autowired('loggerFactory'), 
	        __metadata('design:type', logger_1.LoggerFactory)
	    ], RowRenderer.prototype, "loggerFactory", void 0);
	    __decorate([
	        context_1.Autowired('rowModel'), 
	        __metadata('design:type', Object)
	    ], RowRenderer.prototype, "rowModel", void 0);
	    __decorate([
	        context_1.Autowired('focusedCellController'), 
	        __metadata('design:type', focusedCellController_1.FocusedCellController)
	    ], RowRenderer.prototype, "focusedCellController", void 0);
	    __decorate([
	        context_1.Optional('rangeController'), 
	        __metadata('design:type', Object)
	    ], RowRenderer.prototype, "rangeController", void 0);
	    __decorate([
	        context_1.Autowired('cellNavigationService'), 
	        __metadata('design:type', cellNavigationService_1.CellNavigationService)
	    ], RowRenderer.prototype, "cellNavigationService", void 0);
	    __decorate([
	        __param(0, context_1.Qualifier('loggerFactory')), 
	        __metadata('design:type', Function), 
	        __metadata('design:paramtypes', [logger_1.LoggerFactory]), 
	        __metadata('design:returntype', void 0)
	    ], RowRenderer.prototype, "agWire", null);
	    __decorate([
	        context_1.PostConstruct, 
	        __metadata('design:type', Function), 
	        __metadata('design:paramtypes', []), 
	        __metadata('design:returntype', void 0)
	    ], RowRenderer.prototype, "init", null);
	    __decorate([
	        context_1.PreDestroy, 
	        __metadata('design:type', Function), 
	        __metadata('design:paramtypes', []), 
	        __metadata('design:returntype', void 0)
	    ], RowRenderer.prototype, "destroy", null);
	    RowRenderer = __decorate([
	        context_1.Bean('rowRenderer'), 
	        __metadata('design:paramtypes', [])
	    ], RowRenderer);
	    return RowRenderer;
	})();
	exports.RowRenderer = RowRenderer;


/***/ },
/* 24 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
	 * @version v7.0.2
	 * @link http://www.ag-grid.com/
	 * @license MIT
	 */
	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var __param = (this && this.__param) || function (paramIndex, decorator) {
	    return function (target, key) { decorator(target, key, paramIndex); }
	};
	var utils_1 = __webpack_require__(7);
	var masterSlaveService_1 = __webpack_require__(25);
	var gridOptionsWrapper_1 = __webpack_require__(3);
	var columnController_1 = __webpack_require__(13);
	var rowRenderer_1 = __webpack_require__(23);
	var floatingRowModel_1 = __webpack_require__(26);
	var borderLayout_1 = __webpack_require__(30);
	var logger_1 = __webpack_require__(5);
	var context_1 = __webpack_require__(6);
	var eventService_1 = __webpack_require__(4);
	var events_1 = __webpack_require__(10);
	var dragService_1 = __webpack_require__(31);
	var constants_1 = __webpack_require__(8);
	var selectionController_1 = __webpack_require__(28);
	var csvCreator_1 = __webpack_require__(12);
	var mouseEventService_1 = __webpack_require__(32);
	var focusedCellController_1 = __webpack_require__(35);
	// in the html below, it is important that there are no white space between some of the divs, as if there is white space,
	// it won't render correctly in safari, as safari renders white space as a gap
	var gridHtml = '<div>' +
	    // header
	    '<div class="ag-header">' +
	    '<div class="ag-pinned-left-header"></div>' +
	    '<div class="ag-pinned-right-header"></div>' +
	    '<div class="ag-header-viewport">' +
	    '<div class="ag-header-container"></div>' +
	    '</div>' +
	    '<div class="ag-header-overlay"></div>' +
	    '</div>' +
	    // floating top
	    '<div class="ag-floating-top">' +
	    '<div class="ag-pinned-left-floating-top"></div>' +
	    '<div class="ag-pinned-right-floating-top"></div>' +
	    '<div class="ag-floating-top-viewport">' +
	    '<div class="ag-floating-top-container"></div>' +
	    '</div>' +
	    '<div class="ag-floating-top-full-width-container"></div>' +
	    '</div>' +
	    // floating bottom
	    '<div class="ag-floating-bottom">' +
	    '<div class="ag-pinned-left-floating-bottom"></div>' +
	    '<div class="ag-pinned-right-floating-bottom"></div>' +
	    '<div class="ag-floating-bottom-viewport">' +
	    '<div class="ag-floating-bottom-container"></div>' +
	    '</div>' +
	    '<div class="ag-floating-bottom-full-width-container"></div>' +
	    '</div>' +
	    // body
	    '<div class="ag-body">' +
	    '<div class="ag-pinned-left-cols-viewport">' +
	    '<div class="ag-pinned-left-cols-container"></div>' +
	    '</div>' +
	    '<div class="ag-pinned-right-cols-viewport">' +
	    '<div class="ag-pinned-right-cols-container"></div>' +
	    '</div>' +
	    '<div class="ag-body-viewport-wrapper">' +
	    '<div class="ag-body-viewport">' +
	    '<div class="ag-body-container"></div>' +
	    '</div>' +
	    '</div>' +
	    '<div class="ag-full-width-viewport">' +
	    '<div class="ag-full-width-container"></div>' +
	    '</div>' +
	    '</div>' +
	    '</div>';
	var gridForPrintHtml = '<div>' +
	    // header
	    '<div class="ag-header-container"></div>' +
	    // floating
	    '<div class="ag-floating-top-container"></div>' +
	    // body
	    '<div class="ag-body-container"></div>' +
	    // floating bottom
	    '<div class="ag-floating-bottom-container"></div>' +
	    '</div>';
	// wrapping in outer div, and wrapper, is needed to center the loading icon
	// The idea for centering came from here: http://www.vanseodesign.com/css/vertical-centering/
	var mainOverlayTemplate = '<div class="ag-overlay-panel">' +
	    '<div class="ag-overlay-wrapper ag-overlay-[OVERLAY_NAME]-wrapper">[OVERLAY_TEMPLATE]</div>' +
	    '</div>';
	var defaultLoadingOverlayTemplate = '<span class="ag-overlay-loading-center">[LOADING...]</span>';
	var defaultNoRowsOverlayTemplate = '<span class="ag-overlay-no-rows-center">[NO_ROWS_TO_SHOW]</span>';
	var GridPanel = (function () {
	    function GridPanel() {
	        this.requestAnimationFrameExists = typeof requestAnimationFrame === 'function';
	        this.scrollLagCounter = 0;
	        this.scrollLagTicking = false;
	        this.lastLeftPosition = -1;
	        this.lastTopPosition = -1;
	        this.animationThreadCount = 0;
	        this.destroyFunctions = [];
	    }
	    GridPanel.prototype.agWire = function (loggerFactory) {
	        // makes code below more readable if we pull 'forPrint' out
	        this.forPrint = this.gridOptionsWrapper.isForPrint();
	        this.setScrollBarWidth();
	        this.logger = loggerFactory.create('GridPanel');
	        this.findElements();
	    };
	    GridPanel.prototype.getBodyTopPixel = function () {
	        return this.eBodyViewport.scrollTop;
	    };
	    GridPanel.prototype.getBodyBottomPixel = function () {
	        return this.eBodyViewport.scrollTop + this.eBodyViewport.offsetHeight;
	    };
	    GridPanel.prototype.setScrollBarWidth = function () {
	        // the user might be using some non-standard scrollbar, eg a scrollbar that has zero
	        // width and overlays (like the Safari scrollbar, but presented in Chrome). so we
	        // allow the user to provide the scroll width before we work it out.
	        var scrollWidth = this.gridOptionsWrapper.getScrollbarWidth();
	        if (typeof scrollWidth !== 'number' || scrollWidth < 0) {
	            scrollWidth = utils_1.Utils.getScrollbarWidth();
	        }
	        this.scrollWidth = scrollWidth;
	    };
	    GridPanel.prototype.destroy = function () {
	        this.destroyFunctions.forEach(function (func) { return func(); });
	    };
	    GridPanel.prototype.onRowDataChanged = function () {
	        if (this.rowModel.isEmpty() && !this.gridOptionsWrapper.isSuppressNoRowsOverlay()) {
	            this.showNoRowsOverlay();
	        }
	        else {
	            this.hideOverlay();
	        }
	    };
	    GridPanel.prototype.getLayout = function () {
	        return this.layout;
	    };
	    GridPanel.prototype.init = function () {
	        this.addEventListeners();
	        this.addDragListeners();
	        this.useScrollLag = this.isUseScrollLag();
	        this.layout = new borderLayout_1.BorderLayout({
	            overlays: {
	                loading: utils_1.Utils.loadTemplate(this.createLoadingOverlayTemplate()),
	                noRows: utils_1.Utils.loadTemplate(this.createNoRowsOverlayTemplate())
	            },
	            center: this.eRoot,
	            dontFill: this.forPrint,
	            name: 'eGridPanel'
	        });
	        this.layout.addSizeChangeListener(this.sizeHeaderAndBody.bind(this));
	        this.addScrollListener();
	        this.setLeftAndRightBounds();
	        if (this.gridOptionsWrapper.isSuppressHorizontalScroll()) {
	            this.eBodyViewport.style.overflowX = 'hidden';
	        }
	        if (this.gridOptionsWrapper.isRowModelDefault() && !this.gridOptionsWrapper.getRowData()) {
	            this.showLoadingOverlay();
	        }
	        this.setWidthsOfContainers();
	        this.showPinnedColContainersIfNeeded();
	        this.sizeHeaderAndBody();
	        this.disableBrowserDragging();
	        this.addShortcutKeyListeners();
	        this.addMouseEvents();
	        this.addKeyboardEvents();
	        this.addBodyViewportListener();
	        if (this.$scope) {
	            this.addAngularApplyCheck();
	        }
	    };
	    GridPanel.prototype.addAngularApplyCheck = function () {
	        var _this = this;
	        // this makes sure if we queue up requests, we only execute oe
	        var applyTriggered = false;
	        var listener = function () {
	            // only need to do one apply at a time
	            if (applyTriggered) {
	                return;
	            }
	            applyTriggered = true; // mark 'need apply' to true
	            setTimeout(function () {
	                applyTriggered = false;
	                _this.$scope.$apply();
	            }, 0);
	        };
	        // these are the events we need to do an apply after - these are the ones that can end up
	        // with columns added or removed
	        this.eventService.addEventListener(events_1.Events.EVENT_DISPLAYED_COLUMNS_CHANGED, listener);
	        this.eventService.addEventListener(events_1.Events.EVENT_VIRTUAL_COLUMNS_CHANGED, listener);
	        this.destroyFunctions.push(function () {
	            _this.eventService.removeEventListener(events_1.Events.EVENT_DISPLAYED_COLUMNS_CHANGED, listener);
	            _this.eventService.removeEventListener(events_1.Events.EVENT_VIRTUAL_COLUMNS_CHANGED, listener);
	        });
	    };
	    // if we do not do this, then the user can select a pic in the grid (eg an image in a custom cell renderer)
	    // and then that will start the browser native drag n' drop, which messes up with our own drag and drop.
	    GridPanel.prototype.disableBrowserDragging = function () {
	        this.eRoot.addEventListener('dragstart', function (event) {
	            if (event.target instanceof HTMLImageElement) {
	                event.preventDefault();
	                return false;
	            }
	        });
	    };
	    GridPanel.prototype.addEventListeners = function () {
	        var _this = this;
	        var displayedColumnsChangedListener = this.onDisplayedColumnsChanged.bind(this);
	        var columnResizedListener = this.onColumnResized.bind(this);
	        var sizeHeaderAndBodyListener = this.sizeHeaderAndBody.bind(this);
	        var rowDataChangedListener = this.onRowDataChanged.bind(this);
	        this.eventService.addEventListener(events_1.Events.EVENT_DISPLAYED_COLUMNS_CHANGED, displayedColumnsChangedListener);
	        this.eventService.addEventListener(events_1.Events.EVENT_COLUMN_RESIZED, columnResizedListener);
	        this.eventService.addEventListener(events_1.Events.EVENT_FLOATING_ROW_DATA_CHANGED, sizeHeaderAndBodyListener);
	        this.gridOptionsWrapper.addEventListener(gridOptionsWrapper_1.GridOptionsWrapper.PROP_HEADER_HEIGHT, sizeHeaderAndBodyListener);
	        this.eventService.addEventListener(events_1.Events.EVENT_ROW_DATA_CHANGED, rowDataChangedListener);
	        this.eventService.addEventListener(events_1.Events.EVENT_ITEMS_ADDED, rowDataChangedListener);
	        this.eventService.addEventListener(events_1.Events.EVENT_ITEMS_REMOVED, rowDataChangedListener);
	        this.destroyFunctions.push(function () {
	            _this.eventService.removeEventListener(events_1.Events.EVENT_DISPLAYED_COLUMNS_CHANGED, displayedColumnsChangedListener);
	            _this.eventService.removeEventListener(events_1.Events.EVENT_COLUMN_RESIZED, columnResizedListener);
	            _this.eventService.removeEventListener(events_1.Events.EVENT_FLOATING_ROW_DATA_CHANGED, sizeHeaderAndBodyListener);
	            _this.gridOptionsWrapper.removeEventListener(gridOptionsWrapper_1.GridOptionsWrapper.PROP_HEADER_HEIGHT, sizeHeaderAndBodyListener);
	            _this.eventService.removeEventListener(events_1.Events.EVENT_ROW_DATA_CHANGED, rowDataChangedListener);
	            _this.eventService.removeEventListener(events_1.Events.EVENT_ITEMS_ADDED, rowDataChangedListener);
	            _this.eventService.removeEventListener(events_1.Events.EVENT_ITEMS_REMOVED, rowDataChangedListener);
	        });
	    };
	    GridPanel.prototype.addDragListeners = function () {
	        var _this = this;
	        if (this.forPrint // no range select when doing 'for print'
	            || !this.gridOptionsWrapper.isEnableRangeSelection() // no range selection if no property
	            || utils_1.Utils.missing(this.rangeController)) {
	            return;
	        }
	        var containers = [this.ePinnedLeftColsContainer, this.ePinnedRightColsContainer, this.eBodyContainer,
	            this.eFloatingTop, this.eFloatingBottom];
	        containers.forEach(function (container) {
	            var params = {
	                dragStartPixels: 0,
	                eElement: container,
	                onDragStart: _this.rangeController.onDragStart.bind(_this.rangeController),
	                onDragStop: _this.rangeController.onDragStop.bind(_this.rangeController),
	                onDragging: _this.rangeController.onDragging.bind(_this.rangeController)
	            };
	            _this.dragService.addDragSource(params);
	            _this.destroyFunctions.push(function () { return _this.dragService.removeDragSource(params); });
	        });
	    };
	    GridPanel.prototype.addMouseEvents = function () {
	        var _this = this;
	        var eventNames = ['click', 'mousedown', 'dblclick', 'contextmenu'];
	        eventNames.forEach(function (eventName) {
	            var listener = _this.processMouseEvent.bind(_this, eventName);
	            _this.eAllCellContainers.forEach(function (container) {
	                container.addEventListener(eventName, listener);
	                _this.destroyFunctions.push(function () { return container.removeEventListener(eventName, listener); });
	            });
	        });
	    };
	    GridPanel.prototype.addKeyboardEvents = function () {
	        var _this = this;
	        var eventNames = ['keydown', 'keypress'];
	        eventNames.forEach(function (eventName) {
	            var listener = _this.processKeyboardEvent.bind(_this, eventName);
	            _this.eAllCellContainers.forEach(function (container) {
	                container.addEventListener(eventName, listener);
	                _this.destroyFunctions.push(function () { return container.removeEventListener(eventName, listener); });
	            });
	        });
	    };
	    GridPanel.prototype.addBodyViewportListener = function () {
	        var _this = this;
	        // we never add this when doing 'forPrint'
	        if (this.gridOptionsWrapper.isForPrint()) {
	            return;
	        }
	        // we want to listen for clicks directly on the eBodyViewport, so the user has a way of showing
	        // the context menu if no rows are displayed, or user simply clicks outside of a cell
	        var listener = function (mouseEvent) {
	            var target = utils_1.Utils.getTarget(mouseEvent);
	            if (target === _this.eBodyViewport) {
	                // show it
	                _this.onContextMenu(mouseEvent);
	                _this.preventDefaultOnContextMenu(mouseEvent);
	            }
	        };
	        this.eBodyViewport.addEventListener('contextmenu', listener);
	        this.destroyFunctions.push(function () { return _this.eBodyViewport.removeEventListener('contextmenu', listener); });
	    };
	    GridPanel.prototype.getCellForEvent = function (event) {
	        var domDataKey = this.gridOptionsWrapper.getDomDataKey();
	        var sourceElement = utils_1.Utils.getTarget(event);
	        while (sourceElement) {
	            var domData = sourceElement[domDataKey];
	            if (domData && domData.renderedCell) {
	                return domData.renderedCell;
	            }
	            sourceElement = sourceElement.parentElement;
	        }
	        return null;
	    };
	    GridPanel.prototype.getRowForEvent = function (event) {
	        var domDataKey = this.gridOptionsWrapper.getDomDataKey();
	        var sourceElement = utils_1.Utils.getTarget(event);
	        while (sourceElement) {
	            var domData = sourceElement[domDataKey];
	            if (domData && domData.renderedRow) {
	                return domData.renderedRow;
	            }
	            sourceElement = sourceElement.parentElement;
	        }
	        return null;
	    };
	    GridPanel.prototype.processKeyboardEvent = function (eventName, keyboardEvent) {
	        var renderedCell = this.getCellForEvent(keyboardEvent);
	        if (renderedCell) {
	            switch (eventName) {
	                case 'keydown':
	                    renderedCell.onKeyDown(keyboardEvent);
	                    break;
	                case 'keypress':
	                    renderedCell.onKeyPress(keyboardEvent);
	                    break;
	            }
	        }
	    };
	    GridPanel.prototype.processMouseEvent = function (eventName, mouseEvent) {
	        var renderedCell = this.getCellForEvent(mouseEvent);
	        if (renderedCell) {
	            renderedCell.onMouseEvent(eventName, mouseEvent);
	        }
	        var renderedRow = this.getRowForEvent(mouseEvent);
	        if (renderedRow) {
	            renderedRow.onMouseEvent(eventName, mouseEvent);
	        }
	        this.preventDefaultOnContextMenu(mouseEvent);
	    };
	    GridPanel.prototype.onContextMenu = function (mouseEvent) {
	        // to allow us to debug in chrome, we ignore the event if ctrl is pressed,
	        // thus the normal menu is displayed
	        if (mouseEvent.ctrlKey || mouseEvent.metaKey) {
	            return;
	        }
	        if (this.contextMenuFactory && !this.gridOptionsWrapper.isSuppressContextMenu()) {
	            this.contextMenuFactory.showMenu(null, null, null, mouseEvent);
	            mouseEvent.preventDefault();
	        }
	    };
	    GridPanel.prototype.preventDefaultOnContextMenu = function (mouseEvent) {
	        // if we don't do this, then middle click will never result in a 'click' event, as 'mousedown'
	        // will be consumed by the browser to mean 'scroll' (as you can scroll with the middle mouse
	        // button in the browser). so this property allows the user to receive middle button clicks if
	        // they want.
	        if (this.gridOptionsWrapper.isSuppressMiddleClickScrolls() && mouseEvent.which === 2) {
	            mouseEvent.preventDefault();
	        }
	    };
	    GridPanel.prototype.addShortcutKeyListeners = function () {
	        var _this = this;
	        this.eAllCellContainers.forEach(function (container) {
	            container.addEventListener('keydown', function (event) {
	                // if the cell the event came from is editing, then we do not
	                // want to do the default shortcut keys, otherwise the editor
	                // (eg a text field) would not be able to do the normal cut/copy/paste
	                var renderedCell = _this.getCellForEvent(event);
	                if (renderedCell && renderedCell.isEditing()) {
	                    return;
	                }
	                if (event.ctrlKey || event.metaKey) {
	                    switch (event.which) {
	                        case constants_1.Constants.KEY_A: return _this.onCtrlAndA(event);
	                        case constants_1.Constants.KEY_C: return _this.onCtrlAndC(event);
	                        case constants_1.Constants.KEY_V: return _this.onCtrlAndV(event);
	                        case constants_1.Constants.KEY_D: return _this.onCtrlAndD(event);
	                    }
	                }
	            });
	        });
	    };
	    GridPanel.prototype.onCtrlAndA = function (event) {
	        if (this.rangeController && this.rowModel.isRowsToRender()) {
	            var rowEnd;
	            var floatingStart;
	            var floatingEnd;
	            if (this.floatingRowModel.isEmpty(constants_1.Constants.FLOATING_TOP)) {
	                floatingStart = null;
	            }
	            else {
	                floatingStart = constants_1.Constants.FLOATING_TOP;
	            }
	            if (this.floatingRowModel.isEmpty(constants_1.Constants.FLOATING_BOTTOM)) {
	                floatingEnd = null;
	                rowEnd = this.rowModel.getRowCount() - 1;
	            }
	            else {
	                floatingEnd = constants_1.Constants.FLOATING_BOTTOM;
	                rowEnd = this.floatingRowModel.getFloatingBottomRowData().length = 1;
	            }
	            var allDisplayedColumns = this.columnController.getAllDisplayedColumns();
	            if (utils_1.Utils.missingOrEmpty(allDisplayedColumns)) {
	                return;
	            }
	            this.rangeController.setRange({
	                rowStart: 0,
	                floatingStart: floatingStart,
	                rowEnd: rowEnd,
	                floatingEnd: floatingEnd,
	                columnStart: allDisplayedColumns[0],
	                columnEnd: allDisplayedColumns[allDisplayedColumns.length - 1]
	            });
	        }
	        event.preventDefault();
	        return false;
	    };
	    GridPanel.prototype.onCtrlAndC = function (event) {
	        if (!this.clipboardService) {
	            return;
	        }
	        var focusedCell = this.focusedCellController.getFocusedCell();
	        this.clipboardService.copyToClipboard();
	        event.preventDefault();
	        // the copy operation results in loosing focus on the cell,
	        // because of the trickery the copy logic uses with a temporary
	        // widget. so we set it back again.
	        if (focusedCell) {
	            this.focusedCellController.setFocusedCell(focusedCell.rowIndex, focusedCell.column, focusedCell.floating, true);
	        }
	        return false;
	    };
	    GridPanel.prototype.onCtrlAndV = function (event) {
	        if (!this.rangeController) {
	            return;
	        }
	        this.clipboardService.pasteFromClipboard();
	        return false;
	    };
	    GridPanel.prototype.onCtrlAndD = function (event) {
	        if (!this.clipboardService) {
	            return;
	        }
	        this.clipboardService.copyRangeDown();
	        event.preventDefault();
	        return false;
	    };
	    GridPanel.prototype.getPinnedLeftFloatingTop = function () {
	        return this.ePinnedLeftFloatingTop;
	    };
	    GridPanel.prototype.getPinnedRightFloatingTop = function () {
	        return this.ePinnedRightFloatingTop;
	    };
	    GridPanel.prototype.getFloatingTopContainer = function () {
	        return this.eFloatingTopContainer;
	    };
	    GridPanel.prototype.getPinnedLeftFloatingBottom = function () {
	        return this.ePinnedLeftFloatingBottom;
	    };
	    GridPanel.prototype.getPinnedRightFloatingBottom = function () {
	        return this.ePinnedRightFloatingBottom;
	    };
	    GridPanel.prototype.getFloatingBottomContainer = function () {
	        return this.eFloatingBottomContainer;
	    };
	    GridPanel.prototype.createOverlayTemplate = function (name, defaultTemplate, userProvidedTemplate) {
	        var template = mainOverlayTemplate
	            .replace('[OVERLAY_NAME]', name);
	        if (userProvidedTemplate) {
	            template = template.replace('[OVERLAY_TEMPLATE]', userProvidedTemplate);
	        }
	        else {
	            template = template.replace('[OVERLAY_TEMPLATE]', defaultTemplate);
	        }
	        return template;
	    };
	    GridPanel.prototype.createLoadingOverlayTemplate = function () {
	        var userProvidedTemplate = this.gridOptionsWrapper.getOverlayLoadingTemplate();
	        var templateNotLocalised = this.createOverlayTemplate('loading', defaultLoadingOverlayTemplate, userProvidedTemplate);
	        var localeTextFunc = this.gridOptionsWrapper.getLocaleTextFunc();
	        var templateLocalised = templateNotLocalised.replace('[LOADING...]', localeTextFunc('loadingOoo', 'Loading...'));
	        return templateLocalised;
	    };
	    GridPanel.prototype.createNoRowsOverlayTemplate = function () {
	        var userProvidedTemplate = this.gridOptionsWrapper.getOverlayNoRowsTemplate();
	        var templateNotLocalised = this.createOverlayTemplate('no-rows', defaultNoRowsOverlayTemplate, userProvidedTemplate);
	        var localeTextFunc = this.gridOptionsWrapper.getLocaleTextFunc();
	        var templateLocalised = templateNotLocalised.replace('[NO_ROWS_TO_SHOW]', localeTextFunc('noRowsToShow', 'No Rows To Show'));
	        return templateLocalised;
	    };
	    GridPanel.prototype.ensureIndexVisible = function (index) {
	        this.logger.log('ensureIndexVisible: ' + index);
	        var lastRow = this.rowModel.getRowCount();
	        if (typeof index !== 'number' || index < 0 || index >= lastRow) {
	            console.warn('invalid row index for ensureIndexVisible: ' + index);
	            return;
	        }
	        var nodeAtIndex = this.rowModel.getRow(index);
	        var rowTopPixel = nodeAtIndex.rowTop;
	        var rowBottomPixel = rowTopPixel + nodeAtIndex.rowHeight;
	        var viewportTopPixel = this.eBodyViewport.scrollTop;
	        var viewportHeight = this.eBodyViewport.offsetHeight;
	        var scrollShowing = this.isHorizontalScrollShowing();
	        if (scrollShowing) {
	            viewportHeight -= this.scrollWidth;
	        }
	        var viewportBottomPixel = viewportTopPixel + viewportHeight;
	        var viewportScrolledPastRow = viewportTopPixel > rowTopPixel;
	        var viewportScrolledBeforeRow = viewportBottomPixel < rowBottomPixel;
	        var eViewportToScroll = this.columnController.isPinningRight() ? this.ePinnedRightColsViewport : this.eBodyViewport;
	        if (viewportScrolledPastRow) {
	            // if row is before, scroll up with row at top
	            eViewportToScroll.scrollTop = rowTopPixel;
	            this.rowRenderer.drawVirtualRowsWithLock();
	        }
	        else if (viewportScrolledBeforeRow) {
	            // if row is below, scroll down with row at bottom
	            var newScrollPosition = rowBottomPixel - viewportHeight;
	            eViewportToScroll.scrollTop = newScrollPosition;
	            this.rowRenderer.drawVirtualRowsWithLock();
	        }
	        // otherwise, row is already in view, so do nothing
	    };
	    // + moveColumnController
	    GridPanel.prototype.getCenterWidth = function () {
	        return this.eBodyViewport.clientWidth;
	    };
	    GridPanel.prototype.isHorizontalScrollShowing = function () {
	        var result = this.eBodyViewport.clientWidth < this.eBodyViewport.scrollWidth;
	        return result;
	    };
	    GridPanel.prototype.isVerticalScrollShowing = function () {
	        if (this.columnController.isPinningRight()) {
	            return utils_1.Utils.isScrollShowing(this.ePinnedRightColsViewport);
	        }
	        else {
	            return utils_1.Utils.isScrollShowing(this.eBodyViewport);
	        }
	    };
	    GridPanel.prototype.isBodyVerticalScrollShowing = function () {
	        if (this.columnController.isPinningRight()) {
	            return false;
	        }
	        else {
	            return utils_1.Utils.isScrollShowing(this.eBodyViewport);
	        }
	    };
	    // gets called every 500 ms. we use this to set padding on right pinned column
	    GridPanel.prototype.periodicallyCheck = function () {
	        if (this.forPrint) {
	            return;
	        }
	        this.setBottomPaddingOnPinnedRight();
	        this.setMarginOnFullWidthCellContainer();
	    };
	    // the pinned container needs extra space at the bottom, some blank space, otherwise when
	    // vertically scrolled all the way down, the last row will be hidden behind the scrolls.
	    // this extra padding allows the last row to be lifted above the bottom scrollbar.
	    GridPanel.prototype.setBottomPaddingOnPinnedRight = function () {
	        if (this.forPrint) {
	            return;
	        }
	        if (this.columnController.isPinningRight()) {
	            var bodyHorizontalScrollShowing = this.eBodyViewport.clientWidth < this.eBodyViewport.scrollWidth;
	            if (bodyHorizontalScrollShowing) {
	                this.ePinnedRightColsContainer.style.marginBottom = this.scrollWidth + 'px';
	            }
	            else {
	                this.ePinnedRightColsContainer.style.marginBottom = '';
	            }
	        }
	    };
	    GridPanel.prototype.setMarginOnFullWidthCellContainer = function () {
	        if (this.forPrint) {
	            return;
	        }
	        // if either right or bottom scrollbars are showing, we need to make sure the
	        // fullWidthCell panel isn't covering the scrollbars. originally i tried to do this using
	        // margin, but the overflow was not getting clipped and going into the margin,
	        // so used border instead. dunno why it works, trial and error found the solution.
	        if (this.isVerticalScrollShowing()) {
	            this.eFullWidthCellViewport.style.borderRight = this.scrollWidth + 'px solid transparent';
	        }
	        else {
	            this.eFullWidthCellViewport.style.borderRight = '';
	        }
	        if (this.isHorizontalScrollShowing()) {
	            this.eFullWidthCellViewport.style.borderBottom = this.scrollWidth + 'px solid transparent';
	        }
	        else {
	            this.eFullWidthCellViewport.style.borderBottom = '';
	        }
	    };
	    GridPanel.prototype.ensureColumnVisible = function (key) {
	        var column = this.columnController.getGridColumn(key);
	        if (!column) {
	            return;
	        }
	        if (column.isPinned()) {
	            console.warn('calling ensureIndexVisible on a ' + column.getPinned() + ' pinned column doesn\'t make sense for column ' + column.getColId());
	            return;
	        }
	        if (!this.columnController.isColumnDisplayed(column)) {
	            console.warn('column is not currently visible');
	            return;
	        }
	        var colLeftPixel = column.getLeft();
	        var colRightPixel = colLeftPixel + column.getActualWidth();
	        var viewportLeftPixel = this.eBodyViewport.scrollLeft;
	        var viewportWidth = this.eBodyViewport.offsetWidth;
	        var scrollShowing = this.eBodyViewport.clientHeight < this.eBodyViewport.scrollHeight;
	        if (scrollShowing) {
	            viewportWidth -= this.scrollWidth;
	        }
	        var viewportRightPixel = viewportLeftPixel + viewportWidth;
	        var viewportScrolledPastCol = viewportLeftPixel > colLeftPixel;
	        var viewportScrolledBeforeCol = viewportRightPixel < colRightPixel;
	        if (viewportScrolledPastCol) {
	            // if viewport's left side is after col's left side, scroll right to pull col into viewport at left
	            this.eBodyViewport.scrollLeft = colLeftPixel;
	        }
	        else if (viewportScrolledBeforeCol) {
	            // if viewport's right side is before col's right side, scroll left to pull col into viewport at right
	            var newScrollPosition = colRightPixel - viewportWidth;
	            this.eBodyViewport.scrollLeft = newScrollPosition;
	        }
	        else {
	        }
	        // this will happen anyway, as the move will cause a 'scroll' event on the body, however
	        // it is possible that the ensureColumnVisible method is called from within ag-Grid and
	        // the caller will need to have the columns rendered to continue, which will be before
	        // the event has been worked on (which is the case for cell navigation).
	        this.setLeftAndRightBounds();
	    };
	    GridPanel.prototype.showLoadingOverlay = function () {
	        if (!this.gridOptionsWrapper.isSuppressLoadingOverlay()) {
	            this.layout.showOverlay('loading');
	        }
	    };
	    GridPanel.prototype.showNoRowsOverlay = function () {
	        if (!this.gridOptionsWrapper.isSuppressNoRowsOverlay()) {
	            this.layout.showOverlay('noRows');
	        }
	    };
	    GridPanel.prototype.hideOverlay = function () {
	        this.layout.hideOverlay();
	    };
	    GridPanel.prototype.getWidthForSizeColsToFit = function () {
	        var availableWidth = this.eBody.clientWidth;
	        // if pinning right, then the scroll bar can show, however for some reason
	        // it overlays the grid and doesn't take space. so we are only interested
	        // in the body scroll showing.
	        var removeScrollWidth = this.isBodyVerticalScrollShowing();
	        if (removeScrollWidth) {
	            availableWidth -= this.scrollWidth;
	        }
	        return availableWidth;
	    };
	    // method will call itself if no available width. this covers if the grid
	    // isn't visible, but is just about to be visible.
	    GridPanel.prototype.sizeColumnsToFit = function (nextTimeout) {
	        var _this = this;
	        var availableWidth = this.getWidthForSizeColsToFit();
	        if (availableWidth > 0) {
	            this.columnController.sizeColumnsToFit(availableWidth);
	        }
	        else {
	            if (nextTimeout === undefined) {
	                setTimeout(function () {
	                    _this.sizeColumnsToFit(100);
	                }, 0);
	            }
	            else if (nextTimeout === 100) {
	                setTimeout(function () {
	                    _this.sizeColumnsToFit(-1);
	                }, 100);
	            }
	            else {
	                console.log('ag-Grid: tried to call sizeColumnsToFit() but the grid is coming back with ' +
	                    'zero width, maybe the grid is not visible yet on the screen?');
	            }
	        }
	    };
	    GridPanel.prototype.getBodyContainer = function () {
	        return this.eBodyContainer;
	    };
	    GridPanel.prototype.getFullWidthCellContainer = function () {
	        return this.eFullWidthCellContainer;
	    };
	    GridPanel.prototype.getFloatingTopFullWidthCellContainer = function () {
	        return this.eFloatingTopFullWidthCellContainer;
	    };
	    GridPanel.prototype.getFloatingBottomFullWidthCellContainer = function () {
	        return this.eFloatingBottomFullWidthCellContainer;
	    };
	    GridPanel.prototype.getDropTargetBodyContainers = function () {
	        if (this.forPrint) {
	            return [this.eBodyContainer, this.eFloatingTopContainer, this.eFloatingBottomContainer];
	        }
	        else {
	            return [this.eBodyViewport, this.eFloatingTopViewport, this.eFloatingBottomViewport];
	        }
	    };
	    GridPanel.prototype.getBodyViewport = function () {
	        return this.eBodyViewport;
	    };
	    GridPanel.prototype.getPinnedLeftColsContainer = function () {
	        return this.ePinnedLeftColsContainer;
	    };
	    GridPanel.prototype.getDropTargetLeftContainers = function () {
	        if (this.forPrint) {
	            return [];
	        }
	        else {
	            return [this.ePinnedLeftColsViewport, this.ePinnedLeftFloatingBottom, this.ePinnedLeftFloatingTop];
	        }
	    };
	    GridPanel.prototype.getPinnedRightColsContainer = function () {
	        return this.ePinnedRightColsContainer;
	    };
	    GridPanel.prototype.getDropTargetPinnedRightContainers = function () {
	        if (this.forPrint) {
	            return [];
	        }
	        else {
	            return [this.ePinnedRightColsViewport, this.ePinnedRightFloatingBottom, this.ePinnedRightFloatingTop];
	        }
	    };
	    GridPanel.prototype.getHeaderContainer = function () {
	        return this.eHeaderContainer;
	    };
	    GridPanel.prototype.getHeaderOverlay = function () {
	        return this.eHeaderOverlay;
	    };
	    GridPanel.prototype.getRoot = function () {
	        return this.eRoot;
	    };
	    GridPanel.prototype.getPinnedLeftHeader = function () {
	        return this.ePinnedLeftHeader;
	    };
	    GridPanel.prototype.getPinnedRightHeader = function () {
	        return this.ePinnedRightHeader;
	    };
	    GridPanel.prototype.queryHtmlElement = function (selector) {
	        return this.eRoot.querySelector(selector);
	    };
	    GridPanel.prototype.findElements = function () {
	        if (this.forPrint) {
	            this.eRoot = utils_1.Utils.loadTemplate(gridForPrintHtml);
	            utils_1.Utils.addCssClass(this.eRoot, 'ag-root');
	            utils_1.Utils.addCssClass(this.eRoot, 'ag-font-style');
	            utils_1.Utils.addCssClass(this.eRoot, 'ag-no-scrolls');
	        }
	        else {
	            this.eRoot = utils_1.Utils.loadTemplate(gridHtml);
	            utils_1.Utils.addCssClass(this.eRoot, 'ag-root');
	            utils_1.Utils.addCssClass(this.eRoot, 'ag-font-style');
	            utils_1.Utils.addCssClass(this.eRoot, 'ag-scrolls');
	        }
	        if (this.forPrint) {
	            this.eHeaderContainer = this.queryHtmlElement('.ag-header-container');
	            this.eBodyContainer = this.queryHtmlElement('.ag-body-container');
	            this.eFloatingTopContainer = this.queryHtmlElement('.ag-floating-top-container');
	            this.eFloatingBottomContainer = this.queryHtmlElement('.ag-floating-bottom-container');
	            this.eAllCellContainers = [this.eBodyContainer, this.eFloatingTopContainer, this.eFloatingBottomContainer];
	            // when doing forPrint, we don't have any fullWidth containers, instead we add directly to the main
	            // containers. this works in forPrint only as there are no pinned columns (no need for fullWidth to
	            // span pinned columns) and the rows are already the full width of the grid (the reason for fullWidth)
	            this.eFullWidthCellContainer = this.eBodyContainer;
	            this.eFloatingBottomFullWidthCellContainer = this.eFloatingBottomContainer;
	            this.eFloatingTopFullWidthCellContainer = this.eFloatingTopContainer;
	        }
	        else {
	            this.eBody = this.queryHtmlElement('.ag-body');
	            this.eBodyContainer = this.queryHtmlElement('.ag-body-container');
	            this.eBodyViewport = this.queryHtmlElement('.ag-body-viewport');
	            this.eBodyViewportWrapper = this.queryHtmlElement('.ag-body-viewport-wrapper');
	            this.eFullWidthCellContainer = this.queryHtmlElement('.ag-full-width-container');
	            this.eFullWidthCellViewport = this.queryHtmlElement('.ag-full-width-viewport');
	            this.ePinnedLeftColsContainer = this.queryHtmlElement('.ag-pinned-left-cols-container');
	            this.ePinnedRightColsContainer = this.queryHtmlElement('.ag-pinned-right-cols-container');
	            this.ePinnedLeftColsViewport = this.queryHtmlElement('.ag-pinned-left-cols-viewport');
	            this.ePinnedRightColsViewport = this.queryHtmlElement('.ag-pinned-right-cols-viewport');
	            this.ePinnedLeftHeader = this.queryHtmlElement('.ag-pinned-left-header');
	            this.ePinnedRightHeader = this.queryHtmlElement('.ag-pinned-right-header');
	            this.eHeader = this.queryHtmlElement('.ag-header');
	            this.eHeaderContainer = this.queryHtmlElement('.ag-header-container');
	            this.eHeaderOverlay = this.queryHtmlElement('.ag-header-overlay');
	            this.eHeaderViewport = this.queryHtmlElement('.ag-header-viewport');
	            this.eFloatingTop = this.queryHtmlElement('.ag-floating-top');
	            this.ePinnedLeftFloatingTop = this.queryHtmlElement('.ag-pinned-left-floating-top');
	            this.ePinnedRightFloatingTop = this.queryHtmlElement('.ag-pinned-right-floating-top');
	            this.eFloatingTopContainer = this.queryHtmlElement('.ag-floating-top-container');
	            this.eFloatingTopViewport = this.queryHtmlElement('.ag-floating-top-viewport');
	            this.eFloatingTopFullWidthCellContainer = this.queryHtmlElement('.ag-floating-top-full-width-container');
	            this.eFloatingBottom = this.queryHtmlElement('.ag-floating-bottom');
	            this.ePinnedLeftFloatingBottom = this.queryHtmlElement('.ag-pinned-left-floating-bottom');
	            this.ePinnedRightFloatingBottom = this.queryHtmlElement('.ag-pinned-right-floating-bottom');
	            this.eFloatingBottomContainer = this.queryHtmlElement('.ag-floating-bottom-container');
	            this.eFloatingBottomViewport = this.queryHtmlElement('.ag-floating-bottom-viewport');
	            this.eFloatingBottomFullWidthCellContainer = this.queryHtmlElement('.ag-floating-bottom-full-width-container');
	            this.eAllCellContainers = [
	                this.ePinnedLeftColsContainer, this.ePinnedRightColsContainer, this.eBodyContainer,
	                this.eFloatingTop, this.eFloatingBottom, this.eFullWidthCellContainer];
	            this.addMouseWheelEventListeners();
	        }
	    };
	    GridPanel.prototype.addMouseWheelEventListeners = function () {
	        var _this = this;
	        var genericListener = this.genericMouseWheelListener.bind(this);
	        var centerListener = this.centerMouseWheelListener.bind(this);
	        // IE9, Chrome, Safari, Opera
	        this.ePinnedLeftColsViewport.addEventListener('mousewheel', genericListener);
	        this.eBodyViewport.addEventListener('mousewheel', centerListener);
	        // Firefox
	        this.ePinnedLeftColsViewport.addEventListener('DOMMouseScroll', genericListener);
	        this.eBodyViewport.addEventListener('DOMMouseScroll', centerListener);
	        this.destroyFunctions.push(function () {
	            _this.ePinnedLeftColsViewport.removeEventListener('mousewheel', genericListener);
	            _this.eBodyViewport.removeEventListener('mousewheel', centerListener);
	            _this.ePinnedLeftColsViewport.removeEventListener('DOMMouseScroll', genericListener);
	            _this.eBodyViewport.removeEventListener('DOMMouseScroll', centerListener);
	        });
	    };
	    GridPanel.prototype.getHeaderViewport = function () {
	        return this.eHeaderViewport;
	    };
	    GridPanel.prototype.centerMouseWheelListener = function (event) {
	        // we are only interested in mimicking the mouse wheel if we are pinning on the right,
	        // as if we are not pinning on the right, then we have scrollbars in the center body, and
	        // as such we just use the default browser wheel behaviour.
	        if (this.columnController.isPinningRight()) {
	            return this.generalMouseWheelListener(event, this.ePinnedRightColsViewport);
	        }
	    };
	    // used for listening to mouse wheel events on 1) left pinned and also the 2) fullWidthCell components.
	    // the fullWidthCell listener is added in renderedRow, hence public.
	    GridPanel.prototype.genericMouseWheelListener = function (event) {
	        var targetPanel;
	        if (this.columnController.isPinningRight()) {
	            targetPanel = this.ePinnedRightColsViewport;
	        }
	        else {
	            targetPanel = this.eBodyViewport;
	        }
	        return this.generalMouseWheelListener(event, targetPanel);
	    };
	    GridPanel.prototype.generalMouseWheelListener = function (event, targetPanel) {
	        var wheelEvent = utils_1.Utils.normalizeWheel(event);
	        // we need to detect in which direction scroll is happening to allow trackpads scroll horizontally
	        // horizontal scroll
	        if (Math.abs(wheelEvent.pixelX) > Math.abs(wheelEvent.pixelY)) {
	            var newLeftPosition = this.eBodyViewport.scrollLeft + wheelEvent.pixelX;
	            this.eBodyViewport.scrollLeft = newLeftPosition;
	        }
	        else {
	            var newTopPosition = this.eBodyViewport.scrollTop + wheelEvent.pixelY;
	            targetPanel.scrollTop = newTopPosition;
	        }
	        // allow the option to pass mouse wheel events to the browser
	        // https://github.com/ceolter/ag-grid/issues/800
	        // in the future, this should be tied in with 'forPrint' option, or have an option 'no vertical scrolls'
	        if (!this.gridOptionsWrapper.isSuppressPreventDefaultOnMouseWheel()) {
	            // if we don't prevent default, then the whole browser will scroll also as well as the grid
	            event.preventDefault();
	        }
	        return false;
	    };
	    GridPanel.prototype.onColumnResized = function () {
	        this.setWidthsOfContainers();
	    };
	    GridPanel.prototype.onDisplayedColumnsChanged = function () {
	        this.setWidthsOfContainers();
	        this.showPinnedColContainersIfNeeded();
	        this.sizeHeaderAndBody();
	    };
	    GridPanel.prototype.setWidthsOfContainers = function () {
	        this.logger.log('setWidthsOfContainers()');
	        this.showPinnedColContainersIfNeeded();
	        var mainRowWidth = this.columnController.getBodyContainerWidth() + 'px';
	        this.eBodyContainer.style.width = mainRowWidth;
	        if (this.forPrint) {
	            // pinned col doesn't exist when doing forPrint
	            return;
	        }
	        this.eFloatingBottomContainer.style.width = mainRowWidth;
	        this.eFloatingTopContainer.style.width = mainRowWidth;
	        var pinnedLeftWidth = this.columnController.getPinnedLeftContainerWidth() + 'px';
	        this.ePinnedLeftColsContainer.style.width = pinnedLeftWidth;
	        this.ePinnedLeftFloatingBottom.style.width = pinnedLeftWidth;
	        this.ePinnedLeftFloatingTop.style.width = pinnedLeftWidth;
	        this.eBodyViewportWrapper.style.marginLeft = pinnedLeftWidth;
	        var pinnedRightWidth = this.columnController.getPinnedRightContainerWidth() + 'px';
	        this.ePinnedRightColsContainer.style.width = pinnedRightWidth;
	        this.ePinnedRightFloatingBottom.style.width = pinnedRightWidth;
	        this.ePinnedRightFloatingTop.style.width = pinnedRightWidth;
	        this.eBodyViewportWrapper.style.marginRight = pinnedRightWidth;
	    };
	    GridPanel.prototype.showPinnedColContainersIfNeeded = function () {
	        // no need to do this if not using scrolls
	        if (this.forPrint) {
	            return;
	        }
	        //some browsers had layout issues with the blank divs, so if blank,
	        //we don't display them
	        if (this.columnController.isPinningLeft()) {
	            this.ePinnedLeftHeader.style.display = 'inline-block';
	            this.ePinnedLeftColsViewport.style.display = 'inline';
	        }
	        else {
	            this.ePinnedLeftHeader.style.display = 'none';
	            this.ePinnedLeftColsViewport.style.display = 'none';
	        }
	        if (this.columnController.isPinningRight()) {
	            this.ePinnedRightHeader.style.display = 'inline-block';
	            this.ePinnedRightColsViewport.style.display = 'inline';
	            this.eBodyViewport.style.overflowY = 'hidden';
	        }
	        else {
	            this.ePinnedRightHeader.style.display = 'none';
	            this.ePinnedRightColsViewport.style.display = 'none';
	            this.eBodyViewport.style.overflowY = 'auto';
	        }
	    };
	    GridPanel.prototype.sizeHeaderAndBody = function () {
	        if (this.forPrint) {
	            // if doing 'for print', then the header and footers are laid
	            // out naturally by the browser. it whatever size that's needed to fit.
	            return;
	        }
	        this.setLeftAndRightBounds();
	        var heightOfContainer = this.layout.getCentreHeight();
	        if (!heightOfContainer) {
	            return;
	        }
	        var headerHeight = this.gridOptionsWrapper.getHeaderHeight();
	        var numberOfRowsInHeader = this.columnController.getHeaderRowCount();
	        var totalHeaderHeight = headerHeight * numberOfRowsInHeader;
	        this.eHeader.style['height'] = totalHeaderHeight + 'px';
	        // padding top covers the header and the floating rows on top
	        var floatingTopHeight = this.floatingRowModel.getFloatingTopTotalHeight();
	        var paddingTop = totalHeaderHeight + floatingTopHeight;
	        // bottom is just the bottom floating rows
	        var floatingBottomHeight = this.floatingRowModel.getFloatingBottomTotalHeight();
	        var floatingBottomTop = heightOfContainer - floatingBottomHeight;
	        var heightOfCentreRows = heightOfContainer - totalHeaderHeight - floatingBottomHeight - floatingTopHeight;
	        // this.eBody.style.paddingTop = paddingTop + 'px';
	        // this.eBody.style.paddingBottom = floatingBottomHeight + 'px';
	        this.eBody.style.top = paddingTop + 'px';
	        this.eBody.style.height = heightOfCentreRows + 'px';
	        this.eFloatingTop.style.top = totalHeaderHeight + 'px';
	        this.eFloatingTop.style.height = floatingTopHeight + 'px';
	        this.eFloatingBottom.style.height = floatingBottomHeight + 'px';
	        this.eFloatingBottom.style.top = floatingBottomTop + 'px';
	        this.ePinnedLeftColsViewport.style.height = heightOfCentreRows + 'px';
	        this.ePinnedRightColsViewport.style.height = heightOfCentreRows + 'px';
	    };
	    GridPanel.prototype.setHorizontalScrollPosition = function (hScrollPosition) {
	        this.eBodyViewport.scrollLeft = hScrollPosition;
	    };
	    // tries to scroll by pixels, but returns what the result actually was
	    GridPanel.prototype.scrollHorizontally = function (pixels) {
	        var oldScrollPosition = this.eBodyViewport.scrollLeft;
	        this.setHorizontalScrollPosition(oldScrollPosition + pixels);
	        var newScrollPosition = this.eBodyViewport.scrollLeft;
	        return newScrollPosition - oldScrollPosition;
	    };
	    GridPanel.prototype.getHorizontalScrollPosition = function () {
	        if (this.forPrint) {
	            return 0;
	        }
	        else {
	            return this.eBodyViewport.scrollLeft;
	        }
	    };
	    GridPanel.prototype.turnOnAnimationForABit = function () {
	        var _this = this;
	        if (this.gridOptionsWrapper.isSuppressColumnMoveAnimation()) {
	            return;
	        }
	        this.animationThreadCount++;
	        var animationThreadCountCopy = this.animationThreadCount;
	        utils_1.Utils.addCssClass(this.eRoot, 'ag-column-moving');
	        setTimeout(function () {
	            if (_this.animationThreadCount === animationThreadCountCopy) {
	                utils_1.Utils.removeCssClass(_this.eRoot, 'ag-column-moving');
	            }
	        }, 300);
	    };
	    GridPanel.prototype.addScrollListener = function () {
	        var _this = this;
	        // if printing, then no scrolling, so no point in listening for scroll events
	        if (this.forPrint) {
	            return;
	        }
	        var that = this;
	        function onBodyViewportScroll() {
	            // we are always interested in horizontal scrolls of the body
	            var newLeftPosition = that.eBodyViewport.scrollLeft;
	            if (newLeftPosition !== that.lastLeftPosition) {
	                that.eventService.dispatchEvent(events_1.Events.EVENT_BODY_SCROLL);
	                that.lastLeftPosition = newLeftPosition;
	                that.horizontallyScrollHeaderCenterAndFloatingCenter();
	                that.masterSlaveService.fireHorizontalScrollEvent(newLeftPosition);
	                that.setLeftAndRightBounds();
	            }
	            // if we are pinning to the right, then it's the right pinned container
	            // that has the scroll.
	            if (!that.columnController.isPinningRight()) {
	                var newTopPosition = that.eBodyViewport.scrollTop;
	                if (newTopPosition !== that.lastTopPosition) {
	                    that.eventService.dispatchEvent(events_1.Events.EVENT_BODY_SCROLL);
	                    that.lastTopPosition = newTopPosition;
	                    that.verticallyScrollLeftPinned(newTopPosition);
	                    that.verticallyScrollFullWidthCellContainer(newTopPosition);
	                    that.rowRenderer.drawVirtualRowsWithLock();
	                }
	            }
	        }
	        function onPinnedRightScroll() {
	            var newTopPosition = that.ePinnedRightColsViewport.scrollTop;
	            if (newTopPosition !== that.lastTopPosition) {
	                that.eventService.dispatchEvent(events_1.Events.EVENT_BODY_SCROLL);
	                that.lastTopPosition = newTopPosition;
	                that.verticallyScrollLeftPinned(newTopPosition);
	                that.verticallyScrollFullWidthCellContainer(newTopPosition);
	                that.verticallyScrollBody(newTopPosition);
	                that.rowRenderer.drawVirtualRowsWithLock();
	            }
	        }
	        var bodyViewportScrollListener = this.useScrollLag ? this.debounce.bind(this, onBodyViewportScroll) : onBodyViewportScroll;
	        var pinnedRightScrollListener = this.useScrollLag ? this.debounce.bind(this, onPinnedRightScroll) : onPinnedRightScroll;
	        this.eBodyViewport.addEventListener('scroll', bodyViewportScrollListener);
	        this.ePinnedRightColsViewport.addEventListener('scroll', pinnedRightScrollListener);
	        this.destroyFunctions.push(function () {
	            _this.eBodyViewport.removeEventListener('scroll', bodyViewportScrollListener);
	            _this.ePinnedRightColsViewport.removeEventListener('scroll', pinnedRightScrollListener);
	        });
	        // this means the pinned panel was moved, which can only
	        // happen when the user is navigating in the pinned container
	        // as the pinned col should never scroll. so we rollback
	        // the scroll on the pinned.
	        var pinnedLeftColsViewportScrollListener = function () {
	            _this.ePinnedLeftColsViewport.scrollTop = 0;
	        };
	        this.ePinnedLeftColsViewport.addEventListener('scroll', pinnedLeftColsViewportScrollListener);
	        this.destroyFunctions.push(function () {
	            _this.ePinnedLeftColsViewport.removeEventListener('scroll', pinnedLeftColsViewportScrollListener);
	        });
	        this.addIEPinFix(onPinnedRightScroll);
	    };
	    // this bit is a fix / hack for IE due to this:
	    // https://www.ag-grid.com/forum/showthread.php?tid=4303
	    // it gets the left panel to reposition itself after a model change
	    GridPanel.prototype.addIEPinFix = function (onPinnedRightScroll) {
	        var _this = this;
	        var listener = function () {
	            if (_this.columnController.isPinningRight()) {
	                setTimeout(function () {
	                    onPinnedRightScroll();
	                }, 0);
	            }
	        };
	        this.eventService.addEventListener(events_1.Events.EVENT_MODEL_UPDATED, listener);
	        this.destroyFunctions.push(function () { return _this.eventService.removeEventListener(events_1.Events.EVENT_MODEL_UPDATED, listener); });
	    };
	    GridPanel.prototype.setLeftAndRightBounds = function () {
	        if (this.gridOptionsWrapper.isForPrint()) {
	            return;
	        }
	        var scrollPosition = this.eBodyViewport.scrollLeft;
	        var totalWidth = this.eBody.offsetWidth;
	        this.columnController.setWidthAndScrollPosition(totalWidth, scrollPosition);
	    };
	    GridPanel.prototype.isUseScrollLag = function () {
	        // if we are in IE or Safari, then we only redraw if there was no scroll event
	        // in the 50ms following this scroll event. without this, these browsers have
	        // a bad scrolling feel, where the redraws clog the scroll experience
	        // (makes the scroll clunky and sticky). this method is like throttling
	        // the scroll events.
	        // let the user override scroll lag option
	        if (this.gridOptionsWrapper.isSuppressScrollLag()) {
	            return false;
	        }
	        else if (this.gridOptionsWrapper.getIsScrollLag()) {
	            return this.gridOptionsWrapper.getIsScrollLag()();
	        }
	        else {
	            return utils_1.Utils.isBrowserIE() || utils_1.Utils.isBrowserSafari();
	        }
	    };
	    GridPanel.prototype.debounce = function (callback) {
	        var _this = this;
	        if (this.requestAnimationFrameExists && utils_1.Utils.isBrowserSafari()) {
	            if (!this.scrollLagTicking) {
	                this.scrollLagTicking = true;
	                requestAnimationFrame(function () {
	                    callback();
	                    _this.scrollLagTicking = false;
	                });
	            }
	        }
	        else {
	            this.scrollLagCounter++;
	            var scrollLagCounterCopy = this.scrollLagCounter;
	            setTimeout(function () {
	                if (_this.scrollLagCounter === scrollLagCounterCopy) {
	                    callback();
	                }
	            }, 50);
	        }
	    };
	    GridPanel.prototype.horizontallyScrollHeaderCenterAndFloatingCenter = function () {
	        var bodyLeftPosition = this.eBodyViewport.scrollLeft;
	        this.eHeaderContainer.style.left = -bodyLeftPosition + 'px';
	        this.eFloatingBottomContainer.style.left = -bodyLeftPosition + 'px';
	        this.eFloatingTopContainer.style.left = -bodyLeftPosition + 'px';
	    };
	    GridPanel.prototype.verticallyScrollLeftPinned = function (bodyTopPosition) {
	        this.ePinnedLeftColsContainer.style.top = -bodyTopPosition + 'px';
	    };
	    GridPanel.prototype.verticallyScrollFullWidthCellContainer = function (bodyTopPosition) {
	        this.eFullWidthCellContainer.style.top = -bodyTopPosition + 'px';
	    };
	    GridPanel.prototype.verticallyScrollBody = function (position) {
	        this.eBodyViewport.scrollTop = position;
	    };
	    GridPanel.prototype.getVerticalScrollPosition = function () {
	        if (this.forPrint) {
	            return 0;
	        }
	        else {
	            return this.eBodyViewport.scrollTop;
	        }
	    };
	    GridPanel.prototype.getBodyViewportClientRect = function () {
	        if (this.forPrint) {
	            return this.eBodyContainer.getBoundingClientRect();
	        }
	        else {
	            return this.eBodyViewport.getBoundingClientRect();
	        }
	    };
	    GridPanel.prototype.getFloatingTopClientRect = function () {
	        if (this.forPrint) {
	            return this.eFloatingTopContainer.getBoundingClientRect();
	        }
	        else {
	            return this.eFloatingTop.getBoundingClientRect();
	        }
	    };
	    GridPanel.prototype.getFloatingBottomClientRect = function () {
	        if (this.forPrint) {
	            return this.eFloatingBottomContainer.getBoundingClientRect();
	        }
	        else {
	            return this.eFloatingBottom.getBoundingClientRect();
	        }
	    };
	    GridPanel.prototype.getPinnedLeftColsViewportClientRect = function () {
	        return this.ePinnedLeftColsViewport.getBoundingClientRect();
	    };
	    GridPanel.prototype.getPinnedRightColsViewportClientRect = function () {
	        return this.ePinnedRightColsViewport.getBoundingClientRect();
	    };
	    GridPanel.prototype.addScrollEventListener = function (listener) {
	        this.eBodyViewport.addEventListener('scroll', listener);
	    };
	    GridPanel.prototype.removeScrollEventListener = function (listener) {
	        this.eBodyViewport.removeEventListener('scroll', listener);
	    };
	    __decorate([
	        context_1.Autowired('masterSlaveService'), 
	        __metadata('design:type', masterSlaveService_1.MasterSlaveService)
	    ], GridPanel.prototype, "masterSlaveService", void 0);
	    __decorate([
	        context_1.Autowired('gridOptionsWrapper'), 
	        __metadata('design:type', gridOptionsWrapper_1.GridOptionsWrapper)
	    ], GridPanel.prototype, "gridOptionsWrapper", void 0);
	    __decorate([
	        context_1.Autowired('columnController'), 
	        __metadata('design:type', columnController_1.ColumnController)
	    ], GridPanel.prototype, "columnController", void 0);
	    __decorate([
	        context_1.Autowired('rowRenderer'), 
	        __metadata('design:type', rowRenderer_1.RowRenderer)
	    ], GridPanel.prototype, "rowRenderer", void 0);
	    __decorate([
	        context_1.Autowired('floatingRowModel'), 
	        __metadata('design:type', floatingRowModel_1.FloatingRowModel)
	    ], GridPanel.prototype, "floatingRowModel", void 0);
	    __decorate([
	        context_1.Autowired('eventService'), 
	        __metadata('design:type', eventService_1.EventService)
	    ], GridPanel.prototype, "eventService", void 0);
	    __decorate([
	        context_1.Autowired('rowModel'), 
	        __metadata('design:type', Object)
	    ], GridPanel.prototype, "rowModel", void 0);
	    __decorate([
	        context_1.Optional('rangeController'), 
	        __metadata('design:type', Object)
	    ], GridPanel.prototype, "rangeController", void 0);
	    __decorate([
	        context_1.Autowired('dragService'), 
	        __metadata('design:type', dragService_1.DragService)
	    ], GridPanel.prototype, "dragService", void 0);
	    __decorate([
	        context_1.Autowired('selectionController'), 
	        __metadata('design:type', selectionController_1.SelectionController)
	    ], GridPanel.prototype, "selectionController", void 0);
	    __decorate([
	        context_1.Optional('clipboardService'), 
	        __metadata('design:type', Object)
	    ], GridPanel.prototype, "clipboardService", void 0);
	    __decorate([
	        context_1.Autowired('csvCreator'), 
	        __metadata('design:type', csvCreator_1.CsvCreator)
	    ], GridPanel.prototype, "csvCreator", void 0);
	    __decorate([
	        context_1.Autowired('mouseEventService'), 
	        __metadata('design:type', mouseEventService_1.MouseEventService)
	    ], GridPanel.prototype, "mouseEventService", void 0);
	    __decorate([
	        context_1.Autowired('focusedCellController'), 
	        __metadata('design:type', focusedCellController_1.FocusedCellController)
	    ], GridPanel.prototype, "focusedCellController", void 0);
	    __decorate([
	        context_1.Autowired('$scope'), 
	        __metadata('design:type', Object)
	    ], GridPanel.prototype, "$scope", void 0);
	    __decorate([
	        context_1.Optional('contextMenuFactory'), 
	        __metadata('design:type', Object)
	    ], GridPanel.prototype, "contextMenuFactory", void 0);
	    __decorate([
	        __param(0, context_1.Qualifier('loggerFactory')), 
	        __metadata('design:type', Function), 
	        __metadata('design:paramtypes', [logger_1.LoggerFactory]), 
	        __metadata('design:returntype', void 0)
	    ], GridPanel.prototype, "agWire", null);
	    __decorate([
	        context_1.PreDestroy, 
	        __metadata('design:type', Function), 
	        __metadata('design:paramtypes', []), 
	        __metadata('design:returntype', void 0)
	    ], GridPanel.prototype, "destroy", null);
	    __decorate([
	        context_1.PostConstruct, 
	        __metadata('design:type', Function), 
	        __metadata('design:paramtypes', []), 
	        __metadata('design:returntype', void 0)
	    ], GridPanel.prototype, "init", null);
	    GridPanel = __decorate([
	        context_1.Bean('gridPanel'), 
	        __metadata('design:paramtypes', [])
	    ], GridPanel);
	    return GridPanel;
	})();
	exports.GridPanel = GridPanel;


/***/ },
/* 25 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
	 * @version v7.0.2
	 * @link http://www.ag-grid.com/
	 * @license MIT
	 */
	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var __param = (this && this.__param) || function (paramIndex, decorator) {
	    return function (target, key) { decorator(target, key, paramIndex); }
	};
	var gridOptionsWrapper_1 = __webpack_require__(3);
	var columnController_1 = __webpack_require__(13);
	var gridPanel_1 = __webpack_require__(24);
	var eventService_1 = __webpack_require__(4);
	var logger_1 = __webpack_require__(5);
	var events_1 = __webpack_require__(10);
	var context_1 = __webpack_require__(6);
	var context_2 = __webpack_require__(6);
	var context_3 = __webpack_require__(6);
	var context_4 = __webpack_require__(6);
	var MasterSlaveService = (function () {
	    function MasterSlaveService() {
	        // flag to mark if we are consuming. to avoid cyclic events (ie slave firing back to master
	        // while processing a master event) we mark this if consuming an event, and if we are, then
	        // we don't fire back any events.
	        this.consuming = false;
	    }
	    MasterSlaveService.prototype.setBeans = function (loggerFactory) {
	        this.logger = loggerFactory.create('MasterSlaveService');
	    };
	    MasterSlaveService.prototype.init = function () {
	        this.eventService.addEventListener(events_1.Events.EVENT_COLUMN_MOVED, this.fireColumnEvent.bind(this));
	        this.eventService.addEventListener(events_1.Events.EVENT_COLUMN_VISIBLE, this.fireColumnEvent.bind(this));
	        this.eventService.addEventListener(events_1.Events.EVENT_COLUMN_PINNED, this.fireColumnEvent.bind(this));
	        this.eventService.addEventListener(events_1.Events.EVENT_COLUMN_GROUP_OPENED, this.fireColumnEvent.bind(this));
	        this.eventService.addEventListener(events_1.Events.EVENT_COLUMN_RESIZED, this.fireColumnEvent.bind(this));
	    };
	    // common logic across all the fire methods
	    MasterSlaveService.prototype.fireEvent = function (callback) {
	        // if we are already consuming, then we are acting on an event from a master,
	        // so we don't cause a cyclic firing of events
	        if (this.consuming) {
	            return;
	        }
	        // iterate through the slave grids, and pass each slave service to the callback
	        var slaveGrids = this.gridOptionsWrapper.getSlaveGrids();
	        if (slaveGrids) {
	            slaveGrids.forEach(function (slaveGridOptions) {
	                if (slaveGridOptions.api) {
	                    var slaveService = slaveGridOptions.api.__getMasterSlaveService();
	                    callback(slaveService);
	                }
	            });
	        }
	    };
	    // common logic across all consume methods. very little common logic, however extracting
	    // guarantees consistency across the methods.
	    MasterSlaveService.prototype.onEvent = function (callback) {
	        this.consuming = true;
	        callback();
	        this.consuming = false;
	    };
	    MasterSlaveService.prototype.fireColumnEvent = function (event) {
	        this.fireEvent(function (slaveService) {
	            slaveService.onColumnEvent(event);
	        });
	    };
	    MasterSlaveService.prototype.fireHorizontalScrollEvent = function (horizontalScroll) {
	        this.fireEvent(function (slaveService) {
	            slaveService.onScrollEvent(horizontalScroll);
	        });
	    };
	    MasterSlaveService.prototype.onScrollEvent = function (horizontalScroll) {
	        var _this = this;
	        this.onEvent(function () {
	            _this.gridPanel.setHorizontalScrollPosition(horizontalScroll);
	        });
	    };
	    MasterSlaveService.prototype.getMasterColumns = function (event) {
	        var result = [];
	        if (event.getColumn()) {
	            result.push(event.getColumn());
	        }
	        if (event.getColumns()) {
	            event.getColumns().forEach(function (column) {
	                result.push(column);
	            });
	        }
	        return result;
	    };
	    MasterSlaveService.prototype.getColumnIds = function (event) {
	        var result = [];
	        if (event.getColumn()) {
	            result.push(event.getColumn().getColId());
	        }
	        else if (event.getColumns()) {
	            event.getColumns().forEach(function (column) {
	                result.push(column.getColId());
	            });
	        }
	        return result;
	    };
	    MasterSlaveService.prototype.onColumnEvent = function (event) {
	        var _this = this;
	        this.onEvent(function () {
	            // the column in the event is from the master grid. need to
	            // look up the equivalent from this (slave) grid
	            var masterColumn = event.getColumn();
	            var slaveColumn;
	            if (masterColumn) {
	                slaveColumn = _this.columnController.getPrimaryColumn(masterColumn.getColId());
	            }
	            // if event was with respect to a master column, that is not present in this
	            // grid, then we ignore the event
	            if (masterColumn && !slaveColumn) {
	                return;
	            }
	            // likewise for column group
	            var masterColumnGroup = event.getColumnGroup();
	            var slaveColumnGroup;
	            if (masterColumnGroup) {
	                var colId = masterColumnGroup.getGroupId();
	                var instanceId = masterColumnGroup.getInstanceId();
	                slaveColumnGroup = _this.columnController.getColumnGroup(colId, instanceId);
	            }
	            if (masterColumnGroup && !slaveColumnGroup) {
	                return;
	            }
	            // in time, all the methods below should use the column ids, it's a more generic way
	            // of handling columns, and also allows for single or multi column events
	            var columnIds = _this.getColumnIds(event);
	            var masterColumns = _this.getMasterColumns(event);
	            switch (event.getType()) {
	                case events_1.Events.EVENT_COLUMN_PIVOT_CHANGED:
	                    // we cannot support pivoting with master / slave as the columns will be out of sync as the
	                    // grids will have columns created based on the row data of the grid.
	                    console.warn('ag-Grid: pivoting is not supported with Master / Slave grids. ' +
	                        'You can only use one of these features at a time in a grid.');
	                    break;
	                case events_1.Events.EVENT_COLUMN_MOVED:
	                    _this.logger.log('onColumnEvent-> processing ' + event + ' toIndex = ' + event.getToIndex());
	                    _this.columnController.moveColumns(columnIds, event.getToIndex());
	                    break;
	                case events_1.Events.EVENT_COLUMN_VISIBLE:
	                    _this.logger.log('onColumnEvent-> processing ' + event + ' visible = ' + event.isVisible());
	                    _this.columnController.setColumnsVisible(columnIds, event.isVisible());
	                    break;
	                case events_1.Events.EVENT_COLUMN_PINNED:
	                    _this.logger.log('onColumnEvent-> processing ' + event + ' pinned = ' + event.getPinned());
	                    _this.columnController.setColumnsPinned(columnIds, event.getPinned());
	                    break;
	                case events_1.Events.EVENT_COLUMN_GROUP_OPENED:
	                    _this.logger.log('onColumnEvent-> processing ' + event + ' expanded = ' + masterColumnGroup.isExpanded());
	                    _this.columnController.setColumnGroupOpened(slaveColumnGroup, masterColumnGroup.isExpanded());
	                    break;
	                case events_1.Events.EVENT_COLUMN_RESIZED:
	                    masterColumns.forEach(function (masterColumn) {
	                        _this.logger.log('onColumnEvent-> processing ' + event + ' actualWidth = ' + masterColumn.getActualWidth());
	                        _this.columnController.setColumnWidth(masterColumn.getColId(), masterColumn.getActualWidth(), event.isFinished());
	                    });
	                    break;
	            }
	        });
	    };
	    __decorate([
	        context_3.Autowired('gridOptionsWrapper'), 
	        __metadata('design:type', gridOptionsWrapper_1.GridOptionsWrapper)
	    ], MasterSlaveService.prototype, "gridOptionsWrapper", void 0);
	    __decorate([
	        context_3.Autowired('columnController'), 
	        __metadata('design:type', columnController_1.ColumnController)
	    ], MasterSlaveService.prototype, "columnController", void 0);
	    __decorate([
	        context_3.Autowired('gridPanel'), 
	        __metadata('design:type', gridPanel_1.GridPanel)
	    ], MasterSlaveService.prototype, "gridPanel", void 0);
	    __decorate([
	        context_3.Autowired('eventService'), 
	        __metadata('design:type', eventService_1.EventService)
	    ], MasterSlaveService.prototype, "eventService", void 0);
	    __decorate([
	        __param(0, context_2.Qualifier('loggerFactory')), 
	        __metadata('design:type', Function), 
	        __metadata('design:paramtypes', [logger_1.LoggerFactory]), 
	        __metadata('design:returntype', void 0)
	    ], MasterSlaveService.prototype, "setBeans", null);
	    __decorate([
	        context_4.PostConstruct, 
	        __metadata('design:type', Function), 
	        __metadata('design:paramtypes', []), 
	        __metadata('design:returntype', void 0)
	    ], MasterSlaveService.prototype, "init", null);
	    MasterSlaveService = __decorate([
	        context_1.Bean('masterSlaveService'), 
	        __metadata('design:paramtypes', [])
	    ], MasterSlaveService);
	    return MasterSlaveService;
	})();
	exports.MasterSlaveService = MasterSlaveService;


/***/ },
/* 26 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
	 * @version v7.0.2
	 * @link http://www.ag-grid.com/
	 * @license MIT
	 */
	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var gridOptionsWrapper_1 = __webpack_require__(3);
	var rowNode_1 = __webpack_require__(27);
	var context_1 = __webpack_require__(6);
	var eventService_1 = __webpack_require__(4);
	var context_2 = __webpack_require__(6);
	var events_1 = __webpack_require__(10);
	var context_3 = __webpack_require__(6);
	var constants_1 = __webpack_require__(8);
	var utils_1 = __webpack_require__(7);
	var FloatingRowModel = (function () {
	    function FloatingRowModel() {
	    }
	    FloatingRowModel.prototype.init = function () {
	        this.setFloatingTopRowData(this.gridOptionsWrapper.getFloatingTopRowData());
	        this.setFloatingBottomRowData(this.gridOptionsWrapper.getFloatingBottomRowData());
	    };
	    FloatingRowModel.prototype.isEmpty = function (floating) {
	        var rows = floating === constants_1.Constants.FLOATING_TOP ? this.floatingTopRows : this.floatingBottomRows;
	        return utils_1.Utils.missingOrEmpty(rows);
	    };
	    FloatingRowModel.prototype.isRowsToRender = function (floating) {
	        return !this.isEmpty(floating);
	    };
	    FloatingRowModel.prototype.getRowAtPixel = function (pixel, floating) {
	        var rows = floating === constants_1.Constants.FLOATING_TOP ? this.floatingTopRows : this.floatingBottomRows;
	        if (utils_1.Utils.missingOrEmpty(rows)) {
	            return 0; // this should never happen, just in case, 0 is graceful failure
	        }
	        for (var i = 0; i < rows.length; i++) {
	            var rowNode = rows[i];
	            var rowTopPixel = rowNode.rowTop + rowNode.rowHeight - 1;
	            // only need to range check against the top pixel, as we are going through the list
	            // in order, first row to hit the pixel wins
	            if (rowTopPixel >= pixel) {
	                return i;
	            }
	        }
	        return rows.length - 1;
	    };
	    FloatingRowModel.prototype.setFloatingTopRowData = function (rowData) {
	        this.floatingTopRows = this.createNodesFromData(rowData, true);
	        this.eventService.dispatchEvent(events_1.Events.EVENT_FLOATING_ROW_DATA_CHANGED);
	    };
	    FloatingRowModel.prototype.setFloatingBottomRowData = function (rowData) {
	        this.floatingBottomRows = this.createNodesFromData(rowData, false);
	        this.eventService.dispatchEvent(events_1.Events.EVENT_FLOATING_ROW_DATA_CHANGED);
	    };
	    FloatingRowModel.prototype.createNodesFromData = function (allData, isTop) {
	        var _this = this;
	        var rowNodes = [];
	        if (allData) {
	            var nextRowTop = 0;
	            allData.forEach(function (dataItem, index) {
	                var rowNode = new rowNode_1.RowNode();
	                _this.context.wireBean(rowNode);
	                rowNode.data = dataItem;
	                rowNode.floating = isTop ? constants_1.Constants.FLOATING_TOP : constants_1.Constants.FLOATING_BOTTOM;
	                rowNode.setRowTop(nextRowTop);
	                rowNode.setRowHeight(_this.gridOptionsWrapper.getRowHeightForNode(rowNode));
	                rowNode.setRowIndex(index);
	                nextRowTop += rowNode.rowHeight;
	                rowNodes.push(rowNode);
	            });
	        }
	        return rowNodes;
	    };
	    FloatingRowModel.prototype.getFloatingTopRowData = function () {
	        return this.floatingTopRows;
	    };
	    FloatingRowModel.prototype.getFloatingBottomRowData = function () {
	        return this.floatingBottomRows;
	    };
	    FloatingRowModel.prototype.getFloatingTopTotalHeight = function () {
	        return this.getTotalHeight(this.floatingTopRows);
	    };
	    FloatingRowModel.prototype.getFloatingTopRowCount = function () {
	        return this.floatingTopRows ? this.floatingTopRows.length : 0;
	    };
	    FloatingRowModel.prototype.getFloatingBottomRowCount = function () {
	        return this.floatingBottomRows ? this.floatingBottomRows.length : 0;
	    };
	    FloatingRowModel.prototype.getFloatingTopRow = function (index) {
	        return this.floatingTopRows[index];
	    };
	    FloatingRowModel.prototype.getFloatingBottomRow = function (index) {
	        return this.floatingBottomRows[index];
	    };
	    FloatingRowModel.prototype.forEachFloatingTopRow = function (callback) {
	        if (utils_1.Utils.missingOrEmpty(this.floatingTopRows)) {
	            return;
	        }
	        this.floatingTopRows.forEach(callback);
	    };
	    FloatingRowModel.prototype.forEachFloatingBottomRow = function (callback) {
	        if (utils_1.Utils.missingOrEmpty(this.floatingBottomRows)) {
	            return;
	        }
	        this.floatingBottomRows.forEach(callback);
	    };
	    FloatingRowModel.prototype.getFloatingBottomTotalHeight = function () {
	        return this.getTotalHeight(this.floatingBottomRows);
	    };
	    FloatingRowModel.prototype.getTotalHeight = function (rowNodes) {
	        if (!rowNodes || rowNodes.length === 0) {
	            return 0;
	        }
	        else {
	            var lastNode = rowNodes[rowNodes.length - 1];
	            return lastNode.rowTop + lastNode.rowHeight;
	        }
	    };
	    __decorate([
	        context_2.Autowired('gridOptionsWrapper'), 
	        __metadata('design:type', gridOptionsWrapper_1.GridOptionsWrapper)
	    ], FloatingRowModel.prototype, "gridOptionsWrapper", void 0);
	    __decorate([
	        context_2.Autowired('eventService'), 
	        __metadata('design:type', eventService_1.EventService)
	    ], FloatingRowModel.prototype, "eventService", void 0);
	    __decorate([
	        context_2.Autowired('context'), 
	        __metadata('design:type', context_1.Context)
	    ], FloatingRowModel.prototype, "context", void 0);
	    __decorate([
	        context_3.PostConstruct, 
	        __metadata('design:type', Function), 
	        __metadata('design:paramtypes', []), 
	        __metadata('design:returntype', void 0)
	    ], FloatingRowModel.prototype, "init", null);
	    FloatingRowModel = __decorate([
	        context_1.Bean('floatingRowModel'), 
	        __metadata('design:paramtypes', [])
	    ], FloatingRowModel);
	    return FloatingRowModel;
	})();
	exports.FloatingRowModel = FloatingRowModel;


/***/ },
/* 27 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
	 * @version v7.0.2
	 * @link http://www.ag-grid.com/
	 * @license MIT
	 */
	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var eventService_1 = __webpack_require__(4);
	var events_1 = __webpack_require__(10);
	var gridOptionsWrapper_1 = __webpack_require__(3);
	var selectionController_1 = __webpack_require__(28);
	var valueService_1 = __webpack_require__(29);
	var columnController_1 = __webpack_require__(13);
	var context_1 = __webpack_require__(6);
	var constants_1 = __webpack_require__(8);
	var utils_1 = __webpack_require__(7);
	var RowNode = (function () {
	    function RowNode() {
	        /** Children mapped by the pivot columns */
	        this.childrenMapped = {};
	        this.selected = false;
	    }
	    RowNode.prototype.setData = function (data) {
	        var oldData = this.data;
	        this.data = data;
	        var event = { oldData: oldData, newData: data };
	        this.dispatchLocalEvent(RowNode.EVENT_DATA_CHANGED, event);
	    };
	    RowNode.prototype.createDaemonNode = function () {
	        var oldNode = new RowNode();
	        this.context.wireBean(oldNode);
	        // just copy the id and data, this is enough for the node to be used
	        // in the selection controller (the selection controller is the only
	        // place where daemon nodes can live).
	        oldNode.id = this.id;
	        oldNode.data = this.data;
	        oldNode.daemon = true;
	        oldNode.selected = this.selected;
	        oldNode.level = this.level;
	        return oldNode;
	    };
	    RowNode.prototype.setDataAndId = function (data, id) {
	        var oldNode = utils_1.Utils.exists(this.id) ? this.createDaemonNode() : null;
	        var oldData = this.data;
	        this.data = data;
	        this.setId(id);
	        this.selectionController.syncInRowNode(this, oldNode);
	        var event = { oldData: oldData, newData: data };
	        this.dispatchLocalEvent(RowNode.EVENT_DATA_CHANGED, event);
	    };
	    RowNode.prototype.setId = function (id) {
	        // see if user is providing the id's
	        var getRowNodeId = this.gridOptionsWrapper.getRowNodeIdFunc();
	        if (getRowNodeId) {
	            // if user is providing the id's, then we set the id only after the data has been set.
	            // this is important for virtual pagination and viewport, where empty rows exist.
	            if (this.data) {
	                this.id = getRowNodeId(this.data);
	            }
	            else {
	                // this can happen if user has set blank into the rowNode after the row previously
	                // having data. this happens in virtual page row model, when data is delete and
	                // the page is refreshed.
	                this.id = undefined;
	            }
	        }
	        else {
	            this.id = id;
	        }
	    };
	    RowNode.prototype.clearRowTop = function () {
	        this.oldRowTop = this.rowTop;
	        this.setRowTop(null);
	    };
	    RowNode.prototype.setRowTop = function (rowTop) {
	        if (this.rowTop === rowTop) {
	            return;
	        }
	        this.rowTop = rowTop;
	        if (this.eventService) {
	            this.eventService.dispatchEvent(RowNode.EVENT_TOP_CHANGED);
	        }
	    };
	    RowNode.prototype.setRowHeight = function (rowHeight) {
	        this.rowHeight = rowHeight;
	        if (this.eventService) {
	            this.eventService.dispatchEvent(RowNode.EVENT_HEIGHT_CHANGED);
	        }
	    };
	    RowNode.prototype.setRowIndex = function (rowIndex) {
	        this.rowIndex = rowIndex;
	        if (this.eventService) {
	            this.eventService.dispatchEvent(RowNode.EVENT_ROW_INDEX_CHANGED);
	        }
	    };
	    RowNode.prototype.setExpanded = function (expanded) {
	        if (this.expanded === expanded) {
	            return;
	        }
	        this.expanded = expanded;
	        if (this.eventService) {
	            this.eventService.dispatchEvent(RowNode.EVENT_EXPANDED_CHANGED);
	        }
	        var event = { node: this };
	        this.mainEventService.dispatchEvent(events_1.Events.EVENT_ROW_GROUP_OPENED, event);
	    };
	    RowNode.prototype.dispatchLocalEvent = function (eventName, event) {
	        if (this.eventService) {
	            this.eventService.dispatchEvent(eventName, event);
	        }
	    };
	    // we also allow editing the value via the editors. when it is done via
	    // the editors, no 'cell changed' event gets fired, as it's assumed that
	    // the cell knows about the change given it's in charge of the editing.
	    // this method is for the client to call, so the cell listens for the change
	    // event, and also flashes the cell when the change occurs.
	    RowNode.prototype.setDataValue = function (colKey, newValue) {
	        var column = this.columnController.getGridColumn(colKey);
	        this.valueService.setValue(this, column, newValue);
	        var event = { column: column, newValue: newValue };
	        this.dispatchLocalEvent(RowNode.EVENT_CELL_CHANGED, event);
	    };
	    RowNode.prototype.resetQuickFilterAggregateText = function () {
	        this.quickFilterAggregateText = null;
	    };
	    RowNode.prototype.isExpandable = function () {
	        return this.group || this.canFlower;
	    };
	    RowNode.prototype.isSelected = function () {
	        // for footers, we just return what our sibling selected state is, as cannot select a footer
	        if (this.footer) {
	            return this.sibling.isSelected();
	        }
	        return this.selected;
	    };
	    RowNode.prototype.depthFirstSearch = function (callback) {
	        if (this.childrenAfterGroup) {
	            this.childrenAfterGroup.forEach(function (child) { return child.depthFirstSearch(callback); });
	        }
	        callback(this);
	    };
	    // + rowController.updateGroupsInSelection()
	    RowNode.prototype.calculateSelectedFromChildren = function () {
	        var atLeastOneSelected = false;
	        var atLeastOneDeSelected = false;
	        var atLeastOneMixed = false;
	        var newSelectedValue;
	        if (this.childrenAfterGroup) {
	            for (var i = 0; i < this.childrenAfterGroup.length; i++) {
	                var childState = this.childrenAfterGroup[i].isSelected();
	                switch (childState) {
	                    case true:
	                        atLeastOneSelected = true;
	                        break;
	                    case false:
	                        atLeastOneDeSelected = true;
	                        break;
	                    default:
	                        atLeastOneMixed = true;
	                        break;
	                }
	            }
	        }
	        if (atLeastOneMixed) {
	            newSelectedValue = undefined;
	        }
	        else if (atLeastOneSelected && !atLeastOneDeSelected) {
	            newSelectedValue = true;
	        }
	        else if (!atLeastOneSelected && atLeastOneDeSelected) {
	            newSelectedValue = false;
	        }
	        else {
	            newSelectedValue = undefined;
	        }
	        this.selectThisNode(newSelectedValue);
	    };
	    RowNode.prototype.calculateSelectedFromChildrenBubbleUp = function () {
	        this.calculateSelectedFromChildren();
	        if (this.parent) {
	            this.parent.calculateSelectedFromChildrenBubbleUp();
	        }
	    };
	    RowNode.prototype.setSelectedInitialValue = function (selected) {
	        this.selected = selected;
	    };
	    RowNode.prototype.setSelected = function (newValue, clearSelection, tailingNodeInSequence) {
	        if (clearSelection === void 0) { clearSelection = false; }
	        if (tailingNodeInSequence === void 0) { tailingNodeInSequence = false; }
	        this.setSelectedParams({
	            newValue: newValue,
	            clearSelection: clearSelection,
	            tailingNodeInSequence: tailingNodeInSequence,
	            rangeSelect: false
	        });
	    };
	    // to make calling code more readable, this is the same method as setSelected except it takes names parameters
	    RowNode.prototype.setSelectedParams = function (params) {
	        var groupSelectsChildren = this.gridOptionsWrapper.isGroupSelectsChildren();
	        var newValue = params.newValue === true;
	        var clearSelection = params.clearSelection === true;
	        var tailingNodeInSequence = params.tailingNodeInSequence === true;
	        var rangeSelect = params.rangeSelect === true;
	        // groupSelectsFiltered only makes sense when group selects children
	        var groupSelectsFiltered = groupSelectsChildren && (params.groupSelectsFiltered === true);
	        if (this.id === undefined) {
	            console.warn('ag-Grid: cannot select node until id for node is known');
	            return 0;
	        }
	        if (this.floating) {
	            console.log('ag-Grid: cannot select floating rows');
	            return 0;
	        }
	        // if we are a footer, we don't do selection, just pass the info
	        // to the sibling (the parent of the group)
	        if (this.footer) {
	            var count = this.sibling.setSelectedParams(params);
	            return count;
	        }
	        if (rangeSelect) {
	            var rowModelNormal = this.rowModel.getType() === constants_1.Constants.ROW_MODEL_TYPE_NORMAL;
	            var newRowClicked = this.selectionController.getLastSelectedNode() !== this;
	            var allowMultiSelect = this.gridOptionsWrapper.isRowSelectionMulti();
	            if (rowModelNormal && newRowClicked && allowMultiSelect) {
	                return this.doRowRangeSelection();
	            }
	        }
	        var updatedCount = 0;
	        // when groupSelectsFiltered, then this node may end up intermediate despite
	        // trying to set it to true / false. this group will be calculated further on
	        // down when we call calculatedSelectedForAllGroupNodes(). we need to skip it
	        // here, otherwise the updatedCount would include it.
	        var skipThisNode = groupSelectsFiltered && this.group;
	        if (!skipThisNode) {
	            var thisNodeWasSelected = this.selectThisNode(newValue);
	            if (thisNodeWasSelected) {
	                updatedCount++;
	            }
	        }
	        if (groupSelectsChildren && this.group) {
	            updatedCount += this.selectChildNodes(newValue, groupSelectsFiltered);
	        }
	        // clear other nodes if not doing multi select
	        var actionWasOnThisNode = !tailingNodeInSequence;
	        if (actionWasOnThisNode) {
	            if (newValue && (clearSelection || !this.gridOptionsWrapper.isRowSelectionMulti())) {
	                this.selectionController.clearOtherNodes(this);
	            }
	            // only if we selected something, then update groups and fire events
	            if (updatedCount > 0) {
	                // update groups
	                if (groupSelectsFiltered) {
	                    // if the group was selecting filtered, then all nodes above and or below
	                    // this node could have check, unchecked or intermediate, so easiest is to
	                    // recalculate selected state for all group nodes
	                    this.calculatedSelectedForAllGroupNodes();
	                }
	                else {
	                    // if no selecting filtered, then everything below the group node was either
	                    // selected or not selected, no intermediate, so no need to check items below
	                    // this one, just the parents all the way up to the root
	                    if (groupSelectsChildren && this.parent) {
	                        this.parent.calculateSelectedFromChildrenBubbleUp();
	                    }
	                }
	                // fire events
	                // this is the very end of the 'action node', so we are finished all the updates,
	                // include any parent / child changes that this method caused
	                this.mainEventService.dispatchEvent(events_1.Events.EVENT_SELECTION_CHANGED);
	            }
	            // so if user next does shift-select, we know where to start the selection from
	            if (newValue) {
	                this.selectionController.setLastSelectedNode(this);
	            }
	        }
	        return updatedCount;
	    };
	    // selects all rows between this node and the last selected node (or the top if this is the first selection).
	    // not to be mixed up with 'cell range selection' where you drag the mouse, this is row range selection, by
	    // holding down 'shift'.
	    RowNode.prototype.doRowRangeSelection = function () {
	        var _this = this;
	        var lastSelectedNode = this.selectionController.getLastSelectedNode();
	        // if lastSelectedNode is missing, we start at the first row
	        var firstRowHit = !lastSelectedNode;
	        var lastRowHit = false;
	        var lastRow;
	        var groupsSelectChildren = this.gridOptionsWrapper.isGroupSelectsChildren();
	        var updatedCount = 0;
	        var inMemoryRowModel = this.rowModel;
	        inMemoryRowModel.forEachNodeAfterFilterAndSort(function (rowNode) {
	            var lookingForLastRow = firstRowHit && !lastRowHit;
	            // check if we need to flip the select switch
	            if (!firstRowHit) {
	                if (rowNode === lastSelectedNode || rowNode === _this) {
	                    firstRowHit = true;
	                }
	            }
	            var skipThisGroupNode = rowNode.group && groupsSelectChildren;
	            if (!skipThisGroupNode) {
	                var inRange = firstRowHit && !lastRowHit;
	                var childOfLastRow = rowNode.isParentOfNode(lastRow);
	                var nodeWasSelected = rowNode.selectThisNode(inRange || childOfLastRow);
	                if (nodeWasSelected) {
	                    updatedCount++;
	                }
	            }
	            if (lookingForLastRow) {
	                if (rowNode === lastSelectedNode || rowNode === _this) {
	                    lastRowHit = true;
	                    if (rowNode === lastSelectedNode) {
	                        lastRow = lastSelectedNode;
	                    }
	                    else {
	                        lastRow = _this;
	                    }
	                }
	            }
	        });
	        if (groupsSelectChildren) {
	            this.calculatedSelectedForAllGroupNodes();
	        }
	        this.mainEventService.dispatchEvent(events_1.Events.EVENT_SELECTION_CHANGED);
	        return updatedCount;
	    };
	    RowNode.prototype.isParentOfNode = function (potentialParent) {
	        var parentNode = this.parent;
	        while (parentNode) {
	            if (parentNode === potentialParent) {
	                return true;
	            }
	            parentNode = parentNode.parent;
	        }
	        return false;
	    };
	    RowNode.prototype.calculatedSelectedForAllGroupNodes = function () {
	        // we have to make sure we do this dept first, as parent nodes
	        // will have dependencies on the children having correct values
	        var inMemoryRowModel = this.rowModel;
	        inMemoryRowModel.getTopLevelNodes().forEach(function (topLevelNode) {
	            if (topLevelNode.group) {
	                topLevelNode.depthFirstSearch(function (childNode) {
	                    if (childNode.group) {
	                        childNode.calculateSelectedFromChildren();
	                    }
	                });
	                topLevelNode.calculateSelectedFromChildren();
	            }
	        });
	    };
	    RowNode.prototype.selectThisNode = function (newValue) {
	        if (this.selected === newValue) {
	            return false;
	        }
	        this.selected = newValue;
	        if (this.eventService) {
	            this.dispatchLocalEvent(RowNode.EVENT_ROW_SELECTED);
	        }
	        var event = { node: this };
	        this.mainEventService.dispatchEvent(events_1.Events.EVENT_ROW_SELECTED, event);
	        return true;
	    };
	    RowNode.prototype.selectChildNodes = function (newValue, groupSelectsFiltered) {
	        var children = groupSelectsFiltered ? this.childrenAfterFilter : this.childrenAfterGroup;
	        var updatedCount = 0;
	        if (utils_1.Utils.missing(children)) {
	            return;
	        }
	        for (var i = 0; i < children.length; i++) {
	            updatedCount += children[i].setSelectedParams({
	                newValue: newValue,
	                clearSelection: false,
	                tailingNodeInSequence: true
	            });
	        }
	        return updatedCount;
	    };
	    RowNode.prototype.addEventListener = function (eventType, listener) {
	        if (!this.eventService) {
	            this.eventService = new eventService_1.EventService();
	        }
	        this.eventService.addEventListener(eventType, listener);
	    };
	    RowNode.prototype.removeEventListener = function (eventType, listener) {
	        this.eventService.removeEventListener(eventType, listener);
	    };
	    RowNode.prototype.onMouseEnter = function () {
	        this.dispatchLocalEvent(RowNode.EVENT_MOUSE_ENTER);
	    };
	    RowNode.prototype.onMouseLeave = function () {
	        this.dispatchLocalEvent(RowNode.EVENT_MOUSE_LEAVE);
	    };
	    RowNode.EVENT_ROW_SELECTED = 'rowSelected';
	    RowNode.EVENT_DATA_CHANGED = 'dataChanged';
	    RowNode.EVENT_CELL_CHANGED = 'cellChanged';
	    RowNode.EVENT_MOUSE_ENTER = 'mouseEnter';
	    RowNode.EVENT_MOUSE_LEAVE = 'mouseLeave';
	    RowNode.EVENT_HEIGHT_CHANGED = 'heightChanged';
	    RowNode.EVENT_TOP_CHANGED = 'topChanged';
	    RowNode.EVENT_ROW_INDEX_CHANGED = 'rowIndexChanged';
	    RowNode.EVENT_EXPANDED_CHANGED = 'expandedChanged';
	    __decorate([
	        context_1.Autowired('eventService'), 
	        __metadata('design:type', eventService_1.EventService)
	    ], RowNode.prototype, "mainEventService", void 0);
	    __decorate([
	        context_1.Autowired('gridOptionsWrapper'), 
	        __metadata('design:type', gridOptionsWrapper_1.GridOptionsWrapper)
	    ], RowNode.prototype, "gridOptionsWrapper", void 0);
	    __decorate([
	        context_1.Autowired('selectionController'), 
	        __metadata('design:type', selectionController_1.SelectionController)
	    ], RowNode.prototype, "selectionController", void 0);
	    __decorate([
	        context_1.Autowired('columnController'), 
	        __metadata('design:type', columnController_1.ColumnController)
	    ], RowNode.prototype, "columnController", void 0);
	    __decorate([
	        context_1.Autowired('valueService'), 
	        __metadata('design:type', valueService_1.ValueService)
	    ], RowNode.prototype, "valueService", void 0);
	    __decorate([
	        context_1.Autowired('rowModel'), 
	        __metadata('design:type', Object)
	    ], RowNode.prototype, "rowModel", void 0);
	    __decorate([
	        context_1.Autowired('context'), 
	        __metadata('design:type', context_1.Context)
	    ], RowNode.prototype, "context", void 0);
	    return RowNode;
	})();
	exports.RowNode = RowNode;


/***/ },
/* 28 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
	 * @version v7.0.2
	 * @link http://www.ag-grid.com/
	 * @license MIT
	 */
	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var __param = (this && this.__param) || function (paramIndex, decorator) {
	    return function (target, key) { decorator(target, key, paramIndex); }
	};
	var utils_1 = __webpack_require__(7);
	var context_1 = __webpack_require__(6);
	var context_2 = __webpack_require__(6);
	var logger_1 = __webpack_require__(5);
	var eventService_1 = __webpack_require__(4);
	var events_1 = __webpack_require__(10);
	var context_3 = __webpack_require__(6);
	var gridOptionsWrapper_1 = __webpack_require__(3);
	var context_4 = __webpack_require__(6);
	var constants_1 = __webpack_require__(8);
	var SelectionController = (function () {
	    function SelectionController() {
	    }
	    SelectionController.prototype.setBeans = function (loggerFactory) {
	        this.logger = loggerFactory.create('SelectionController');
	        this.reset();
	        if (this.gridOptionsWrapper.isRowModelDefault()) {
	            this.eventService.addEventListener(events_1.Events.EVENT_ROW_DATA_CHANGED, this.reset.bind(this));
	        }
	        else {
	            this.logger.log('dont know what to do here');
	        }
	    };
	    SelectionController.prototype.init = function () {
	        this.groupSelectsChildren = this.gridOptionsWrapper.isGroupSelectsChildren();
	        this.eventService.addEventListener(events_1.Events.EVENT_ROW_SELECTED, this.onRowSelected.bind(this));
	    };
	    SelectionController.prototype.setLastSelectedNode = function (rowNode) {
	        this.lastSelectedNode = rowNode;
	    };
	    SelectionController.prototype.getLastSelectedNode = function () {
	        return this.lastSelectedNode;
	    };
	    SelectionController.prototype.getSelectedNodes = function () {
	        var selectedNodes = [];
	        utils_1.Utils.iterateObject(this.selectedNodes, function (key, rowNode) {
	            if (rowNode) {
	                selectedNodes.push(rowNode);
	            }
	        });
	        return selectedNodes;
	    };
	    SelectionController.prototype.getSelectedRows = function () {
	        var selectedRows = [];
	        utils_1.Utils.iterateObject(this.selectedNodes, function (key, rowNode) {
	            if (rowNode) {
	                selectedRows.push(rowNode.data);
	            }
	        });
	        return selectedRows;
	    };
	    SelectionController.prototype.removeGroupsFromSelection = function () {
	        var _this = this;
	        utils_1.Utils.iterateObject(this.selectedNodes, function (key, rowNode) {
	            if (rowNode && rowNode.group) {
	                _this.selectedNodes[rowNode.id] = undefined;
	            }
	        });
	    };
	    // should only be called if groupSelectsChildren=true
	    SelectionController.prototype.updateGroupsFromChildrenSelections = function () {
	        if (this.rowModel.getType() !== constants_1.Constants.ROW_MODEL_TYPE_NORMAL) {
	            console.warn('updateGroupsFromChildrenSelections not available when rowModel is not normal');
	        }
	        var inMemoryRowModel = this.rowModel;
	        inMemoryRowModel.getTopLevelNodes().forEach(function (rowNode) {
	            rowNode.depthFirstSearch(function (rowNode) {
	                if (rowNode.group) {
	                    rowNode.calculateSelectedFromChildren();
	                }
	            });
	        });
	    };
	    SelectionController.prototype.getNodeForIdIfSelected = function (id) {
	        return this.selectedNodes[id];
	    };
	    SelectionController.prototype.clearOtherNodes = function (rowNodeToKeepSelected) {
	        var _this = this;
	        var groupsToRefresh = {};
	        utils_1.Utils.iterateObject(this.selectedNodes, function (key, otherRowNode) {
	            if (otherRowNode && otherRowNode.id !== rowNodeToKeepSelected.id) {
	                var rowNode = _this.selectedNodes[otherRowNode.id];
	                rowNode.setSelectedParams({ newValue: false, clearSelection: false, tailingNodeInSequence: true });
	                if (_this.groupSelectsChildren && otherRowNode.parent) {
	                    groupsToRefresh[otherRowNode.parent.id] = otherRowNode.parent;
	                }
	            }
	        });
	        utils_1.Utils.iterateObject(groupsToRefresh, function (key, group) {
	            group.calculateSelectedFromChildren();
	        });
	    };
	    SelectionController.prototype.onRowSelected = function (event) {
	        var rowNode = event.node;
	        // we do not store the group rows when the groups select children
	        if (this.groupSelectsChildren && rowNode.group) {
	            return;
	        }
	        if (rowNode.isSelected()) {
	            this.selectedNodes[rowNode.id] = rowNode;
	        }
	        else {
	            this.selectedNodes[rowNode.id] = undefined;
	        }
	    };
	    SelectionController.prototype.syncInRowNode = function (rowNode, oldNode) {
	        this.syncInOldRowNode(rowNode, oldNode);
	        this.syncInNewRowNode(rowNode);
	    };
	    // if the id has changed for the node, then this means the rowNode
	    // is getting used for a different data item, which breaks
	    // our selectedNodes, as the node now is mapped by the old id
	    // which is inconsistent. so to keep the old node as selected,
	    // we swap in the clone (with the old id and old data). this means
	    // the oldNode is effectively a daemon we keep a reference to,
	    // so if client calls api.getSelectedNodes(), it gets the daemon
	    // in the result. when the client un-selects, the reference to the
	    // daemon is removed. the daemon, because it's an oldNode, is not
	    // used by the grid for rendering, it's a copy of what the node used
	    // to be like before the id was changed.
	    SelectionController.prototype.syncInOldRowNode = function (rowNode, oldNode) {
	        var oldNodeHasDifferentId = utils_1.Utils.exists(oldNode) && (rowNode.id !== oldNode.id);
	        if (oldNodeHasDifferentId) {
	            var oldNodeSelected = utils_1.Utils.exists(this.selectedNodes[oldNode.id]);
	            if (oldNodeSelected) {
	                this.selectedNodes[oldNode.id] = oldNode;
	            }
	        }
	    };
	    SelectionController.prototype.syncInNewRowNode = function (rowNode) {
	        if (utils_1.Utils.exists(this.selectedNodes[rowNode.id])) {
	            rowNode.setSelectedInitialValue(true);
	            this.selectedNodes[rowNode.id] = rowNode;
	        }
	        else {
	            rowNode.setSelectedInitialValue(false);
	        }
	    };
	    SelectionController.prototype.reset = function () {
	        this.logger.log('reset');
	        this.selectedNodes = {};
	        this.lastSelectedNode = null;
	    };
	    // returns a list of all nodes at 'best cost' - a feature to be used
	    // with groups / trees. if a group has all it's children selected,
	    // then the group appears in the result, but not the children.
	    // Designed for use with 'children' as the group selection type,
	    // where groups don't actually appear in the selection normally.
	    SelectionController.prototype.getBestCostNodeSelection = function () {
	        if (this.rowModel.getType() !== constants_1.Constants.ROW_MODEL_TYPE_NORMAL) {
	            console.warn('getBestCostNodeSelection is only avilable when using normal row model');
	        }
	        var inMemoryRowModel = this.rowModel;
	        var topLevelNodes = inMemoryRowModel.getTopLevelNodes();
	        if (topLevelNodes === null) {
	            console.warn('selectAll not available doing rowModel=virtual');
	            return;
	        }
	        var result = [];
	        // recursive function, to find the selected nodes
	        function traverse(nodes) {
	            for (var i = 0, l = nodes.length; i < l; i++) {
	                var node = nodes[i];
	                if (node.isSelected()) {
	                    result.push(node);
	                }
	                else {
	                    // if not selected, then if it's a group, and the group
	                    // has children, continue to search for selections
	                    if (node.group && node.children) {
	                        traverse(node.children);
	                    }
	                }
	            }
	        }
	        traverse(topLevelNodes);
	        return result;
	    };
	    SelectionController.prototype.setRowModel = function (rowModel) {
	        this.rowModel = rowModel;
	    };
	    SelectionController.prototype.isEmpty = function () {
	        var count = 0;
	        utils_1.Utils.iterateObject(this.selectedNodes, function (nodeId, rowNode) {
	            if (rowNode) {
	                count++;
	            }
	        });
	        return count === 0;
	    };
	    SelectionController.prototype.deselectAllRowNodes = function () {
	        utils_1.Utils.iterateObject(this.selectedNodes, function (nodeId, rowNode) {
	            if (rowNode) {
	                rowNode.selectThisNode(false);
	            }
	        });
	        // the above does not clean up the parent rows if they are selected
	        if (this.rowModel.getType() === constants_1.Constants.ROW_MODEL_TYPE_NORMAL && this.groupSelectsChildren) {
	            this.updateGroupsFromChildrenSelections();
	        }
	        // we should not have to do this, as deselecting the nodes fires events
	        // that we pick up, however it's good to clean it down, as we are still
	        // left with entries pointing to 'undefined'
	        this.selectedNodes = {};
	        this.eventService.dispatchEvent(events_1.Events.EVENT_SELECTION_CHANGED);
	    };
	    SelectionController.prototype.selectAllRowNodes = function () {
	        if (this.rowModel.getType() !== constants_1.Constants.ROW_MODEL_TYPE_NORMAL) {
	            throw 'selectAll only available with normal row model, ie not virtual pagination';
	        }
	        this.rowModel.forEachNode(function (rowNode) {
	            rowNode.selectThisNode(true);
	        });
	        this.eventService.dispatchEvent(events_1.Events.EVENT_SELECTION_CHANGED);
	    };
	    // Deprecated method
	    SelectionController.prototype.selectNode = function (rowNode, tryMulti) {
	        rowNode.setSelectedParams({ newValue: true, clearSelection: !tryMulti });
	    };
	    // Deprecated method
	    SelectionController.prototype.deselectIndex = function (rowIndex) {
	        var node = this.rowModel.getRow(rowIndex);
	        this.deselectNode(node);
	    };
	    // Deprecated method
	    SelectionController.prototype.deselectNode = function (rowNode) {
	        rowNode.setSelectedParams({ newValue: false, clearSelection: false });
	    };
	    // Deprecated method
	    SelectionController.prototype.selectIndex = function (index, tryMulti) {
	        var node = this.rowModel.getRow(index);
	        this.selectNode(node, tryMulti);
	    };
	    __decorate([
	        context_3.Autowired('eventService'), 
	        __metadata('design:type', eventService_1.EventService)
	    ], SelectionController.prototype, "eventService", void 0);
	    __decorate([
	        context_3.Autowired('rowModel'), 
	        __metadata('design:type', Object)
	    ], SelectionController.prototype, "rowModel", void 0);
	    __decorate([
	        context_3.Autowired('gridOptionsWrapper'), 
	        __metadata('design:type', gridOptionsWrapper_1.GridOptionsWrapper)
	    ], SelectionController.prototype, "gridOptionsWrapper", void 0);
	    __decorate([
	        __param(0, context_2.Qualifier('loggerFactory')), 
	        __metadata('design:type', Function), 
	        __metadata('design:paramtypes', [logger_1.LoggerFactory]), 
	        __metadata('design:returntype', void 0)
	    ], SelectionController.prototype, "setBeans", null);
	    __decorate([
	        context_4.PostConstruct, 
	        __metadata('design:type', Function), 
	        __metadata('design:paramtypes', []), 
	        __metadata('design:returntype', void 0)
	    ], SelectionController.prototype, "init", null);
	    SelectionController = __decorate([
	        context_1.Bean('selectionController'), 
	        __metadata('design:paramtypes', [])
	    ], SelectionController);
	    return SelectionController;
	})();
	exports.SelectionController = SelectionController;


/***/ },
/* 29 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
	 * @version v7.0.2
	 * @link http://www.ag-grid.com/
	 * @license MIT
	 */
	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var gridOptionsWrapper_1 = __webpack_require__(3);
	var expressionService_1 = __webpack_require__(18);
	var columnController_1 = __webpack_require__(13);
	var context_1 = __webpack_require__(6);
	var utils_1 = __webpack_require__(7);
	var events_1 = __webpack_require__(10);
	var eventService_1 = __webpack_require__(4);
	var ValueService = (function () {
	    function ValueService() {
	        this.initialised = false;
	    }
	    ValueService.prototype.init = function () {
	        this.cellExpressions = this.gridOptionsWrapper.isEnableCellExpressions();
	        this.userProvidedTheGroups = utils_1.Utils.exists(this.gridOptionsWrapper.getNodeChildDetailsFunc());
	        this.suppressUseColIdForGroups = this.gridOptionsWrapper.isSuppressUseColIdForGroups();
	        this.initialised = true;
	    };
	    ValueService.prototype.getValue = function (column, node) {
	        return this.getValueUsingSpecificData(column, node.data, node);
	    };
	    ValueService.prototype.getValueUsingSpecificData = function (column, data, node) {
	        // hack - the grid is getting refreshed before this bean gets initialised, race condition.
	        // really should have a way so they get initialised in the right order???
	        if (!this.initialised) {
	            this.init();
	        }
	        var colDef = column.getColDef();
	        var field = colDef.field;
	        var result;
	        // if there is a value getter, this gets precedence over a field
	        // - need to revisit this, we check 'data' as this is the way for the grid to
	        //   not render when on the footer row
	        if (data && node.group && !this.userProvidedTheGroups && !this.suppressUseColIdForGroups) {
	            result = node.data ? node.data[column.getId()] : undefined;
	        }
	        else if (colDef.valueGetter) {
	            result = this.executeValueGetter(colDef.valueGetter, data, column, node);
	        }
	        else if (field && data) {
	            result = utils_1.Utils.getValueUsingField(data, field, column.isFieldContainsDots());
	        }
	        else {
	            result = undefined;
	        }
	        // the result could be an expression itself, if we are allowing cell values to be expressions
	        if (this.cellExpressions && (typeof result === 'string') && result.indexOf('=') === 0) {
	            var cellValueGetter = result.substring(1);
	            result = this.executeValueGetter(cellValueGetter, data, column, node);
	        }
	        return result;
	    };
	    ValueService.prototype.setValue = function (rowNode, colKey, newValue) {
	        var column = this.columnController.getPrimaryColumn(colKey);
	        if (!rowNode || !column) {
	            return;
	        }
	        // this will only happen if user is trying to paste into a group row, which doesn't make sense
	        // the user should not be trying to paste into group rows
	        var data = rowNode.data;
	        if (utils_1.Utils.missing(data)) {
	            return;
	        }
	        var field = column.getColDef().field;
	        var newValueHandler = column.getColDef().newValueHandler;
	        // need either a field or a newValueHandler for this to work
	        if (utils_1.Utils.missing(field) && utils_1.Utils.missing(newValueHandler)) {
	            console.warn("ag-Grid: you need either field or newValueHandler set on colDef for editing to work");
	            return;
	        }
	        var paramsForCallbacks = {
	            node: rowNode,
	            data: rowNode.data,
	            oldValue: this.getValue(column, rowNode),
	            newValue: newValue,
	            colDef: column.getColDef(),
	            api: this.gridOptionsWrapper.getApi(),
	            context: this.gridOptionsWrapper.getContext()
	        };
	        if (newValueHandler) {
	            newValueHandler(paramsForCallbacks);
	        }
	        else {
	            this.setValueUsingField(data, field, newValue, column.isFieldContainsDots());
	        }
	        // reset quick filter on this row
	        rowNode.resetQuickFilterAggregateText();
	        paramsForCallbacks.newValue = this.getValue(column, rowNode);
	        if (typeof column.getColDef().onCellValueChanged === 'function') {
	            column.getColDef().onCellValueChanged(paramsForCallbacks);
	        }
	        this.eventService.dispatchEvent(events_1.Events.EVENT_CELL_VALUE_CHANGED, paramsForCallbacks);
	    };
	    ValueService.prototype.setValueUsingField = function (data, field, newValue, isFieldContainsDots) {
	        // if no '.', then it's not a deep value
	        if (!isFieldContainsDots) {
	            data[field] = newValue;
	        }
	        else {
	            // otherwise it is a deep value, so need to dig for it
	            var fieldPieces = field.split('.');
	            var currentObject = data;
	            while (fieldPieces.length > 0 && currentObject) {
	                var fieldPiece = fieldPieces.shift();
	                if (fieldPieces.length === 0) {
	                    currentObject[fieldPiece] = newValue;
	                }
	                else {
	                    currentObject = currentObject[fieldPiece];
	                }
	            }
	        }
	    };
	    ValueService.prototype.executeValueGetter = function (valueGetter, data, column, node) {
	        var context = this.gridOptionsWrapper.getContext();
	        var api = this.gridOptionsWrapper.getApi();
	        var params = {
	            data: data,
	            node: node,
	            colDef: column.getColDef(),
	            api: api,
	            context: context,
	            getValue: this.getValueCallback.bind(this, data, node)
	        };
	        if (typeof valueGetter === 'function') {
	            // valueGetter is a function, so just call it
	            return valueGetter(params);
	        }
	        else if (typeof valueGetter === 'string') {
	            // valueGetter is an expression, so execute the expression
	            return this.expressionService.evaluate(valueGetter, params);
	        }
	    };
	    ValueService.prototype.getValueCallback = function (data, node, field) {
	        var otherColumn = this.columnController.getPrimaryColumn(field);
	        if (otherColumn) {
	            return this.getValueUsingSpecificData(otherColumn, data, node);
	        }
	        else {
	            return null;
	        }
	    };
	    __decorate([
	        context_1.Autowired('gridOptionsWrapper'), 
	        __metadata('design:type', gridOptionsWrapper_1.GridOptionsWrapper)
	    ], ValueService.prototype, "gridOptionsWrapper", void 0);
	    __decorate([
	        context_1.Autowired('expressionService'), 
	        __metadata('design:type', expressionService_1.ExpressionService)
	    ], ValueService.prototype, "expressionService", void 0);
	    __decorate([
	        context_1.Autowired('columnController'), 
	        __metadata('design:type', columnController_1.ColumnController)
	    ], ValueService.prototype, "columnController", void 0);
	    __decorate([
	        context_1.Autowired('eventService'), 
	        __metadata('design:type', eventService_1.EventService)
	    ], ValueService.prototype, "eventService", void 0);
	    __decorate([
	        context_1.PostConstruct, 
	        __metadata('design:type', Function), 
	        __metadata('design:paramtypes', []), 
	        __metadata('design:returntype', void 0)
	    ], ValueService.prototype, "init", null);
	    ValueService = __decorate([
	        context_1.Bean('valueService'), 
	        __metadata('design:paramtypes', [])
	    ], ValueService);
	    return ValueService;
	})();
	exports.ValueService = ValueService;


/***/ },
/* 30 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
	 * @version v7.0.2
	 * @link http://www.ag-grid.com/
	 * @license MIT
	 */
	var utils_1 = __webpack_require__(7);
	var BorderLayout = (function () {
	    function BorderLayout(params) {
	        this.centerHeightLastTime = -1;
	        this.centerWidthLastTime = -1;
	        this.centerLeftMarginLastTime = -1;
	        this.visibleLastTime = false;
	        this.sizeChangeListeners = [];
	        this.isLayoutPanel = true;
	        this.fullHeight = !params.north && !params.south;
	        var template;
	        if (!params.dontFill) {
	            if (this.fullHeight) {
	                template = BorderLayout.TEMPLATE_FULL_HEIGHT;
	            }
	            else {
	                template = BorderLayout.TEMPLATE_NORMAL;
	            }
	            this.layoutActive = true;
	        }
	        else {
	            template = BorderLayout.TEMPLATE_DONT_FILL;
	            this.layoutActive = false;
	        }
	        this.eGui = utils_1.Utils.loadTemplate(template);
	        this.id = 'borderLayout';
	        if (params.name) {
	            this.id += '_' + params.name;
	        }
	        this.eGui.setAttribute('id', this.id);
	        this.childPanels = [];
	        if (params) {
	            this.setupPanels(params);
	        }
	        this.overlays = params.overlays;
	        this.setupOverlays();
	    }
	    BorderLayout.prototype.addSizeChangeListener = function (listener) {
	        this.sizeChangeListeners.push(listener);
	    };
	    BorderLayout.prototype.fireSizeChanged = function () {
	        this.sizeChangeListeners.forEach(function (listener) {
	            listener();
	        });
	    };
	    BorderLayout.prototype.setupPanels = function (params) {
	        this.eNorthWrapper = this.eGui.querySelector('#north');
	        this.eSouthWrapper = this.eGui.querySelector('#south');
	        this.eEastWrapper = this.eGui.querySelector('#east');
	        this.eWestWrapper = this.eGui.querySelector('#west');
	        this.eCenterWrapper = this.eGui.querySelector('#center');
	        this.eOverlayWrapper = this.eGui.querySelector('#overlay');
	        this.eCenterRow = this.eGui.querySelector('#centerRow');
	        this.eNorthChildLayout = this.setupPanel(params.north, this.eNorthWrapper);
	        this.eSouthChildLayout = this.setupPanel(params.south, this.eSouthWrapper);
	        this.eEastChildLayout = this.setupPanel(params.east, this.eEastWrapper);
	        this.eWestChildLayout = this.setupPanel(params.west, this.eWestWrapper);
	        this.eCenterChildLayout = this.setupPanel(params.center, this.eCenterWrapper);
	    };
	    BorderLayout.prototype.setupPanel = function (content, ePanel) {
	        if (!ePanel) {
	            return;
	        }
	        if (content) {
	            if (content.isLayoutPanel) {
	                this.childPanels.push(content);
	                ePanel.appendChild(content.getGui());
	                return content;
	            }
	            else {
	                ePanel.appendChild(content);
	                return null;
	            }
	        }
	        else {
	            ePanel.parentNode.removeChild(ePanel);
	            return null;
	        }
	    };
	    BorderLayout.prototype.getGui = function () {
	        return this.eGui;
	    };
	    // returns true if any item changed size, otherwise returns false
	    BorderLayout.prototype.doLayout = function () {
	        var _this = this;
	        var isVisible = utils_1.Utils.isVisible(this.eGui);
	        if (!isVisible) {
	            this.visibleLastTime = false;
	            return false;
	        }
	        var atLeastOneChanged = false;
	        if (this.visibleLastTime !== isVisible) {
	            atLeastOneChanged = true;
	        }
	        this.visibleLastTime = true;
	        var childLayouts = [this.eNorthChildLayout, this.eSouthChildLayout, this.eEastChildLayout, this.eWestChildLayout];
	        childLayouts.forEach(function (childLayout) {
	            var childChangedSize = _this.layoutChild(childLayout);
	            if (childChangedSize) {
	                atLeastOneChanged = true;
	            }
	        });
	        if (this.layoutActive) {
	            var ourHeightChanged = this.layoutHeight();
	            var ourWidthChanged = this.layoutWidth();
	            if (ourHeightChanged || ourWidthChanged) {
	                atLeastOneChanged = true;
	            }
	        }
	        var centerChanged = this.layoutChild(this.eCenterChildLayout);
	        if (centerChanged) {
	            atLeastOneChanged = true;
	        }
	        if (atLeastOneChanged) {
	            this.fireSizeChanged();
	        }
	        return atLeastOneChanged;
	    };
	    BorderLayout.prototype.layoutChild = function (childPanel) {
	        if (childPanel) {
	            return childPanel.doLayout();
	        }
	        else {
	            return false;
	        }
	    };
	    BorderLayout.prototype.layoutHeight = function () {
	        if (this.fullHeight) {
	            return this.layoutHeightFullHeight();
	        }
	        else {
	            return this.layoutHeightNormal();
	        }
	    };
	    // full height never changes the height, because the center is always 100%,
	    // however we do check for change, to inform the listeners
	    BorderLayout.prototype.layoutHeightFullHeight = function () {
	        var centerHeight = utils_1.Utils.offsetHeight(this.eGui);
	        if (centerHeight < 0) {
	            centerHeight = 0;
	        }
	        if (this.centerHeightLastTime !== centerHeight) {
	            this.centerHeightLastTime = centerHeight;
	            return true;
	        }
	        else {
	            return false;
	        }
	    };
	    BorderLayout.prototype.layoutHeightNormal = function () {
	        var totalHeight = utils_1.Utils.offsetHeight(this.eGui);
	        var northHeight = utils_1.Utils.offsetHeight(this.eNorthWrapper);
	        var southHeight = utils_1.Utils.offsetHeight(this.eSouthWrapper);
	        var centerHeight = totalHeight - northHeight - southHeight;
	        if (centerHeight < 0) {
	            centerHeight = 0;
	        }
	        if (this.centerHeightLastTime !== centerHeight) {
	            this.eCenterRow.style.height = centerHeight + 'px';
	            this.centerHeightLastTime = centerHeight;
	            return true; // return true because there was a change
	        }
	        else {
	            return false;
	        }
	    };
	    BorderLayout.prototype.getCentreHeight = function () {
	        return this.centerHeightLastTime;
	    };
	    BorderLayout.prototype.layoutWidth = function () {
	        var totalWidth = utils_1.Utils.offsetWidth(this.eGui);
	        var eastWidth = utils_1.Utils.offsetWidth(this.eEastWrapper);
	        var westWidth = utils_1.Utils.offsetWidth(this.eWestWrapper);
	        var centerWidth = totalWidth - eastWidth - westWidth;
	        if (centerWidth < 0) {
	            centerWidth = 0;
	        }
	        var atLeastOneChanged = false;
	        if (this.centerLeftMarginLastTime !== westWidth) {
	            this.centerLeftMarginLastTime = westWidth;
	            this.eCenterWrapper.style.marginLeft = westWidth + 'px';
	            atLeastOneChanged = true;
	        }
	        if (this.centerWidthLastTime !== centerWidth) {
	            this.centerWidthLastTime = centerWidth;
	            this.eCenterWrapper.style.width = centerWidth + 'px';
	            atLeastOneChanged = true;
	        }
	        return atLeastOneChanged;
	    };
	    BorderLayout.prototype.setEastVisible = function (visible) {
	        if (this.eEastWrapper) {
	            this.eEastWrapper.style.display = visible ? '' : 'none';
	        }
	        this.doLayout();
	    };
	    BorderLayout.prototype.setupOverlays = function () {
	        // if no overlays, just remove the panel
	        if (!this.overlays) {
	            this.eOverlayWrapper.parentNode.removeChild(this.eOverlayWrapper);
	            return;
	        }
	        this.hideOverlay();
	    };
	    BorderLayout.prototype.hideOverlay = function () {
	        utils_1.Utils.removeAllChildren(this.eOverlayWrapper);
	        this.eOverlayWrapper.style.display = 'none';
	    };
	    BorderLayout.prototype.showOverlay = function (key) {
	        var overlay = this.overlays ? this.overlays[key] : null;
	        if (overlay) {
	            utils_1.Utils.removeAllChildren(this.eOverlayWrapper);
	            this.eOverlayWrapper.style.display = '';
	            this.eOverlayWrapper.appendChild(overlay);
	        }
	        else {
	            console.log('ag-Grid: unknown overlay');
	            this.hideOverlay();
	        }
	    };
	    BorderLayout.TEMPLATE_FULL_HEIGHT = '<div class="ag-bl ag-bl-full-height">' +
	        '  <div class="ag-bl-west ag-bl-full-height-west" id="west"></div>' +
	        '  <div class="ag-bl-east ag-bl-full-height-east" id="east"></div>' +
	        '  <div class="ag-bl-center ag-bl-full-height-center" id="center"></div>' +
	        '  <div class="ag-bl-overlay" id="overlay"></div>' +
	        '</div>';
	    BorderLayout.TEMPLATE_NORMAL = '<div class="ag-bl ag-bl-normal">' +
	        '  <div id="north"></div>' +
	        '  <div class="ag-bl-center-row ag-bl-normal-center-row" id="centerRow">' +
	        '    <div class="ag-bl-west ag-bl-normal-west" id="west"></div>' +
	        '    <div class="ag-bl-east ag-bl-normal-east" id="east"></div>' +
	        '    <div class="ag-bl-center ag-bl-normal-center" id="center"></div>' +
	        '  </div>' +
	        '  <div id="south"></div>' +
	        '  <div class="ag-bl-overlay" id="overlay"></div>' +
	        '</div>';
	    BorderLayout.TEMPLATE_DONT_FILL = '<div class="ag-bl ag-bl-dont-fill">' +
	        '  <div id="north"></div>' +
	        '  <div id="centerRow">' +
	        '    <div id="west"></div>' +
	        '    <div id="east"></div>' +
	        '    <div id="center"></div>' +
	        '  </div>' +
	        '  <div id="south"></div>' +
	        '  <div class="ag-bl-overlay" id="overlay"></div>' +
	        '</div>';
	    return BorderLayout;
	})();
	exports.BorderLayout = BorderLayout;


/***/ },
/* 31 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
	 * @version v7.0.2
	 * @link http://www.ag-grid.com/
	 * @license MIT
	 */
	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var context_1 = __webpack_require__(6);
	var logger_1 = __webpack_require__(5);
	var utils_1 = __webpack_require__(7);
	var eventService_1 = __webpack_require__(4);
	var events_1 = __webpack_require__(10);
	var gridOptionsWrapper_1 = __webpack_require__(3);
	/** Adds drag listening onto an element. In ag-Grid this is used twice, first is resizing columns,
	 * second is moving the columns and column groups around (ie the 'drag' part of Drag and Drop. */
	var DragService = (function () {
	    function DragService() {
	        this.onMouseUpListener = this.onMouseUp.bind(this);
	        this.onMouseMoveListener = this.onMouseMove.bind(this);
	        this.onTouchEndListener = this.onTouchUp.bind(this);
	        this.onTouchMoveListener = this.onTouchMove.bind(this);
	        this.dragEndFunctions = [];
	        this.dragSources = [];
	    }
	    DragService.prototype.init = function () {
	        this.logger = this.loggerFactory.create('DragService');
	        this.eBody = document.querySelector('body');
	    };
	    DragService.prototype.destroy = function () {
	        this.dragSources.forEach(this.removeListener.bind(this));
	        this.dragSources.length = 0;
	    };
	    DragService.prototype.removeListener = function (dragSourceAndListener) {
	        var element = dragSourceAndListener.dragSource.eElement;
	        var mouseDownListener = dragSourceAndListener.mouseDownListener;
	        element.removeEventListener('mousedown', mouseDownListener);
	        // remove touch listener only if it exists
	        if (dragSourceAndListener.touchEnabled) {
	            var touchStartListener = dragSourceAndListener.touchStartListener;
	            element.removeEventListener('touchstart', touchStartListener);
	        }
	    };
	    DragService.prototype.removeDragSource = function (params) {
	        var dragSourceAndListener = utils_1.Utils.find(this.dragSources, function (item) { return item.dragSource === params; });
	        if (!dragSourceAndListener) {
	            return;
	        }
	        this.removeListener(dragSourceAndListener);
	        utils_1.Utils.removeFromArray(this.dragSources, dragSourceAndListener);
	    };
	    DragService.prototype.setNoSelectToBody = function (noSelect) {
	        if (utils_1.Utils.exists(this.eBody)) {
	            utils_1.Utils.addOrRemoveCssClass(this.eBody, 'ag-body-no-select', noSelect);
	        }
	    };
	    DragService.prototype.addDragSource = function (params, includeTouch) {
	        if (includeTouch === void 0) { includeTouch = false; }
	        var mouseListener = this.onMouseDown.bind(this, params);
	        params.eElement.addEventListener('mousedown', mouseListener);
	        var touchListener = null;
	        var suppressTouch = this.gridOptionsWrapper.isSuppressTouch();
	        var reallyIncludeTouch = includeTouch && !suppressTouch;
	        if (reallyIncludeTouch) {
	            touchListener = this.onTouchStart.bind(this, params);
	            params.eElement.addEventListener('touchstart', touchListener);
	        }
	        this.dragSources.push({
	            dragSource: params,
	            mouseDownListener: mouseListener,
	            touchStartListener: touchListener,
	            touchEnabled: includeTouch
	        });
	    };
	    // gets called whenever mouse down on any drag source
	    DragService.prototype.onTouchStart = function (params, touchEvent) {
	        var _this = this;
	        this.currentDragParams = params;
	        this.dragging = false;
	        var touch = touchEvent.touches[0];
	        this.touchLastTime = touch;
	        this.touchStart = touch;
	        touchEvent.preventDefault();
	        // we temporally add these listeners, for the duration of the drag, they
	        // are removed in touch end handling.
	        params.eElement.addEventListener('touchmove', this.onTouchMoveListener);
	        params.eElement.addEventListener('touchend', this.onTouchEndListener);
	        params.eElement.addEventListener('touchcancel', this.onTouchEndListener);
	        this.dragEndFunctions.push(function () {
	            params.eElement.removeEventListener('touchmove', _this.onTouchMoveListener);
	            params.eElement.removeEventListener('touchend', _this.onTouchEndListener);
	            params.eElement.removeEventListener('touchcancel', _this.onTouchEndListener);
	        });
	        // see if we want to start dragging straight away
	        if (params.dragStartPixels === 0) {
	            this.onCommonMove(touch, this.touchStart);
	        }
	    };
	    // gets called whenever mouse down on any drag source
	    DragService.prototype.onMouseDown = function (params, mouseEvent) {
	        var _this = this;
	        // only interested in left button clicks
	        if (mouseEvent.button !== 0) {
	            return;
	        }
	        this.currentDragParams = params;
	        this.dragging = false;
	        this.mouseEventLastTime = mouseEvent;
	        this.mouseStartEvent = mouseEvent;
	        // we temporally add these listeners, for the duration of the drag, they
	        // are removed in mouseup handling.
	        document.addEventListener('mousemove', this.onMouseMoveListener);
	        document.addEventListener('mouseup', this.onMouseUpListener);
	        this.dragEndFunctions.push(function () {
	            document.removeEventListener('mousemove', _this.onMouseMoveListener);
	            document.removeEventListener('mouseup', _this.onMouseUpListener);
	        });
	        // see if we want to start dragging straight away
	        if (params.dragStartPixels === 0) {
	            this.onMouseMove(mouseEvent);
	        }
	    };
	    // returns true if the event is close to the original event by X pixels either vertically or horizontally.
	    // we only start dragging after X pixels so this allows us to know if we should start dragging yet.
	    DragService.prototype.isEventNearStartEvent = function (currentEvent, startEvent) {
	        // by default, we wait 4 pixels before starting the drag
	        var requiredPixelDiff = utils_1.Utils.exists(this.currentDragParams.dragStartPixels) ? this.currentDragParams.dragStartPixels : 4;
	        return utils_1.Utils.areEventsNear(currentEvent, startEvent, requiredPixelDiff);
	    };
	    DragService.prototype.getFirstActiveTouch = function (touchList) {
	        for (var i = 0; i < touchList.length; i++) {
	            var matches = touchList[i].identifier === this.touchStart.identifier;
	            if (matches) {
	                return touchList[i];
	            }
	        }
	        return null;
	    };
	    DragService.prototype.onCommonMove = function (currentEvent, startEvent) {
	        if (!this.dragging) {
	            // if mouse hasn't travelled from the start position enough, do nothing
	            var toEarlyToDrag = !this.dragging && this.isEventNearStartEvent(currentEvent, startEvent);
	            if (toEarlyToDrag) {
	                return;
	            }
	            else {
	                // alert(`started`);
	                this.dragging = true;
	                this.eventService.dispatchEvent(events_1.Events.EVENT_DRAG_STARTED);
	                this.currentDragParams.onDragStart(startEvent);
	                this.setNoSelectToBody(true);
	            }
	        }
	        this.currentDragParams.onDragging(currentEvent);
	    };
	    DragService.prototype.onTouchMove = function (touchEvent) {
	        var touch = this.getFirstActiveTouch(touchEvent.touches);
	        if (!touch) {
	            return;
	        }
	        // this.___statusBar.setInfoText(Math.random() + ' onTouchMove preventDefault stopPropagation');
	        this.onCommonMove(touch, this.touchStart);
	    };
	    // only gets called after a mouse down - as this is only added after mouseDown
	    // and is removed when mouseUp happens
	    DragService.prototype.onMouseMove = function (mouseEvent) {
	        this.onCommonMove(mouseEvent, this.mouseStartEvent);
	    };
	    DragService.prototype.onTouchUp = function (touchEvent) {
	        var touch = this.getFirstActiveTouch(touchEvent.targetTouches);
	        // i haven't worked this out yet, but there is no matching touch
	        // when we get the touch up event. to get around this, we swap in
	        // the last touch. this is a hack to 'get it working' while we
	        // figure out what's going on, why we are not getting a touch in
	        // current event.
	        if (!touch) {
	            touch = this.touchLastTime;
	        }
	        // if mouse was left up before we started to move, then this is a tap.
	        // we check this before onUpCommon as onUpCommon resets the dragging
	        // var tap = !this.dragging;
	        // var tapTarget = this.currentDragParams.eElement;
	        this.onUpCommon(touch);
	        // if tap, tell user
	        // console.log(`${Math.random()} tap = ${tap}`);
	        // if (tap) {
	        //     tapTarget.click();
	        // }
	    };
	    DragService.prototype.onMouseUp = function (mouseEvent) {
	        this.onUpCommon(mouseEvent);
	    };
	    DragService.prototype.onUpCommon = function (eventOrTouch) {
	        if (this.dragging) {
	            this.dragging = false;
	            this.currentDragParams.onDragStop(eventOrTouch);
	            this.eventService.dispatchEvent(events_1.Events.EVENT_DRAG_STOPPED);
	        }
	        this.setNoSelectToBody(false);
	        this.mouseStartEvent = null;
	        this.mouseEventLastTime = null;
	        this.touchStart = null;
	        this.touchLastTime = null;
	        this.currentDragParams = null;
	        this.dragEndFunctions.forEach(function (func) { return func(); });
	        this.dragEndFunctions.length = 0;
	    };
	    __decorate([
	        context_1.Autowired('loggerFactory'), 
	        __metadata('design:type', logger_1.LoggerFactory)
	    ], DragService.prototype, "loggerFactory", void 0);
	    __decorate([
	        context_1.Autowired('eventService'), 
	        __metadata('design:type', eventService_1.EventService)
	    ], DragService.prototype, "eventService", void 0);
	    __decorate([
	        context_1.Autowired('gridOptionsWrapper'), 
	        __metadata('design:type', gridOptionsWrapper_1.GridOptionsWrapper)
	    ], DragService.prototype, "gridOptionsWrapper", void 0);
	    __decorate([
	        context_1.PostConstruct, 
	        __metadata('design:type', Function), 
	        __metadata('design:paramtypes', []), 
	        __metadata('design:returntype', void 0)
	    ], DragService.prototype, "init", null);
	    __decorate([
	        context_1.PreDestroy, 
	        __metadata('design:type', Function), 
	        __metadata('design:paramtypes', []), 
	        __metadata('design:returntype', void 0)
	    ], DragService.prototype, "destroy", null);
	    DragService = __decorate([
	        context_1.Bean('dragService'), 
	        __metadata('design:paramtypes', [])
	    ], DragService);
	    return DragService;
	})();
	exports.DragService = DragService;


/***/ },
/* 32 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
	 * @version v7.0.2
	 * @link http://www.ag-grid.com/
	 * @license MIT
	 */
	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var context_1 = __webpack_require__(6);
	var context_2 = __webpack_require__(6);
	var gridPanel_1 = __webpack_require__(24);
	var columnController_1 = __webpack_require__(13);
	var column_1 = __webpack_require__(15);
	var constants_1 = __webpack_require__(8);
	var floatingRowModel_1 = __webpack_require__(26);
	var utils_1 = __webpack_require__(7);
	var gridCell_1 = __webpack_require__(33);
	var gridOptionsWrapper_1 = __webpack_require__(3);
	var MouseEventService = (function () {
	    function MouseEventService() {
	    }
	    MouseEventService.prototype.getCellForMouseEvent = function (mouseEvent) {
	        var floating = this.getFloating(mouseEvent);
	        var rowIndex = this.getRowIndex(mouseEvent, floating);
	        var column = this.getColumn(mouseEvent);
	        if (rowIndex >= 0 && utils_1.Utils.exists(column)) {
	            return new gridCell_1.GridCell(rowIndex, floating, column);
	        }
	        else {
	            return null;
	        }
	    };
	    MouseEventService.prototype.getFloating = function (mouseEvent) {
	        var floatingTopRowsExist = !this.floatingRowModel.isEmpty(constants_1.Constants.FLOATING_TOP);
	        var floatingBottomRowsExist = !this.floatingRowModel.isEmpty(constants_1.Constants.FLOATING_BOTTOM);
	        var floatingTopRect = floatingTopRowsExist ? this.gridPanel.getFloatingTopClientRect() : null;
	        var floatingBottomRect = floatingBottomRowsExist ? this.gridPanel.getFloatingBottomClientRect() : null;
	        if (floatingTopRowsExist && floatingTopRect.bottom >= mouseEvent.clientY) {
	            return constants_1.Constants.FLOATING_TOP;
	        }
	        else if (floatingBottomRowsExist && floatingBottomRect.top <= mouseEvent.clientY) {
	            return constants_1.Constants.FLOATING_BOTTOM;
	        }
	        else {
	            return null;
	        }
	    };
	    MouseEventService.prototype.getFloatingRowIndex = function (mouseEvent, floating) {
	        var clientRect;
	        switch (floating) {
	            case constants_1.Constants.FLOATING_TOP:
	                clientRect = this.gridPanel.getFloatingTopClientRect();
	                break;
	            case constants_1.Constants.FLOATING_BOTTOM:
	                clientRect = this.gridPanel.getFloatingBottomClientRect();
	                break;
	        }
	        var bodyY = mouseEvent.clientY - clientRect.top;
	        var rowIndex = this.floatingRowModel.getRowAtPixel(bodyY, floating);
	        return rowIndex;
	    };
	    MouseEventService.prototype.getRowIndex = function (mouseEvent, floating) {
	        switch (floating) {
	            case constants_1.Constants.FLOATING_TOP:
	            case constants_1.Constants.FLOATING_BOTTOM:
	                return this.getFloatingRowIndex(mouseEvent, floating);
	            default: return this.getBodyRowIndex(mouseEvent);
	        }
	    };
	    MouseEventService.prototype.getBodyRowIndex = function (mouseEvent) {
	        var clientRect = this.gridPanel.getBodyViewportClientRect();
	        var scrollY = this.gridPanel.getVerticalScrollPosition();
	        var bodyY = mouseEvent.clientY - clientRect.top + scrollY;
	        var rowIndex = this.rowModel.getRowIndexAtPixel(bodyY);
	        return rowIndex;
	    };
	    MouseEventService.prototype.getContainer = function (mouseEvent) {
	        var centerRect = this.gridPanel.getBodyViewportClientRect();
	        var mouseX = mouseEvent.clientX;
	        if (mouseX < centerRect.left && this.columnController.isPinningLeft()) {
	            return column_1.Column.PINNED_LEFT;
	        }
	        else if (mouseX > centerRect.right && this.columnController.isPinningRight()) {
	            return column_1.Column.PINNED_RIGHT;
	        }
	        else {
	            return null;
	        }
	    };
	    MouseEventService.prototype.getColumn = function (mouseEvent) {
	        if (this.columnController.isEmpty()) {
	            return null;
	        }
	        var container = this.getContainer(mouseEvent);
	        var columns = this.getColumnsForContainer(container);
	        var containerX = this.getXForContainer(container, mouseEvent);
	        var hoveringColumn;
	        if (containerX < 0) {
	            hoveringColumn = columns[0];
	        }
	        columns.forEach(function (column) {
	            var afterLeft = containerX >= column.getLeft();
	            var beforeRight = containerX <= column.getRight();
	            if (afterLeft && beforeRight) {
	                hoveringColumn = column;
	            }
	        });
	        if (!hoveringColumn) {
	            hoveringColumn = columns[columns.length - 1];
	        }
	        return hoveringColumn;
	    };
	    MouseEventService.prototype.getColumnsForContainer = function (container) {
	        switch (container) {
	            case column_1.Column.PINNED_LEFT: return this.columnController.getDisplayedLeftColumns();
	            case column_1.Column.PINNED_RIGHT: return this.columnController.getDisplayedRightColumns();
	            default: return this.columnController.getDisplayedCenterColumns();
	        }
	    };
	    MouseEventService.prototype.getXForContainer = function (container, mouseEvent) {
	        var containerX;
	        switch (container) {
	            case column_1.Column.PINNED_LEFT:
	                containerX = this.gridPanel.getPinnedLeftColsViewportClientRect().left;
	                break;
	            case column_1.Column.PINNED_RIGHT:
	                containerX = this.gridPanel.getPinnedRightColsViewportClientRect().left;
	                break;
	            default:
	                var centerRect = this.gridPanel.getBodyViewportClientRect();
	                var centerScroll = this.gridPanel.getHorizontalScrollPosition();
	                containerX = centerRect.left - centerScroll;
	        }
	        var result = mouseEvent.clientX - containerX;
	        return result;
	    };
	    __decorate([
	        context_2.Autowired('gridPanel'), 
	        __metadata('design:type', gridPanel_1.GridPanel)
	    ], MouseEventService.prototype, "gridPanel", void 0);
	    __decorate([
	        context_2.Autowired('columnController'), 
	        __metadata('design:type', columnController_1.ColumnController)
	    ], MouseEventService.prototype, "columnController", void 0);
	    __decorate([
	        context_2.Autowired('rowModel'), 
	        __metadata('design:type', Object)
	    ], MouseEventService.prototype, "rowModel", void 0);
	    __decorate([
	        context_2.Autowired('floatingRowModel'), 
	        __metadata('design:type', floatingRowModel_1.FloatingRowModel)
	    ], MouseEventService.prototype, "floatingRowModel", void 0);
	    __decorate([
	        context_2.Autowired('gridOptionsWrapper'), 
	        __metadata('design:type', gridOptionsWrapper_1.GridOptionsWrapper)
	    ], MouseEventService.prototype, "gridOptionsWrapper", void 0);
	    MouseEventService = __decorate([
	        context_1.Bean('mouseEventService'), 
	        __metadata('design:paramtypes', [])
	    ], MouseEventService);
	    return MouseEventService;
	})();
	exports.MouseEventService = MouseEventService;


/***/ },
/* 33 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
	 * @version v7.0.2
	 * @link http://www.ag-grid.com/
	 * @license MIT
	 */
	var utils_1 = __webpack_require__(7);
	var gridRow_1 = __webpack_require__(34);
	var GridCell = (function () {
	    function GridCell(rowIndex, floating, column) {
	        this.rowIndex = rowIndex;
	        this.column = column;
	        this.floating = utils_1.Utils.makeNull(floating);
	    }
	    GridCell.prototype.getGridRow = function () {
	        return new gridRow_1.GridRow(this.rowIndex, this.floating);
	    };
	    GridCell.prototype.toString = function () {
	        return "rowIndex = " + this.rowIndex + ", floating = " + this.floating + ", column = " + (this.column ? this.column.getId() : null);
	    };
	    GridCell.prototype.createId = function () {
	        return this.rowIndex + "." + this.floating + "." + this.column.getId();
	    };
	    return GridCell;
	})();
	exports.GridCell = GridCell;


/***/ },
/* 34 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
	 * @version v7.0.2
	 * @link http://www.ag-grid.com/
	 * @license MIT
	 */
	var constants_1 = __webpack_require__(8);
	var utils_1 = __webpack_require__(7);
	var gridCell_1 = __webpack_require__(33);
	var GridRow = (function () {
	    function GridRow(rowIndex, floating) {
	        this.rowIndex = rowIndex;
	        this.floating = utils_1.Utils.makeNull(floating);
	    }
	    GridRow.prototype.isFloatingTop = function () {
	        return this.floating === constants_1.Constants.FLOATING_TOP;
	    };
	    GridRow.prototype.isFloatingBottom = function () {
	        return this.floating === constants_1.Constants.FLOATING_BOTTOM;
	    };
	    GridRow.prototype.isNotFloating = function () {
	        return !this.isFloatingBottom() && !this.isFloatingTop();
	    };
	    GridRow.prototype.equals = function (otherSelection) {
	        return this.rowIndex === otherSelection.rowIndex
	            && this.floating === otherSelection.floating;
	    };
	    GridRow.prototype.toString = function () {
	        return "rowIndex = " + this.rowIndex + ", floating = " + this.floating;
	    };
	    GridRow.prototype.getGridCell = function (column) {
	        return new gridCell_1.GridCell(this.rowIndex, this.floating, column);
	    };
	    // tests if this row selection is before the other row selection
	    GridRow.prototype.before = function (otherSelection) {
	        var otherFloating = otherSelection.floating;
	        switch (this.floating) {
	            case constants_1.Constants.FLOATING_TOP:
	                // we we are floating top, and other isn't, then we are always before
	                if (otherFloating !== constants_1.Constants.FLOATING_TOP) {
	                    return true;
	                }
	                break;
	            case constants_1.Constants.FLOATING_BOTTOM:
	                // if we are floating bottom, and the other isn't, then we are never before
	                if (otherFloating !== constants_1.Constants.FLOATING_BOTTOM) {
	                    return false;
	                }
	                break;
	            default:
	                // if we are not floating, but the other one is floating...
	                if (utils_1.Utils.exists(otherFloating)) {
	                    if (otherFloating === constants_1.Constants.FLOATING_TOP) {
	                        // we are not floating, other is floating top, we are first
	                        return false;
	                    }
	                    else {
	                        // we are not floating, other is floating bottom, we are always first
	                        return true;
	                    }
	                }
	                break;
	        }
	        return this.rowIndex <= otherSelection.rowIndex;
	    };
	    return GridRow;
	})();
	exports.GridRow = GridRow;


/***/ },
/* 35 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
	 * @version v7.0.2
	 * @link http://www.ag-grid.com/
	 * @license MIT
	 */
	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var context_1 = __webpack_require__(6);
	var eventService_1 = __webpack_require__(4);
	var events_1 = __webpack_require__(10);
	var gridOptionsWrapper_1 = __webpack_require__(3);
	var columnController_1 = __webpack_require__(13);
	var utils_1 = __webpack_require__(7);
	var gridCell_1 = __webpack_require__(33);
	var constants_1 = __webpack_require__(8);
	var FocusedCellController = (function () {
	    function FocusedCellController() {
	    }
	    FocusedCellController.prototype.init = function () {
	        this.eventService.addEventListener(events_1.Events.EVENT_COLUMN_PIVOT_MODE_CHANGED, this.clearFocusedCell.bind(this));
	        this.eventService.addEventListener(events_1.Events.EVENT_COLUMN_EVERYTHING_CHANGED, this.clearFocusedCell.bind(this));
	        this.eventService.addEventListener(events_1.Events.EVENT_COLUMN_GROUP_OPENED, this.clearFocusedCell.bind(this));
	        this.eventService.addEventListener(events_1.Events.EVENT_COLUMN_MOVED, this.clearFocusedCell.bind(this));
	        this.eventService.addEventListener(events_1.Events.EVENT_COLUMN_PINNED, this.clearFocusedCell.bind(this));
	        this.eventService.addEventListener(events_1.Events.EVENT_COLUMN_ROW_GROUP_CHANGED, this.clearFocusedCell.bind(this));
	        this.eventService.addEventListener(events_1.Events.EVENT_COLUMN_VISIBLE, this.clearFocusedCell.bind(this));
	    };
	    FocusedCellController.prototype.clearFocusedCell = function () {
	        this.focusedCell = null;
	        this.onCellFocused(false);
	    };
	    FocusedCellController.prototype.getFocusedCell = function () {
	        return this.focusedCell;
	    };
	    // we check if the browser is focusing something, and if it is, and
	    // it's the cell we think is focused, then return the cell. so this
	    // methods returns the cell if a) we think it has focus and b) the
	    // browser thinks it has focus. this then returns nothing if we
	    // first focus a cell, then second click outside the grid, as then the
	    // grid cell will still be focused as far as the grid is concerned,
	    // however the browser focus will have moved somewhere else.
	    FocusedCellController.prototype.getFocusCellToUseAfterRefresh = function () {
	        if (this.gridOptionsWrapper.isSuppressFocusAfterRefresh()) {
	            return null;
	        }
	        if (!this.focusedCell) {
	            return null;
	        }
	        var browserFocusedCell = this.getGridCellForDomElement(document.activeElement);
	        if (!browserFocusedCell) {
	            return null;
	        }
	        var gridFocusId = this.focusedCell.createId();
	        var browserFocusId = browserFocusedCell.createId();
	        if (gridFocusId === browserFocusId) {
	            return this.focusedCell;
	        }
	        else {
	            return null;
	        }
	    };
	    FocusedCellController.prototype.getGridCellForDomElement = function (eBrowserCell) {
	        if (!eBrowserCell) {
	            return null;
	        }
	        var column = null;
	        var row = null;
	        var floating = null;
	        var that = this;
	        while (eBrowserCell) {
	            checkRow(eBrowserCell);
	            checkColumn(eBrowserCell);
	            eBrowserCell = eBrowserCell.parentNode;
	        }
	        if (utils_1.Utils.exists(column) && utils_1.Utils.exists(row)) {
	            var gridCell = new gridCell_1.GridCell(row, floating, column);
	            return gridCell;
	        }
	        else {
	            return null;
	        }
	        function checkRow(eTarget) {
	            // match the column by checking a) it has a valid colId and b) it has the 'ag-cell' class
	            var rowId = utils_1.Utils.getElementAttribute(eTarget, 'row');
	            if (utils_1.Utils.exists(rowId) && utils_1.Utils.containsClass(eTarget, 'ag-row')) {
	                if (rowId.indexOf('ft') === 0) {
	                    floating = constants_1.Constants.FLOATING_TOP;
	                    rowId = rowId.substr(3);
	                }
	                else if (rowId.indexOf('fb') === 0) {
	                    floating = constants_1.Constants.FLOATING_BOTTOM;
	                    rowId = rowId.substr(3);
	                }
	                else {
	                    floating = null;
	                }
	                row = parseInt(rowId);
	            }
	        }
	        function checkColumn(eTarget) {
	            // match the column by checking a) it has a valid colId and b) it has the 'ag-cell' class
	            var colId = utils_1.Utils.getElementAttribute(eTarget, 'colid');
	            if (utils_1.Utils.exists(colId) && utils_1.Utils.containsClass(eTarget, 'ag-cell')) {
	                var foundColumn = that.columnController.getGridColumn(colId);
	                if (foundColumn) {
	                    column = foundColumn;
	                }
	            }
	        }
	    };
	    FocusedCellController.prototype.setFocusedCell = function (rowIndex, colKey, floating, forceBrowserFocus) {
	        if (forceBrowserFocus === void 0) { forceBrowserFocus = false; }
	        if (this.gridOptionsWrapper.isSuppressCellSelection()) {
	            return;
	        }
	        var column = utils_1.Utils.makeNull(this.columnController.getGridColumn(colKey));
	        this.focusedCell = new gridCell_1.GridCell(rowIndex, utils_1.Utils.makeNull(floating), column);
	        this.onCellFocused(forceBrowserFocus);
	    };
	    FocusedCellController.prototype.isCellFocused = function (gridCell) {
	        if (utils_1.Utils.missing(this.focusedCell)) {
	            return false;
	        }
	        return this.focusedCell.column === gridCell.column && this.isRowFocused(gridCell.rowIndex, gridCell.floating);
	    };
	    FocusedCellController.prototype.isRowFocused = function (rowIndex, floating) {
	        if (utils_1.Utils.missing(this.focusedCell)) {
	            return false;
	        }
	        var floatingOrNull = utils_1.Utils.makeNull(floating);
	        return this.focusedCell.rowIndex === rowIndex && this.focusedCell.floating === floatingOrNull;
	    };
	    FocusedCellController.prototype.onCellFocused = function (forceBrowserFocus) {
	        var event = {
	            rowIndex: null,
	            column: null,
	            floating: null,
	            forceBrowserFocus: forceBrowserFocus
	        };
	        if (this.focusedCell) {
	            event.rowIndex = this.focusedCell.rowIndex;
	            event.column = this.focusedCell.column;
	            event.floating = this.focusedCell.floating;
	        }
	        this.eventService.dispatchEvent(events_1.Events.EVENT_CELL_FOCUSED, event);
	    };
	    __decorate([
	        context_1.Autowired('eventService'), 
	        __metadata('design:type', eventService_1.EventService)
	    ], FocusedCellController.prototype, "eventService", void 0);
	    __decorate([
	        context_1.Autowired('gridOptionsWrapper'), 
	        __metadata('design:type', gridOptionsWrapper_1.GridOptionsWrapper)
	    ], FocusedCellController.prototype, "gridOptionsWrapper", void 0);
	    __decorate([
	        context_1.Autowired('columnController'), 
	        __metadata('design:type', columnController_1.ColumnController)
	    ], FocusedCellController.prototype, "columnController", void 0);
	    __decorate([
	        context_1.PostConstruct, 
	        __metadata('design:type', Function), 
	        __metadata('design:paramtypes', []), 
	        __metadata('design:returntype', void 0)
	    ], FocusedCellController.prototype, "init", null);
	    FocusedCellController = __decorate([
	        context_1.Bean('focusedCellController'), 
	        __metadata('design:paramtypes', [])
	    ], FocusedCellController);
	    return FocusedCellController;
	})();
	exports.FocusedCellController = FocusedCellController;


/***/ },
/* 36 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
	 * @version v7.0.2
	 * @link http://www.ag-grid.com/
	 * @license MIT
	 */
	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var context_1 = __webpack_require__(6);
	var context_2 = __webpack_require__(6);
	var TemplateService = (function () {
	    function TemplateService() {
	        this.templateCache = {};
	        this.waitingCallbacks = {};
	    }
	    // returns the template if it is loaded, or null if it is not loaded
	    // but will call the callback when it is loaded
	    TemplateService.prototype.getTemplate = function (url, callback) {
	        var templateFromCache = this.templateCache[url];
	        if (templateFromCache) {
	            return templateFromCache;
	        }
	        var callbackList = this.waitingCallbacks[url];
	        var that = this;
	        if (!callbackList) {
	            // first time this was called, so need a new list for callbacks
	            callbackList = [];
	            this.waitingCallbacks[url] = callbackList;
	            // and also need to do the http request
	            var client = new XMLHttpRequest();
	            client.onload = function () {
	                that.handleHttpResult(this, url);
	            };
	            client.open("GET", url);
	            client.send();
	        }
	        // add this callback
	        if (callback) {
	            callbackList.push(callback);
	        }
	        // caller needs to wait for template to load, so return null
	        return null;
	    };
	    TemplateService.prototype.handleHttpResult = function (httpResult, url) {
	        if (httpResult.status !== 200 || httpResult.response === null) {
	            console.warn('Unable to get template error ' + httpResult.status + ' - ' + url);
	            return;
	        }
	        // response success, so process it
	        // in IE9 the response is in - responseText
	        this.templateCache[url] = httpResult.response || httpResult.responseText;
	        // inform all listeners that this is now in the cache
	        var callbacks = this.waitingCallbacks[url];
	        for (var i = 0; i < callbacks.length; i++) {
	            var callback = callbacks[i];
	            // we could pass the callback the response, however we know the client of this code
	            // is the cell renderer, and it passes the 'cellRefresh' method in as the callback
	            // which doesn't take any parameters.
	            callback();
	        }
	        if (this.$scope) {
	            var that = this;
	            setTimeout(function () {
	                that.$scope.$apply();
	            }, 0);
	        }
	    };
	    __decorate([
	        context_2.Autowired('$scope'), 
	        __metadata('design:type', Object)
	    ], TemplateService.prototype, "$scope", void 0);
	    TemplateService = __decorate([
	        context_1.Bean('templateService'), 
	        __metadata('design:paramtypes', [])
	    ], TemplateService);
	    return TemplateService;
	})();
	exports.TemplateService = TemplateService;


/***/ },
/* 37 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
	 * @version v7.0.2
	 * @link http://www.ag-grid.com/
	 * @license MIT
	 */
	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var utils_1 = __webpack_require__(7);
	var renderedCell_1 = __webpack_require__(38);
	var rowNode_1 = __webpack_require__(27);
	var gridOptionsWrapper_1 = __webpack_require__(3);
	var columnController_1 = __webpack_require__(13);
	var column_1 = __webpack_require__(15);
	var events_1 = __webpack_require__(10);
	var eventService_1 = __webpack_require__(4);
	var context_1 = __webpack_require__(6);
	var focusedCellController_1 = __webpack_require__(35);
	var constants_1 = __webpack_require__(8);
	var cellRendererService_1 = __webpack_require__(60);
	var cellRendererFactory_1 = __webpack_require__(55);
	var gridPanel_1 = __webpack_require__(24);
	var RenderedRow = (function () {
	    function RenderedRow(parentScope, rowRenderer, eBodyContainer, eBodyContainerDF, eFullWidthContainer, ePinnedLeftContainer, ePinnedLeftContainerDF, ePinnedRightContainer, ePinnedRightContainerDF, node, animateIn) {
	        this.eAllRowContainers = [];
	        this.renderedCells = {};
	        this.destroyFunctions = [];
	        // for animations, there are bits we want done in the next VM turn, to all DOM to update first.
	        // instead of each row doing a setTimeout(func,0), we put the functions here and the rowRenderer
	        // executes them all in one timeout
	        this.nextVmTurnFunctions = [];
	        // for animations, these functions get called 400ms after the row is cleared, called by the rowRenderer
	        // so each row isn't setting up it's own timeout
	        this.delayedDestroyFunctions = [];
	        // these get called before the row is destroyed - they set up the DOM for the remove animation (ie they
	        // set the DOM up for the animation), then the delayedDestroyFunctions get called when the animation is
	        // complete (ie removes from the dom).
	        this.startRemoveAnimationFunctions = [];
	        this.editingRow = false;
	        this.initialised = false;
	        this.parentScope = parentScope;
	        this.rowRenderer = rowRenderer;
	        this.eBodyContainer = eBodyContainer;
	        this.eBodyContainerDF = eBodyContainerDF;
	        this.eFullWidthContainer = eFullWidthContainer;
	        this.ePinnedLeftContainer = ePinnedLeftContainer;
	        this.ePinnedLeftContainerDF = ePinnedLeftContainerDF;
	        this.ePinnedRightContainer = ePinnedRightContainer;
	        this.ePinnedRightContainerDF = ePinnedRightContainerDF;
	        this.rowNode = node;
	        this.animateIn = animateIn;
	    }
	    RenderedRow.prototype.setupRowContainers = function (animateInRowTop) {
	        var isFullWidthCellFunc = this.gridOptionsWrapper.getIsFullWidthCellFunc();
	        var isFullWidthCell = isFullWidthCellFunc ? isFullWidthCellFunc(this.rowNode) : false;
	        var isGroupSpanningRow = this.rowNode.group && this.gridOptionsWrapper.isGroupUseEntireRow();
	        if (isFullWidthCell) {
	            this.setupFullWidthContainers(animateInRowTop);
	        }
	        else if (isGroupSpanningRow) {
	            this.setupFullWidthGroupContainers(animateInRowTop);
	        }
	        else {
	            this.setupNormalContainers(animateInRowTop);
	        }
	    };
	    // we clear so that the functions are never executed twice
	    RenderedRow.prototype.getAndClearDelayedDestroyFunctions = function () {
	        var result = this.delayedDestroyFunctions;
	        this.delayedDestroyFunctions = [];
	        return result;
	    };
	    // we clear so that the functions are never executed twice
	    RenderedRow.prototype.getAndClearNextVMTurnFunctions = function () {
	        var result = this.nextVmTurnFunctions;
	        this.nextVmTurnFunctions = [];
	        return result;
	    };
	    RenderedRow.prototype.addDomData = function (eRowContainer) {
	        var domDataKey = this.gridOptionsWrapper.getDomDataKey();
	        var gridCellNoType = eRowContainer;
	        gridCellNoType[domDataKey] = {
	            renderedRow: this
	        };
	        this.destroyFunctions.push(function () { gridCellNoType[domDataKey] = null; });
	    };
	    RenderedRow.prototype.setupFullWidthContainers = function (animateInRowTop) {
	        this.fullWidthRow = true;
	        this.fullWidthCellRenderer = this.gridOptionsWrapper.getFullWidthCellRenderer();
	        this.fullWidthCellRendererParams = this.gridOptionsWrapper.getFullWidthCellRendererParams();
	        if (utils_1.Utils.missing(this.fullWidthCellRenderer)) {
	            console.warn("ag-Grid: you need to provide a fullWidthCellRenderer if using isFullWidthCell()");
	        }
	        this.eFullWidthRow = this.createRowContainer(null, this.eFullWidthContainer, animateInRowTop);
	        if (!this.gridOptionsWrapper.isForPrint()) {
	            this.addMouseWheelListenerToFullWidthRow();
	        }
	    };
	    RenderedRow.prototype.addMouseWheelListenerToFullWidthRow = function () {
	        var _this = this;
	        var mouseWheelListener = this.gridPanel.genericMouseWheelListener.bind(this.gridPanel);
	        // IE9, Chrome, Safari, Opera
	        this.eFullWidthRow.addEventListener('mousewheel', mouseWheelListener);
	        // Firefox
	        this.eFullWidthRow.addEventListener('DOMMouseScroll', mouseWheelListener);
	        this.destroyFunctions.push(function () {
	            _this.eFullWidthRow.removeEventListener('mousewheel', mouseWheelListener);
	            _this.eFullWidthRow.removeEventListener('DOMMouseScroll', mouseWheelListener);
	        });
	    };
	    RenderedRow.prototype.setupFullWidthGroupContainers = function (animateInRowTop) {
	        this.fullWidthRow = true;
	        this.fullWidthCellRenderer = this.gridOptionsWrapper.getGroupRowRenderer();
	        this.fullWidthCellRendererParams = this.gridOptionsWrapper.getGroupRowRendererParams();
	        if (!this.fullWidthCellRenderer) {
	            this.fullWidthCellRenderer = cellRendererFactory_1.CellRendererFactory.GROUP;
	            this.fullWidthCellRendererParams = {
	                innerRenderer: this.gridOptionsWrapper.getGroupRowInnerRenderer(),
	            };
	        }
	        this.eFullWidthRow = this.createRowContainer(null, this.eFullWidthContainer, animateInRowTop);
	        if (!this.gridOptionsWrapper.isForPrint()) {
	            this.addMouseWheelListenerToFullWidthRow();
	        }
	    };
	    RenderedRow.prototype.setupNormalContainers = function (animateInRowTop) {
	        this.fullWidthRow = false;
	        this.eBodyRow = this.createRowContainer(this.eBodyContainerDF, this.eBodyContainer, animateInRowTop);
	        if (!this.gridOptionsWrapper.isForPrint()) {
	            this.ePinnedLeftRow = this.createRowContainer(this.ePinnedLeftContainerDF, this.ePinnedLeftContainer, animateInRowTop);
	            this.ePinnedRightRow = this.createRowContainer(this.ePinnedRightContainerDF, this.ePinnedRightContainer, animateInRowTop);
	        }
	    };
	    RenderedRow.prototype.init = function () {
	        var animateInRowTop = this.animateIn && utils_1.Utils.exists(this.rowNode.oldRowTop);
	        this.setupRowContainers(animateInRowTop);
	        this.scope = this.createChildScopeOrNull(this.rowNode.data);
	        if (this.fullWidthRow) {
	            this.refreshFullWidthComponent();
	        }
	        else {
	            this.refreshCellsIntoRow();
	        }
	        this.addGridClasses();
	        this.addStyleFromRowStyle();
	        this.addStyleFromRowStyleFunc();
	        this.addClassesFromRowClass();
	        this.addClassesFromRowClassFunc();
	        this.addRowIndexes();
	        this.addRowIds();
	        this.setupTop(animateInRowTop);
	        this.setHeight();
	        this.addRowSelectedListener();
	        this.addCellFocusedListener();
	        this.addNodeDataChangedListener();
	        this.addColumnListener();
	        this.addHoverFunctionality();
	        this.gridOptionsWrapper.executeProcessRowPostCreateFunc({
	            eRow: this.eBodyRow,
	            ePinnedLeftRow: this.ePinnedLeftRow,
	            ePinnedRightRow: this.ePinnedRightRow,
	            node: this.rowNode,
	            api: this.gridOptionsWrapper.getApi(),
	            rowIndex: this.rowNode.rowIndex,
	            addRenderedRowListener: this.addEventListener.bind(this),
	            columnApi: this.gridOptionsWrapper.getColumnApi(),
	            context: this.gridOptionsWrapper.getContext()
	        });
	        this.addDataChangedListener();
	        this.initialised = true;
	    };
	    RenderedRow.prototype.stopRowEditing = function (cancel) {
	        this.stopEditing(cancel);
	    };
	    RenderedRow.prototype.stopEditing = function (cancel) {
	        if (cancel === void 0) { cancel = false; }
	        this.forEachRenderedCell(function (renderedCell) {
	            renderedCell.stopEditing(cancel);
	        });
	        if (this.editingRow) {
	            this.setEditingRow(false);
	            if (!cancel) {
	                var event = {
	                    node: this.rowNode,
	                    data: this.rowNode.data,
	                    api: this.gridOptionsWrapper.getApi(),
	                    context: this.gridOptionsWrapper.getContext()
	                };
	                this.mainEventService.dispatchEvent(events_1.Events.EVENT_ROW_VALUE_CHANGED, event);
	            }
	        }
	    };
	    RenderedRow.prototype.startRowEditing = function (keyPress, charPress, sourceRenderedCell) {
	        if (keyPress === void 0) { keyPress = null; }
	        if (charPress === void 0) { charPress = null; }
	        if (sourceRenderedCell === void 0) { sourceRenderedCell = null; }
	        // don't do it if already editing
	        if (this.editingRow) {
	            return;
	        }
	        this.forEachRenderedCell(function (renderedCell) {
	            var cellStartedEdit = renderedCell === sourceRenderedCell;
	            if (cellStartedEdit) {
	                renderedCell.startEditingIfEnabled(keyPress, charPress, cellStartedEdit);
	            }
	            else {
	                renderedCell.startEditingIfEnabled(null, null, cellStartedEdit);
	            }
	        });
	        this.setEditingRow(true);
	    };
	    RenderedRow.prototype.setEditingRow = function (value) {
	        this.editingRow = value;
	        this.eAllRowContainers.forEach(function (row) { return utils_1.Utils.addOrRemoveCssClass(row, 'ag-row-editing', value); });
	    };
	    // because data can change, especially in virtual pagination and viewport row models, need to allow setting
	    // styles and classes after the data has changed
	    RenderedRow.prototype.addDataChangedListener = function () {
	        var _this = this;
	        var dataChangedListener = function () {
	            _this.addStyleFromRowStyleFunc();
	            _this.addClassesFromRowClass();
	        };
	        this.rowNode.addEventListener(rowNode_1.RowNode.EVENT_DATA_CHANGED, dataChangedListener);
	        this.destroyFunctions.push(function () { return _this.rowNode.removeEventListener(rowNode_1.RowNode.EVENT_DATA_CHANGED, dataChangedListener); });
	    };
	    RenderedRow.prototype.angular1Compile = function (element) {
	        if (this.scope) {
	            this.$compile(element)(this.scope);
	        }
	    };
	    RenderedRow.prototype.addColumnListener = function () {
	        var _this = this;
	        var columnListener = this.onDisplayedColumnsChanged.bind(this);
	        var virtualListener = this.onVirtualColumnsChanged.bind(this);
	        var gridColumnsChangedListener = this.onGridColumnsChanged.bind(this);
	        this.mainEventService.addEventListener(events_1.Events.EVENT_DISPLAYED_COLUMNS_CHANGED, columnListener);
	        this.mainEventService.addEventListener(events_1.Events.EVENT_VIRTUAL_COLUMNS_CHANGED, virtualListener);
	        this.mainEventService.addEventListener(events_1.Events.EVENT_COLUMN_RESIZED, columnListener);
	        this.mainEventService.addEventListener(events_1.Events.EVENT_GRID_COLUMNS_CHANGED, gridColumnsChangedListener);
	        this.destroyFunctions.push(function () {
	            _this.mainEventService.removeEventListener(events_1.Events.EVENT_DISPLAYED_COLUMNS_CHANGED, columnListener);
	            _this.mainEventService.removeEventListener(events_1.Events.EVENT_VIRTUAL_COLUMNS_CHANGED, virtualListener);
	            _this.mainEventService.removeEventListener(events_1.Events.EVENT_COLUMN_RESIZED, columnListener);
	            _this.mainEventService.removeEventListener(events_1.Events.EVENT_GRID_COLUMNS_CHANGED, gridColumnsChangedListener);
	        });
	    };
	    RenderedRow.prototype.onDisplayedColumnsChanged = function (event) {
	        // if row is a group row that spans, then it's not impacted by column changes, with exception of pinning
	        if (this.fullWidthRow) {
	            var columnPinned = event.getType() === events_1.Events.EVENT_COLUMN_PINNED;
	            if (columnPinned) {
	                this.refreshFullWidthComponent();
	            }
	        }
	        else {
	            this.refreshCellsIntoRow();
	        }
	    };
	    RenderedRow.prototype.onVirtualColumnsChanged = function (event) {
	        // if row is a group row that spans, then it's not impacted by column changes, with exception of pinning
	        if (!this.fullWidthRow) {
	            this.refreshCellsIntoRow();
	        }
	    };
	    // when grid columns change, then all cells should be cleaned out,
	    // as the new columns could have same id as the previous columns and may conflict
	    RenderedRow.prototype.onGridColumnsChanged = function () {
	        var allRenderedCellIds = Object.keys(this.renderedCells);
	        this.removeRenderedCells(allRenderedCellIds);
	    };
	    // method makes sure the right cells are present, and are in the right container. so when this gets called for
	    // the first time, it sets up all the cells. but then over time the cells might appear / dissappear or move
	    // container (ie into pinned)
	    RenderedRow.prototype.refreshCellsIntoRow = function () {
	        var _this = this;
	        var columns = this.columnController.getAllDisplayedVirtualColumns();
	        var renderedCellKeys = Object.keys(this.renderedCells);
	        columns.forEach(function (column) {
	            var renderedCell = _this.getOrCreateCell(column);
	            _this.ensureCellInCorrectRow(renderedCell);
	            utils_1.Utils.removeFromArray(renderedCellKeys, column.getColId());
	        });
	        // remove old cells from gui, but we don't destroy them, we might use them again
	        this.removeRenderedCells(renderedCellKeys);
	    };
	    RenderedRow.prototype.removeRenderedCells = function (colIds) {
	        var _this = this;
	        colIds.forEach(function (key) {
	            var renderedCell = _this.renderedCells[key];
	            // could be old reference, ie removed cell
	            if (utils_1.Utils.missing(renderedCell)) {
	                return;
	            }
	            if (renderedCell.getParentRow()) {
	                renderedCell.getParentRow().removeChild(renderedCell.getGui());
	                renderedCell.setParentRow(null);
	            }
	            renderedCell.destroy();
	            _this.renderedCells[key] = null;
	        });
	    };
	    RenderedRow.prototype.ensureCellInCorrectRow = function (renderedCell) {
	        var eRowGui = renderedCell.getGui();
	        var column = renderedCell.getColumn();
	        var rowWeWant;
	        switch (column.getPinned()) {
	            case column_1.Column.PINNED_LEFT:
	                rowWeWant = this.ePinnedLeftRow;
	                break;
	            case column_1.Column.PINNED_RIGHT:
	                rowWeWant = this.ePinnedRightRow;
	                break;
	            default:
	                rowWeWant = this.eBodyRow;
	                break;
	        }
	        // if in wrong container, remove it
	        var oldRow = renderedCell.getParentRow();
	        var inWrongRow = oldRow !== rowWeWant;
	        if (inWrongRow) {
	            // take out from old row
	            if (oldRow) {
	                oldRow.removeChild(eRowGui);
	            }
	            rowWeWant.appendChild(eRowGui);
	            renderedCell.setParentRow(rowWeWant);
	        }
	    };
	    RenderedRow.prototype.getOrCreateCell = function (column) {
	        var colId = column.getColId();
	        if (this.renderedCells[colId]) {
	            return this.renderedCells[colId];
	        }
	        else {
	            var renderedCell = new renderedCell_1.RenderedCell(column, this.rowNode, this.scope, this);
	            this.context.wireBean(renderedCell);
	            this.renderedCells[colId] = renderedCell;
	            this.angular1Compile(renderedCell.getGui());
	            // if we are editing the row, then the cell needs to turn
	            // into edit mode
	            if (this.editingRow) {
	                renderedCell.startEditingIfEnabled();
	            }
	            return renderedCell;
	        }
	    };
	    RenderedRow.prototype.onRowSelected = function () {
	        var selected = this.rowNode.isSelected();
	        this.eAllRowContainers.forEach(function (row) { return utils_1.Utils.addOrRemoveCssClass(row, 'ag-row-selected', selected); });
	    };
	    RenderedRow.prototype.addRowSelectedListener = function () {
	        var _this = this;
	        var rowSelectedListener = this.onRowSelected.bind(this);
	        this.rowNode.addEventListener(rowNode_1.RowNode.EVENT_ROW_SELECTED, rowSelectedListener);
	        this.destroyFunctions.push(function () {
	            _this.rowNode.removeEventListener(rowNode_1.RowNode.EVENT_ROW_SELECTED, rowSelectedListener);
	        });
	    };
	    RenderedRow.prototype.onMouseEvent = function (eventName, mouseEvent) {
	        switch (eventName) {
	            case 'dblclick':
	                this.onRowDblClick(mouseEvent);
	                break;
	            case 'click':
	                this.onRowClick(mouseEvent);
	                break;
	        }
	    };
	    RenderedRow.prototype.addHoverFunctionality = function () {
	        var _this = this;
	        // because we are adding listeners to the row, we give the user the choice to not add
	        // the hover class, as it slows things down, especially in IE, when you add listeners
	        // to each row. we cannot do the trick of adding one listener to the GridPanel (like we
	        // do for other mouse events) as these events don't propogate
	        if (this.gridOptionsWrapper.isSuppressRowHoverClass()) {
	            return;
	        }
	        var onGuiMouseEnter = this.rowNode.onMouseEnter.bind(this.rowNode);
	        var onGuiMouseLeave = this.rowNode.onMouseLeave.bind(this.rowNode);
	        this.eAllRowContainers.forEach(function (eRow) {
	            eRow.addEventListener('mouseenter', onGuiMouseEnter);
	            eRow.addEventListener('mouseleave', onGuiMouseLeave);
	        });
	        var onNodeMouseEnter = this.addHoverClass.bind(this, true);
	        var onNodeMouseLeave = this.addHoverClass.bind(this, false);
	        this.rowNode.addEventListener(rowNode_1.RowNode.EVENT_MOUSE_ENTER, onNodeMouseEnter);
	        this.rowNode.addEventListener(rowNode_1.RowNode.EVENT_MOUSE_LEAVE, onNodeMouseLeave);
	        this.destroyFunctions.push(function () {
	            _this.eAllRowContainers.forEach(function (eRow) {
	                eRow.removeEventListener('mouseenter', onGuiMouseEnter);
	                eRow.removeEventListener('mouseleave', onGuiMouseLeave);
	            });
	            _this.rowNode.removeEventListener(rowNode_1.RowNode.EVENT_MOUSE_ENTER, onNodeMouseEnter);
	            _this.rowNode.removeEventListener(rowNode_1.RowNode.EVENT_MOUSE_LEAVE, onNodeMouseLeave);
	        });
	    };
	    RenderedRow.prototype.addHoverClass = function (hover) {
	        this.eAllRowContainers.forEach(function (eRow) { return utils_1.Utils.addOrRemoveCssClass(eRow, 'ag-row-hover', hover); });
	    };
	    RenderedRow.prototype.addCellFocusedListener = function () {
	        var _this = this;
	        var rowFocusedLastTime = null;
	        var rowFocusedListener = function () {
	            var rowFocused = _this.focusedCellController.isRowFocused(_this.rowNode.rowIndex, _this.rowNode.floating);
	            if (rowFocused !== rowFocusedLastTime) {
	                _this.eAllRowContainers.forEach(function (row) { return utils_1.Utils.addOrRemoveCssClass(row, 'ag-row-focus', rowFocused); });
	                _this.eAllRowContainers.forEach(function (row) { return utils_1.Utils.addOrRemoveCssClass(row, 'ag-row-no-focus', !rowFocused); });
	                rowFocusedLastTime = rowFocused;
	            }
	            if (!rowFocused && _this.editingRow) {
	                _this.stopEditing(false);
	            }
	        };
	        this.mainEventService.addEventListener(events_1.Events.EVENT_CELL_FOCUSED, rowFocusedListener);
	        this.destroyFunctions.push(function () {
	            _this.mainEventService.removeEventListener(events_1.Events.EVENT_CELL_FOCUSED, rowFocusedListener);
	        });
	        rowFocusedListener();
	    };
	    RenderedRow.prototype.forEachRenderedCell = function (callback) {
	        utils_1.Utils.iterateObject(this.renderedCells, function (key, renderedCell) {
	            if (renderedCell) {
	                callback(renderedCell);
	            }
	        });
	    };
	    RenderedRow.prototype.addNodeDataChangedListener = function () {
	        var _this = this;
	        var nodeDataChangedListener = function () {
	            var animate = false;
	            var newData = true;
	            _this.forEachRenderedCell(function (renderedCell) { return renderedCell.refreshCell(animate, newData); });
	            // check for selected also, as this could be after lazy loading of the row data, in which csae
	            // the id might of just gotten set inside the row and the row selected state may of changed
	            // as a result. this is what happens when selected rows are loaded in virtual pagination.
	            _this.onRowSelected();
	        };
	        this.rowNode.addEventListener(rowNode_1.RowNode.EVENT_DATA_CHANGED, nodeDataChangedListener);
	        this.destroyFunctions.push(function () {
	            _this.rowNode.removeEventListener(rowNode_1.RowNode.EVENT_DATA_CHANGED, nodeDataChangedListener);
	        });
	    };
	    RenderedRow.prototype.onTopChanged = function () {
	        // console.log(`top changed for ${this.rowNode.id} = ${this.rowNode.rowTop}`);
	        this.setRowTop(this.rowNode.rowTop);
	    };
	    RenderedRow.prototype.setRowTop = function (pixels) {
	        // need to make sure rowTop is not null, as this can happen if the node was once
	        // visible (ie parent group was expanded) but is now not visible
	        if (utils_1.Utils.exists(pixels)) {
	            var topPx = pixels + "px";
	            this.eAllRowContainers.forEach(function (row) { return row.style.top = topPx; });
	        }
	    };
	    RenderedRow.prototype.setupTop = function (animateInRowTop) {
	        var _this = this;
	        if (this.gridOptionsWrapper.isForPrint()) {
	            return;
	        }
	        var topChangedListener = this.onTopChanged.bind(this);
	        this.rowNode.addEventListener(rowNode_1.RowNode.EVENT_TOP_CHANGED, topChangedListener);
	        this.destroyFunctions.push(function () { return _this.rowNode.removeEventListener(rowNode_1.RowNode.EVENT_TOP_CHANGED, topChangedListener); });
	        if (!animateInRowTop) {
	            this.onTopChanged();
	        }
	    };
	    RenderedRow.prototype.setHeight = function () {
	        var _this = this;
	        var setHeightListener = function () {
	            // check for exists first - if the user is resetting the row height, then
	            // it will be null (or undefined) momentarily until the next time the flatten
	            // stage is called where the row will then update again with a new height
	            if (utils_1.Utils.exists(_this.rowNode.rowHeight)) {
	                var heightPx = _this.rowNode.rowHeight + 'px';
	                _this.eAllRowContainers.forEach(function (row) { return row.style.height = heightPx; });
	            }
	        };
	        this.rowNode.addEventListener(rowNode_1.RowNode.EVENT_HEIGHT_CHANGED, setHeightListener);
	        this.destroyFunctions.push(function () { return _this.rowNode.removeEventListener(rowNode_1.RowNode.EVENT_HEIGHT_CHANGED, setHeightListener); });
	        setHeightListener();
	    };
	    RenderedRow.prototype.addRowIndexes = function () {
	        var _this = this;
	        var rowIndexListener = function () {
	            var rowStr = _this.rowNode.rowIndex.toString();
	            if (_this.rowNode.floating === constants_1.Constants.FLOATING_BOTTOM) {
	                rowStr = 'fb-' + rowStr;
	            }
	            else if (_this.rowNode.floating === constants_1.Constants.FLOATING_TOP) {
	                rowStr = 'ft-' + rowStr;
	            }
	            _this.eAllRowContainers.forEach(function (eRow) {
	                eRow.setAttribute('row', rowStr);
	                var rowIsEven = _this.rowNode.rowIndex % 2 === 0;
	                utils_1.Utils.addOrRemoveCssClass(eRow, 'ag-row-even', rowIsEven);
	                utils_1.Utils.addOrRemoveCssClass(eRow, 'ag-row-odd', !rowIsEven);
	            });
	        };
	        this.rowNode.addEventListener(rowNode_1.RowNode.EVENT_ROW_INDEX_CHANGED, rowIndexListener);
	        this.destroyFunctions.push(function () { return _this.rowNode.removeEventListener(rowNode_1.RowNode.EVENT_ROW_INDEX_CHANGED, rowIndexListener); });
	        rowIndexListener();
	    };
	    // adds in row and row-id attributes to the row
	    RenderedRow.prototype.addRowIds = function () {
	        if (typeof this.gridOptionsWrapper.getBusinessKeyForNodeFunc() === 'function') {
	            var businessKey = this.gridOptionsWrapper.getBusinessKeyForNodeFunc()(this.rowNode);
	            if (typeof businessKey === 'string' || typeof businessKey === 'number') {
	                this.eAllRowContainers.forEach(function (row) { return row.setAttribute('row-id', businessKey); });
	            }
	        }
	    };
	    RenderedRow.prototype.addEventListener = function (eventType, listener) {
	        if (!this.renderedRowEventService) {
	            this.renderedRowEventService = new eventService_1.EventService();
	        }
	        this.renderedRowEventService.addEventListener(eventType, listener);
	    };
	    RenderedRow.prototype.removeEventListener = function (eventType, listener) {
	        this.renderedRowEventService.removeEventListener(eventType, listener);
	    };
	    RenderedRow.prototype.getRenderedCellForColumn = function (column) {
	        return this.renderedCells[column.getColId()];
	    };
	    RenderedRow.prototype.getCellForCol = function (column) {
	        var renderedCell = this.renderedCells[column.getColId()];
	        if (renderedCell) {
	            return renderedCell.getGui();
	        }
	        else {
	            return null;
	        }
	    };
	    RenderedRow.prototype.destroy = function (animate) {
	        if (animate === void 0) { animate = false; }
	        this.destroyScope();
	        this.destroyFullWidthComponent();
	        this.forEachRenderedCell(function (renderedCell) { return renderedCell.destroy(); });
	        this.destroyFunctions.forEach(function (func) { return func(); });
	        if (animate) {
	            this.startRemoveAnimationFunctions.forEach(function (func) { return func(); });
	        }
	        else {
	            // we are not animating, so execute the second stage of removal now.
	            // we call getAndClear, so that they are only called once
	            var delayedDestroyFunctions = this.getAndClearDelayedDestroyFunctions();
	            delayedDestroyFunctions.forEach(function (func) { return func(); });
	        }
	        if (this.renderedRowEventService) {
	            this.renderedRowEventService.dispatchEvent(RenderedRow.EVENT_RENDERED_ROW_REMOVED, { node: this.rowNode });
	        }
	        var event = { node: this.rowNode, rowIndex: this.rowNode.rowIndex };
	        this.mainEventService.dispatchEvent(events_1.Events.EVENT_VIRTUAL_ROW_REMOVED, event);
	    };
	    RenderedRow.prototype.destroyScope = function () {
	        if (this.scope) {
	            this.scope.$destroy();
	            this.scope = null;
	        }
	    };
	    RenderedRow.prototype.isDataInList = function (rows) {
	        return rows.indexOf(this.rowNode.data) >= 0;
	    };
	    RenderedRow.prototype.isGroup = function () {
	        return this.rowNode.group === true;
	    };
	    RenderedRow.prototype.refreshFullWidthComponent = function () {
	        this.destroyFullWidthComponent();
	        this.createFullWidthComponent();
	    };
	    RenderedRow.prototype.createFullWidthComponent = function () {
	        var params = this.createFullWidthParams(this.eFullWidthRow);
	        this.fullWidthRowComponent = this.cellRendererService.useCellRenderer(this.fullWidthCellRenderer, this.eFullWidthRow, params);
	        this.angular1Compile(this.eFullWidthRow);
	    };
	    RenderedRow.prototype.destroyFullWidthComponent = function () {
	        if (this.fullWidthRowComponent) {
	            if (this.fullWidthRowComponent.destroy) {
	                this.fullWidthRowComponent.destroy();
	            }
	            this.fullWidthRowComponent = null;
	        }
	        utils_1.Utils.removeAllChildren(this.eFullWidthRow);
	    };
	    RenderedRow.prototype.createFullWidthParams = function (eRow) {
	        var params = {
	            data: this.rowNode.data,
	            node: this.rowNode,
	            $scope: this.scope,
	            rowIndex: this.rowNode.rowIndex,
	            api: this.gridOptionsWrapper.getApi(),
	            columnApi: this.gridOptionsWrapper.getColumnApi(),
	            context: this.gridOptionsWrapper.getContext(),
	            eGridCell: eRow,
	            eParentOfValue: eRow,
	            addRenderedRowListener: this.addEventListener.bind(this),
	            colDef: {
	                cellRenderer: this.fullWidthCellRenderer,
	                cellRendererParams: this.fullWidthCellRendererParams
	            }
	        };
	        if (this.fullWidthCellRendererParams) {
	            utils_1.Utils.assign(params, this.fullWidthCellRendererParams);
	        }
	        return params;
	    };
	    RenderedRow.prototype.createGroupSpanningEntireRowCell = function (padding) {
	        var eRow = document.createElement('span');
	        // padding means we are on the right hand side of a pinned table, ie
	        // in the main body.
	        if (!padding) {
	            var params = this.createFullWidthParams(eRow);
	            var cellComponent = this.cellRendererService.useCellRenderer(this.fullWidthCellRenderer, eRow, params);
	            if (cellComponent && cellComponent.destroy) {
	                this.destroyFunctions.push(function () { return cellComponent.destroy(); });
	            }
	        }
	        if (this.rowNode.footer) {
	            utils_1.Utils.addCssClass(eRow, 'ag-footer-cell-entire-row');
	        }
	        else {
	            utils_1.Utils.addCssClass(eRow, 'ag-group-cell-entire-row');
	        }
	        return eRow;
	    };
	    RenderedRow.prototype.createChildScopeOrNull = function (data) {
	        if (this.gridOptionsWrapper.isAngularCompileRows()) {
	            var newChildScope = this.parentScope.$new();
	            newChildScope.data = data;
	            newChildScope.rowNode = this.rowNode;
	            newChildScope.context = this.gridOptionsWrapper.getContext();
	            return newChildScope;
	        }
	        else {
	            return null;
	        }
	    };
	    RenderedRow.prototype.addStyleFromRowStyle = function () {
	        var rowStyle = this.gridOptionsWrapper.getRowStyle();
	        if (rowStyle) {
	            if (typeof rowStyle === 'function') {
	                console.log('ag-Grid: rowStyle should be an object of key/value styles, not be a function, use getRowStyle() instead');
	            }
	            else {
	                this.eAllRowContainers.forEach(function (row) { return utils_1.Utils.addStylesToElement(row, rowStyle); });
	            }
	        }
	    };
	    RenderedRow.prototype.addStyleFromRowStyleFunc = function () {
	        var rowStyleFunc = this.gridOptionsWrapper.getRowStyleFunc();
	        if (rowStyleFunc) {
	            var params = {
	                data: this.rowNode.data,
	                node: this.rowNode,
	                api: this.gridOptionsWrapper.getApi(),
	                context: this.gridOptionsWrapper.getContext(),
	                $scope: this.scope
	            };
	            var cssToUseFromFunc = rowStyleFunc(params);
	            this.eAllRowContainers.forEach(function (row) { return utils_1.Utils.addStylesToElement(row, cssToUseFromFunc); });
	        }
	    };
	    RenderedRow.prototype.createParams = function () {
	        var params = {
	            node: this.rowNode,
	            data: this.rowNode.data,
	            rowIndex: this.rowNode.rowIndex,
	            $scope: this.scope,
	            context: this.gridOptionsWrapper.getContext(),
	            api: this.gridOptionsWrapper.getApi()
	        };
	        return params;
	    };
	    RenderedRow.prototype.createEvent = function (event, eventSource) {
	        var agEvent = this.createParams();
	        agEvent.event = event;
	        agEvent.eventSource = eventSource;
	        return agEvent;
	    };
	    RenderedRow.prototype.createRowContainer = function (eParentDF, eParent, slideRowIn) {
	        var _this = this;
	        var eRow = document.createElement('div');
	        this.addDomData(eRow);
	        var eTarget = eParentDF ? eParentDF : eParent;
	        eTarget.appendChild(eRow);
	        this.eAllRowContainers.push(eRow);
	        this.delayedDestroyFunctions.push(function () {
	            eParent.removeChild(eRow);
	        });
	        this.startRemoveAnimationFunctions.push(function () {
	            utils_1.Utils.addCssClass(eRow, 'ag-opacity-zero');
	            if (utils_1.Utils.exists(_this.rowNode.rowTop)) {
	                var rowTop = _this.roundRowTopToBounds(_this.rowNode.rowTop);
	                _this.setRowTop(rowTop);
	            }
	            // _.prepend(eParent, eRow);
	        });
	        if (this.animateIn) {
	            this.animateRowIn(eRow, slideRowIn);
	        }
	        return eRow;
	    };
	    // puts animation into the row by setting start state and then final state in another VM turn
	    // (another VM turn so the rendering engine will kick off once with start state, and then transition
	    // into the end state)
	    RenderedRow.prototype.animateRowIn = function (eRow, slideRowIn) {
	        if (slideRowIn) {
	            // for sliding the row in, we position the row in it's old position first
	            var rowTop = this.roundRowTopToBounds(this.rowNode.oldRowTop);
	            this.setRowTop(rowTop);
	            // and then update the position to it's new position
	            this.nextVmTurnFunctions.push(this.onTopChanged.bind(this));
	        }
	        else {
	            // for fading in, we first set it invisible
	            utils_1.Utils.addCssClass(eRow, 'ag-opacity-zero');
	            // and then transition to visible
	            this.nextVmTurnFunctions.push(function () { return utils_1.Utils.removeCssClass(eRow, 'ag-opacity-zero'); });
	        }
	    };
	    // for animation, we don't want to animate entry or exit to a very far away pixel,
	    // otherwise the row would move so fast, it would appear to disappear. so this method
	    // moves the row closer to the viewport if it is far away, so the row slide in / out
	    // at a speed the user can see.
	    RenderedRow.prototype.roundRowTopToBounds = function (rowTop) {
	        var minPixel = this.gridPanel.getBodyTopPixel() - 100;
	        var maxPixel = this.gridPanel.getBodyBottomPixel() + 100;
	        if (rowTop < minPixel) {
	            return minPixel;
	        }
	        else if (rowTop > maxPixel) {
	            return maxPixel;
	        }
	        else {
	            return rowTop;
	        }
	    };
	    RenderedRow.prototype.onRowDblClick = function (event) {
	        var agEvent = this.createEvent(event, this);
	        this.mainEventService.dispatchEvent(events_1.Events.EVENT_ROW_DOUBLE_CLICKED, agEvent);
	    };
	    RenderedRow.prototype.onRowClick = function (event) {
	        var agEvent = this.createEvent(event, this);
	        this.mainEventService.dispatchEvent(events_1.Events.EVENT_ROW_CLICKED, agEvent);
	        // ctrlKey for windows, metaKey for Apple
	        var multiSelectKeyPressed = event.ctrlKey || event.metaKey;
	        var shiftKeyPressed = event.shiftKey;
	        // we do not allow selecting groups by clicking (as the click here expands the group)
	        // so return if it's a group row
	        if (this.rowNode.group) {
	            return;
	        }
	        // we also don't allow selection of floating rows
	        if (this.rowNode.floating) {
	            return;
	        }
	        // making local variables to make the below more readable
	        var gridOptionsWrapper = this.gridOptionsWrapper;
	        // if no selection method enabled, do nothing
	        if (!gridOptionsWrapper.isRowSelection()) {
	            return;
	        }
	        // if click selection suppressed, do nothing
	        if (gridOptionsWrapper.isSuppressRowClickSelection()) {
	            return;
	        }
	        if (this.rowNode.isSelected()) {
	            if (multiSelectKeyPressed) {
	                if (gridOptionsWrapper.isRowDeselection()) {
	                    this.rowNode.setSelectedParams({ newValue: false });
	                }
	            }
	            else {
	                // selected with no multi key, must make sure anything else is unselected
	                this.rowNode.setSelectedParams({ newValue: true, clearSelection: true });
	            }
	        }
	        else {
	            this.rowNode.setSelectedParams({ newValue: true, clearSelection: !multiSelectKeyPressed, rangeSelect: shiftKeyPressed });
	        }
	    };
	    RenderedRow.prototype.getRowNode = function () {
	        return this.rowNode;
	    };
	    RenderedRow.prototype.refreshCells = function (colIds, animate) {
	        if (!colIds) {
	            return;
	        }
	        var columnsToRefresh = this.columnController.getGridColumns(colIds);
	        this.forEachRenderedCell(function (renderedCell) {
	            var colForCel = renderedCell.getColumn();
	            if (columnsToRefresh.indexOf(colForCel) >= 0) {
	                renderedCell.refreshCell(animate);
	            }
	        });
	    };
	    RenderedRow.prototype.addClassesFromRowClassFunc = function () {
	        var _this = this;
	        var classes = [];
	        var gridOptionsRowClassFunc = this.gridOptionsWrapper.getRowClassFunc();
	        if (gridOptionsRowClassFunc) {
	            var params = {
	                node: this.rowNode,
	                data: this.rowNode.data,
	                rowIndex: this.rowNode.rowIndex,
	                context: this.gridOptionsWrapper.getContext(),
	                api: this.gridOptionsWrapper.getApi()
	            };
	            var classToUseFromFunc = gridOptionsRowClassFunc(params);
	            if (classToUseFromFunc) {
	                if (typeof classToUseFromFunc === 'string') {
	                    classes.push(classToUseFromFunc);
	                }
	                else if (Array.isArray(classToUseFromFunc)) {
	                    classToUseFromFunc.forEach(function (classItem) {
	                        classes.push(classItem);
	                    });
	                }
	            }
	        }
	        classes.forEach(function (classStr) {
	            _this.eAllRowContainers.forEach(function (row) { return utils_1.Utils.addCssClass(row, classStr); });
	        });
	    };
	    RenderedRow.prototype.addGridClasses = function () {
	        var _this = this;
	        var classes = [];
	        classes.push('ag-row');
	        classes.push('ag-row-no-focus');
	        if (this.gridOptionsWrapper.isAnimateRows()) {
	            classes.push('ag-row-animation');
	        }
	        else {
	            classes.push('ag-row-no-animation');
	        }
	        if (this.rowNode.isSelected()) {
	            classes.push('ag-row-selected');
	        }
	        if (this.rowNode.group) {
	            classes.push('ag-row-group');
	            // if a group, put the level of the group in
	            classes.push('ag-row-level-' + this.rowNode.level);
	            if (!this.rowNode.footer && this.rowNode.expanded) {
	                classes.push('ag-row-group-expanded');
	            }
	            if (!this.rowNode.footer && !this.rowNode.expanded) {
	                // opposite of expanded is contracted according to the internet.
	                classes.push('ag-row-group-contracted');
	            }
	            if (this.rowNode.footer) {
	                classes.push('ag-row-footer');
	            }
	        }
	        else {
	            // if a leaf, and a parent exists, put a level of the parent, else put level of 0 for top level item
	            if (this.rowNode.parent) {
	                classes.push('ag-row-level-' + (this.rowNode.parent.level + 1));
	            }
	            else {
	                classes.push('ag-row-level-0');
	            }
	        }
	        if (this.fullWidthRow) {
	            classes.push('ag-full-width-row');
	        }
	        classes.forEach(function (classStr) {
	            _this.eAllRowContainers.forEach(function (row) { return utils_1.Utils.addCssClass(row, classStr); });
	        });
	    };
	    RenderedRow.prototype.addClassesFromRowClass = function () {
	        var _this = this;
	        var classes = [];
	        // add in extra classes provided by the config
	        var gridOptionsRowClass = this.gridOptionsWrapper.getRowClass();
	        if (gridOptionsRowClass) {
	            if (typeof gridOptionsRowClass === 'function') {
	                console.warn('ag-Grid: rowClass should not be a function, please use getRowClass instead');
	            }
	            else {
	                if (typeof gridOptionsRowClass === 'string') {
	                    classes.push(gridOptionsRowClass);
	                }
	                else if (Array.isArray(gridOptionsRowClass)) {
	                    gridOptionsRowClass.forEach(function (classItem) {
	                        classes.push(classItem);
	                    });
	                }
	            }
	        }
	        classes.forEach(function (classStr) {
	            _this.eAllRowContainers.forEach(function (row) { return utils_1.Utils.addCssClass(row, classStr); });
	        });
	    };
	    RenderedRow.EVENT_RENDERED_ROW_REMOVED = 'renderedRowRemoved';
	    __decorate([
	        context_1.Autowired('gridOptionsWrapper'), 
	        __metadata('design:type', gridOptionsWrapper_1.GridOptionsWrapper)
	    ], RenderedRow.prototype, "gridOptionsWrapper", void 0);
	    __decorate([
	        context_1.Autowired('columnController'), 
	        __metadata('design:type', columnController_1.ColumnController)
	    ], RenderedRow.prototype, "columnController", void 0);
	    __decorate([
	        context_1.Autowired('$compile'), 
	        __metadata('design:type', Object)
	    ], RenderedRow.prototype, "$compile", void 0);
	    __decorate([
	        context_1.Autowired('eventService'), 
	        __metadata('design:type', eventService_1.EventService)
	    ], RenderedRow.prototype, "mainEventService", void 0);
	    __decorate([
	        context_1.Autowired('context'), 
	        __metadata('design:type', context_1.Context)
	    ], RenderedRow.prototype, "context", void 0);
	    __decorate([
	        context_1.Autowired('focusedCellController'), 
	        __metadata('design:type', focusedCellController_1.FocusedCellController)
	    ], RenderedRow.prototype, "focusedCellController", void 0);
	    __decorate([
	        context_1.Autowired('cellRendererService'), 
	        __metadata('design:type', cellRendererService_1.CellRendererService)
	    ], RenderedRow.prototype, "cellRendererService", void 0);
	    __decorate([
	        context_1.Autowired('gridPanel'), 
	        __metadata('design:type', gridPanel_1.GridPanel)
	    ], RenderedRow.prototype, "gridPanel", void 0);
	    __decorate([
	        context_1.PostConstruct, 
	        __metadata('design:type', Function), 
	        __metadata('design:paramtypes', []), 
	        __metadata('design:returntype', void 0)
	    ], RenderedRow.prototype, "init", null);
	    return RenderedRow;
	})();
	exports.RenderedRow = RenderedRow;


/***/ },
/* 38 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
	 * @version v7.0.2
	 * @link http://www.ag-grid.com/
	 * @license MIT
	 */
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var utils_1 = __webpack_require__(7);
	var column_1 = __webpack_require__(15);
	var rowNode_1 = __webpack_require__(27);
	var gridOptionsWrapper_1 = __webpack_require__(3);
	var expressionService_1 = __webpack_require__(18);
	var rowRenderer_1 = __webpack_require__(23);
	var templateService_1 = __webpack_require__(36);
	var columnController_1 = __webpack_require__(13);
	var valueService_1 = __webpack_require__(29);
	var eventService_1 = __webpack_require__(4);
	var constants_1 = __webpack_require__(8);
	var events_1 = __webpack_require__(10);
	var context_1 = __webpack_require__(6);
	var gridApi_1 = __webpack_require__(11);
	var focusedCellController_1 = __webpack_require__(35);
	var gridCell_1 = __webpack_require__(33);
	var focusService_1 = __webpack_require__(39);
	var cellEditorFactory_1 = __webpack_require__(48);
	var component_1 = __webpack_require__(47);
	var popupService_1 = __webpack_require__(44);
	var cellRendererFactory_1 = __webpack_require__(55);
	var cellRendererService_1 = __webpack_require__(60);
	var valueFormatterService_1 = __webpack_require__(61);
	var checkboxSelectionComponent_1 = __webpack_require__(62);
	var setLeftFeature_1 = __webpack_require__(63);
	var methodNotImplementedException_1 = __webpack_require__(64);
	var RenderedCell = (function (_super) {
	    __extends(RenderedCell, _super);
	    function RenderedCell(column, node, scope, renderedRow) {
	        _super.call(this, '<div/>');
	        // set to null, not false, as we need to set 'ag-cell-no-focus' first time around
	        this.cellFocused = null;
	        this.firstRightPinned = false;
	        this.lastLeftPinned = false;
	        // because we reference eGridCell everywhere in this class,
	        // we keep a local reference
	        this.eGridCell = this.getGui();
	        this.column = column;
	        this.node = node;
	        this.scope = scope;
	        this.renderedRow = renderedRow;
	        this.setupGridCell();
	    }
	    RenderedCell.prototype.createGridCell = function () {
	        this.gridCell = new gridCell_1.GridCell(this.node.rowIndex, this.node.floating, this.column);
	    };
	    RenderedCell.prototype.setupGridCell = function () {
	        var _this = this;
	        var listener = function () {
	            // when index changes, this influences items that need the index, so we update the
	            // grid cell so they are working off the new index.
	            _this.createGridCell();
	            // when the index of the row changes, ie means the cell may have lost of gained focus
	            _this.checkCellFocused();
	        };
	        this.addDestroyableEventListener(this.node, rowNode_1.RowNode.EVENT_ROW_INDEX_CHANGED, listener);
	        this.createGridCell();
	    };
	    RenderedCell.prototype.getGridCell = function () {
	        return this.gridCell;
	    };
	    RenderedCell.prototype.setFocusInOnEditor = function () {
	        if (this.editingCell && this.cellEditor && this.cellEditor.focusIn) {
	            this.cellEditor.focusIn();
	        }
	    };
	    RenderedCell.prototype.setFocusOutOnEditor = function () {
	        if (this.editingCell && this.cellEditor && this.cellEditor.focusOut) {
	            this.cellEditor.focusOut();
	        }
	    };
	    RenderedCell.prototype.destroy = function () {
	        _super.prototype.destroy.call(this);
	        if (this.cellEditor && this.cellEditor.destroy) {
	            this.cellEditor.destroy();
	        }
	        if (this.cellRenderer && this.cellRenderer.destroy) {
	            this.cellRenderer.destroy();
	        }
	    };
	    RenderedCell.prototype.setPinnedClasses = function () {
	        var _this = this;
	        var firstPinnedChangedListener = function () {
	            if (_this.firstRightPinned !== _this.column.isFirstRightPinned()) {
	                _this.firstRightPinned = _this.column.isFirstRightPinned();
	                utils_1.Utils.addOrRemoveCssClass(_this.eGridCell, 'ag-cell-first-right-pinned', _this.firstRightPinned);
	            }
	            if (_this.lastLeftPinned !== _this.column.isLastLeftPinned()) {
	                _this.lastLeftPinned = _this.column.isLastLeftPinned();
	                utils_1.Utils.addOrRemoveCssClass(_this.eGridCell, 'ag-cell-last-left-pinned', _this.lastLeftPinned);
	            }
	        };
	        this.column.addEventListener(column_1.Column.EVENT_FIRST_RIGHT_PINNED_CHANGED, firstPinnedChangedListener);
	        this.column.addEventListener(column_1.Column.EVENT_LAST_LEFT_PINNED_CHANGED, firstPinnedChangedListener);
	        this.addDestroyFunc(function () {
	            _this.column.removeEventListener(column_1.Column.EVENT_FIRST_RIGHT_PINNED_CHANGED, firstPinnedChangedListener);
	            _this.column.removeEventListener(column_1.Column.EVENT_LAST_LEFT_PINNED_CHANGED, firstPinnedChangedListener);
	        });
	        firstPinnedChangedListener();
	    };
	    RenderedCell.prototype.getParentRow = function () {
	        return this.eParentRow;
	    };
	    RenderedCell.prototype.setParentRow = function (eParentRow) {
	        this.eParentRow = eParentRow;
	    };
	    RenderedCell.prototype.calculateCheckboxSelection = function () {
	        // never allow selection on floating rows
	        if (this.node.floating) {
	            return false;
	        }
	        // if boolean set, then just use it
	        var colDef = this.column.getColDef();
	        if (typeof colDef.checkboxSelection === 'boolean') {
	            return colDef.checkboxSelection;
	        }
	        // if function, then call the function to find out. we first check colDef for
	        // a function, and if missing then check gridOptions, so colDef has precedence
	        var selectionFunc;
	        if (typeof colDef.checkboxSelection === 'function') {
	            selectionFunc = colDef.checkboxSelection;
	        }
	        if (!selectionFunc && this.gridOptionsWrapper.getCheckboxSelection()) {
	            selectionFunc = this.gridOptionsWrapper.getCheckboxSelection();
	        }
	        if (selectionFunc) {
	            var params = this.createParams();
	            return selectionFunc(params);
	        }
	        return false;
	    };
	    RenderedCell.prototype.getColumn = function () {
	        return this.column;
	    };
	    RenderedCell.prototype.getValue = function () {
	        var data = this.getDataForRow();
	        return this.valueService.getValueUsingSpecificData(this.column, data, this.node);
	    };
	    RenderedCell.prototype.getDataForRow = function () {
	        if (this.node.footer) {
	            // if footer, we always show the data
	            return this.node.data;
	        }
	        else if (this.node.group) {
	            // if header and header is expanded, we show data in footer only
	            var footersEnabled = this.gridOptionsWrapper.isGroupIncludeFooter();
	            var suppressHideHeader = this.gridOptionsWrapper.isGroupSuppressBlankHeader();
	            if (this.node.expanded && footersEnabled && !suppressHideHeader) {
	                return undefined;
	            }
	            else {
	                return this.node.data;
	            }
	        }
	        else {
	            // otherwise it's a normal node, just return data as normal
	            return this.node.data;
	        }
	    };
	    RenderedCell.prototype.addRangeSelectedListener = function () {
	        var _this = this;
	        if (!this.rangeController) {
	            return;
	        }
	        var rangeCountLastTime = 0;
	        var rangeSelectedListener = function () {
	            var rangeCount = _this.rangeController.getCellRangeCount(_this.gridCell);
	            if (rangeCountLastTime !== rangeCount) {
	                utils_1.Utils.addOrRemoveCssClass(_this.eGridCell, 'ag-cell-range-selected', rangeCount !== 0);
	                utils_1.Utils.addOrRemoveCssClass(_this.eGridCell, 'ag-cell-range-selected-1', rangeCount === 1);
	                utils_1.Utils.addOrRemoveCssClass(_this.eGridCell, 'ag-cell-range-selected-2', rangeCount === 2);
	                utils_1.Utils.addOrRemoveCssClass(_this.eGridCell, 'ag-cell-range-selected-3', rangeCount === 3);
	                utils_1.Utils.addOrRemoveCssClass(_this.eGridCell, 'ag-cell-range-selected-4', rangeCount >= 4);
	                rangeCountLastTime = rangeCount;
	            }
	        };
	        this.eventService.addEventListener(events_1.Events.EVENT_RANGE_SELECTION_CHANGED, rangeSelectedListener);
	        this.addDestroyFunc(function () {
	            _this.eventService.removeEventListener(events_1.Events.EVENT_RANGE_SELECTION_CHANGED, rangeSelectedListener);
	        });
	        rangeSelectedListener();
	    };
	    RenderedCell.prototype.addHighlightListener = function () {
	        var _this = this;
	        if (!this.rangeController) {
	            return;
	        }
	        var clipboardListener = function (event) {
	            var cellId = _this.gridCell.createId();
	            var shouldFlash = event.cells[cellId];
	            if (shouldFlash) {
	                _this.animateCellWithHighlight();
	            }
	        };
	        this.eventService.addEventListener(events_1.Events.EVENT_FLASH_CELLS, clipboardListener);
	        this.addDestroyFunc(function () {
	            _this.eventService.removeEventListener(events_1.Events.EVENT_FLASH_CELLS, clipboardListener);
	        });
	    };
	    RenderedCell.prototype.addChangeListener = function () {
	        var _this = this;
	        var cellChangeListener = function (event) {
	            if (event.column === _this.column) {
	                _this.refreshCell();
	                _this.animateCellWithDataChanged();
	            }
	        };
	        this.addDestroyableEventListener(this.node, rowNode_1.RowNode.EVENT_CELL_CHANGED, cellChangeListener);
	    };
	    RenderedCell.prototype.animateCellWithDataChanged = function () {
	        if (this.gridOptionsWrapper.isEnableCellChangeFlash() || this.column.getColDef().enableCellChangeFlash) {
	            this.animateCell('data-changed');
	        }
	    };
	    RenderedCell.prototype.animateCellWithHighlight = function () {
	        this.animateCell('highlight');
	    };
	    RenderedCell.prototype.animateCell = function (cssName) {
	        var _this = this;
	        var fullName = 'ag-cell-' + cssName;
	        var animationFullName = 'ag-cell-' + cssName + '-animation';
	        // we want to highlight the cells, without any animation
	        utils_1.Utils.addCssClass(this.eGridCell, fullName);
	        utils_1.Utils.removeCssClass(this.eGridCell, animationFullName);
	        // then once that is applied, we remove the highlight with animation
	        setTimeout(function () {
	            utils_1.Utils.removeCssClass(_this.eGridCell, fullName);
	            utils_1.Utils.addCssClass(_this.eGridCell, animationFullName);
	            setTimeout(function () {
	                // and then to leave things as we got them, we remove the animation
	                utils_1.Utils.removeCssClass(_this.eGridCell, animationFullName);
	            }, 1000);
	        }, 500);
	    };
	    RenderedCell.prototype.addCellFocusedListener = function () {
	        var _this = this;
	        var cellFocusedListener = this.checkCellFocused.bind(this);
	        this.eventService.addEventListener(events_1.Events.EVENT_CELL_FOCUSED, cellFocusedListener);
	        this.addDestroyFunc(function () {
	            _this.eventService.removeEventListener(events_1.Events.EVENT_CELL_FOCUSED, cellFocusedListener);
	        });
	        cellFocusedListener();
	    };
	    RenderedCell.prototype.checkCellFocused = function (event) {
	        var cellFocused = this.focusedCellController.isCellFocused(this.gridCell);
	        // see if we need to change the classes on this cell
	        if (cellFocused !== this.cellFocused) {
	            utils_1.Utils.addOrRemoveCssClass(this.eGridCell, 'ag-cell-focus', cellFocused);
	            utils_1.Utils.addOrRemoveCssClass(this.eGridCell, 'ag-cell-no-focus', !cellFocused);
	            this.cellFocused = cellFocused;
	        }
	        // if this cell was just focused, see if we need to force browser focus, his can
	        // happen if focus is programmatically set.
	        if (cellFocused && event && event.forceBrowserFocus) {
	            this.eGridCell.focus();
	        }
	        // if another cell was focused, and we are editing, then stop editing
	        var fullRowEdit = this.gridOptionsWrapper.isFullRowEdit();
	        if (!cellFocused && !fullRowEdit && this.editingCell) {
	            this.stopRowOrCellEdit();
	        }
	    };
	    RenderedCell.prototype.setWidthOnCell = function () {
	        var _this = this;
	        var widthChangedListener = function () {
	            _this.eGridCell.style.width = _this.column.getActualWidth() + "px";
	        };
	        this.column.addEventListener(column_1.Column.EVENT_WIDTH_CHANGED, widthChangedListener);
	        this.addDestroyFunc(function () {
	            _this.column.removeEventListener(column_1.Column.EVENT_WIDTH_CHANGED, widthChangedListener);
	        });
	        widthChangedListener();
	    };
	    RenderedCell.prototype.init = function () {
	        this.value = this.getValue();
	        this.checkboxSelection = this.calculateCheckboxSelection();
	        this.setWidthOnCell();
	        this.setPinnedClasses();
	        this.addRangeSelectedListener();
	        this.addHighlightListener();
	        this.addChangeListener();
	        this.addCellFocusedListener();
	        this.addDomData();
	        // this.addSuppressShortcutKeyListenersWhileEditing();
	        var setLeftFeature = new setLeftFeature_1.SetLeftFeature(this.column, this.eGridCell);
	        this.addDestroyFunc(setLeftFeature.destroy.bind(setLeftFeature));
	        // only set tab index if cell selection is enabled
	        if (!this.gridOptionsWrapper.isSuppressCellSelection()) {
	            this.eGridCell.setAttribute("tabindex", "-1");
	        }
	        // these are the grid styles, don't change between soft refreshes
	        this.addClasses();
	        this.setInlineEditingClass();
	        this.createParentOfValue();
	        this.populateCell();
	    };
	    RenderedCell.prototype.addDomData = function () {
	        var domDataKey = this.gridOptionsWrapper.getDomDataKey();
	        var gridCellNoType = this.eGridCell;
	        gridCellNoType[domDataKey] = {
	            renderedCell: this
	        };
	        this.addDestroyFunc(function () { return gridCellNoType[domDataKey] = null; });
	    };
	    RenderedCell.prototype.onEnterKeyDown = function () {
	        if (this.editingCell) {
	            this.stopRowOrCellEdit();
	            this.focusCell(true);
	        }
	        else {
	            this.startRowOrCellEdit(constants_1.Constants.KEY_ENTER);
	        }
	    };
	    RenderedCell.prototype.onF2KeyDown = function () {
	        if (!this.editingCell) {
	            this.startRowOrCellEdit(constants_1.Constants.KEY_F2);
	        }
	    };
	    RenderedCell.prototype.onEscapeKeyDown = function () {
	        if (this.editingCell) {
	            this.stopRowOrCellEdit(true);
	            this.focusCell(true);
	        }
	    };
	    RenderedCell.prototype.onPopupEditorClosed = function () {
	        if (this.editingCell) {
	            this.stopRowOrCellEdit(true);
	            // we only focus cell again if this cell is still focused. it is possible
	            // it is not focused if the user cancelled the edit by clicking on another
	            // cell outside of this one
	            if (this.focusedCellController.isCellFocused(this.gridCell)) {
	                this.focusCell(true);
	            }
	        }
	    };
	    RenderedCell.prototype.isEditing = function () {
	        return this.editingCell;
	    };
	    RenderedCell.prototype.onTabKeyDown = function (event) {
	        this.rowRenderer.onTabKeyDown(this, event);
	    };
	    RenderedCell.prototype.onBackspaceOrDeleteKeyPressed = function (key) {
	        if (!this.editingCell) {
	            this.startRowOrCellEdit(key);
	        }
	    };
	    RenderedCell.prototype.onSpaceKeyPressed = function (event) {
	        if (!this.editingCell && this.gridOptionsWrapper.isRowSelection()) {
	            var selected = this.node.isSelected();
	            this.node.setSelected(!selected);
	        }
	        // prevent default as space key, by default, moves browser scroll down
	        event.preventDefault();
	    };
	    RenderedCell.prototype.onNavigationKeyPressed = function (event, key) {
	        if (this.editingCell) {
	            this.stopRowOrCellEdit();
	        }
	        this.rowRenderer.navigateToNextCell(key, this.gridCell.rowIndex, this.column, this.node.floating);
	        // if we don't prevent default, the grid will scroll with the navigation keys
	        event.preventDefault();
	    };
	    RenderedCell.prototype.onKeyPress = function (event) {
	        // check this, in case focus is on a (for example) a text field inside the cell,
	        // in which cse we should not be listening for these key pressed
	        var eventTarget = utils_1.Utils.getTarget(event);
	        var eventOnChildComponent = eventTarget !== this.getGui();
	        if (eventOnChildComponent) {
	            return;
	        }
	        if (!this.editingCell) {
	            var pressedChar = String.fromCharCode(event.charCode);
	            if (pressedChar === ' ') {
	                this.onSpaceKeyPressed(event);
	            }
	            else {
	                if (RenderedCell.PRINTABLE_CHARACTERS.indexOf(pressedChar) >= 0) {
	                    this.startRowOrCellEdit(null, pressedChar);
	                    // if we don't prevent default, then the keypress also gets applied to the text field
	                    // (at least when doing the default editor), but we need to allow the editor to decide
	                    // what it wants to do. we only do this IF editing was started - otherwise it messes
	                    // up when the use is not doing editing, but using rendering with text fields in cellRenderer
	                    // (as it would block the the user from typing into text fields).
	                    event.preventDefault();
	                }
	            }
	        }
	    };
	    RenderedCell.prototype.onKeyDown = function (event) {
	        var key = event.which || event.keyCode;
	        switch (key) {
	            case constants_1.Constants.KEY_ENTER:
	                this.onEnterKeyDown();
	                break;
	            case constants_1.Constants.KEY_F2:
	                this.onF2KeyDown();
	                break;
	            case constants_1.Constants.KEY_ESCAPE:
	                this.onEscapeKeyDown();
	                break;
	            case constants_1.Constants.KEY_TAB:
	                this.onTabKeyDown(event);
	                break;
	            case constants_1.Constants.KEY_BACKSPACE:
	            case constants_1.Constants.KEY_DELETE:
	                this.onBackspaceOrDeleteKeyPressed(key);
	                break;
	            case constants_1.Constants.KEY_DOWN:
	            case constants_1.Constants.KEY_UP:
	            case constants_1.Constants.KEY_RIGHT:
	            case constants_1.Constants.KEY_LEFT:
	                this.onNavigationKeyPressed(event, key);
	                break;
	        }
	    };
	    RenderedCell.prototype.createCellEditorParams = function (keyPress, charPress, cellStartedEdit) {
	        var params = {
	            value: this.getValue(),
	            keyPress: keyPress,
	            charPress: charPress,
	            column: this.column,
	            node: this.node,
	            api: this.gridOptionsWrapper.getApi(),
	            cellStartedEdit: cellStartedEdit,
	            columnApi: this.gridOptionsWrapper.getColumnApi(),
	            context: this.gridOptionsWrapper.getContext(),
	            $scope: this.scope,
	            onKeyDown: this.onKeyDown.bind(this),
	            stopEditing: this.stopEditingAndFocus.bind(this),
	            eGridCell: this.eGridCell
	        };
	        var colDef = this.column.getColDef();
	        if (colDef.cellEditorParams) {
	            utils_1.Utils.assign(params, colDef.cellEditorParams);
	        }
	        return params;
	    };
	    RenderedCell.prototype.createCellEditor = function (keyPress, charPress, cellStartedEdit) {
	        var params = this.createCellEditorParams(keyPress, charPress, cellStartedEdit);
	        var cellEditor = this.cellEditorFactory.createCellEditor(this.column.getCellEditor(), params);
	        return cellEditor;
	    };
	    // cell editors call this, when they want to stop for reasons other
	    // than what we pick up on. eg selecting from a dropdown ends editing.
	    RenderedCell.prototype.stopEditingAndFocus = function () {
	        this.stopRowOrCellEdit();
	        this.focusCell(true);
	    };
	    // called by rowRenderer when user navigates via tab key
	    RenderedCell.prototype.startRowOrCellEdit = function (keyPress, charPress) {
	        if (this.gridOptionsWrapper.isFullRowEdit()) {
	            this.renderedRow.startRowEditing(keyPress, charPress, this);
	        }
	        else {
	            this.startEditingIfEnabled(keyPress, charPress, true);
	        }
	    };
	    // either called internally if single cell editing, or called by rowRenderer if row editing
	    RenderedCell.prototype.startEditingIfEnabled = function (keyPress, charPress, cellStartedEdit) {
	        if (keyPress === void 0) { keyPress = null; }
	        if (charPress === void 0) { charPress = null; }
	        if (cellStartedEdit === void 0) { cellStartedEdit = false; }
	        // don't do it if not editable
	        if (!this.isCellEditable()) {
	            return;
	        }
	        // don't do it if already editing
	        if (this.editingCell) {
	            return;
	        }
	        var cellEditor = this.createCellEditor(keyPress, charPress, cellStartedEdit);
	        if (cellEditor.isCancelBeforeStart && cellEditor.isCancelBeforeStart()) {
	            if (cellEditor.destroy) {
	                cellEditor.destroy();
	            }
	            return false;
	        }
	        if (!cellEditor.getGui) {
	            console.warn("ag-Grid: cellEditor for column " + this.column.getId() + " is missing getGui() method");
	            // no getGui, for React guys, see if they attached a react component directly
	            if (cellEditor.render) {
	                console.warn("ag-Grid: we found 'render' on the component, are you trying to set a React renderer but added it as colDef.cellEditor instead of colDef.cellEditorFmk?");
	            }
	            return false;
	        }
	        this.cellEditor = cellEditor;
	        this.editingCell = true;
	        this.cellEditorInPopup = this.cellEditor.isPopup && this.cellEditor.isPopup();
	        this.setInlineEditingClass();
	        if (this.cellEditorInPopup) {
	            this.addPopupCellEditor();
	        }
	        else {
	            this.addInCellEditor();
	        }
	        if (cellEditor.afterGuiAttached) {
	            cellEditor.afterGuiAttached();
	        }
	        return true;
	    };
	    RenderedCell.prototype.addInCellEditor = function () {
	        utils_1.Utils.removeAllChildren(this.eGridCell);
	        this.eGridCell.appendChild(this.cellEditor.getGui());
	        if (this.gridOptionsWrapper.isAngularCompileRows()) {
	            this.$compile(this.eGridCell)(this.scope);
	        }
	    };
	    RenderedCell.prototype.addPopupCellEditor = function () {
	        var _this = this;
	        var ePopupGui = this.cellEditor.getGui();
	        this.hideEditorPopup = this.popupService.addAsModalPopup(ePopupGui, true, 
	        // callback for when popup disappears
	        function () {
	            // we only call stopEditing if we are editing, as
	            // it's possible the popup called 'stop editing'
	            // before this, eg if 'enter key' was pressed on
	            // the editor
	            if (_this.editingCell) {
	                _this.onPopupEditorClosed();
	            }
	        });
	        this.popupService.positionPopupOverComponent({
	            eventSource: this.eGridCell,
	            ePopup: ePopupGui,
	            keepWithinBounds: true
	        });
	        if (this.gridOptionsWrapper.isAngularCompileRows()) {
	            this.$compile(ePopupGui)(this.scope);
	        }
	    };
	    RenderedCell.prototype.focusCell = function (forceBrowserFocus) {
	        if (forceBrowserFocus === void 0) { forceBrowserFocus = false; }
	        this.focusedCellController.setFocusedCell(this.gridCell.rowIndex, this.column, this.node.floating, forceBrowserFocus);
	    };
	    // pass in 'true' to cancel the editing.
	    RenderedCell.prototype.stopRowOrCellEdit = function (cancel) {
	        if (cancel === void 0) { cancel = false; }
	        if (this.gridOptionsWrapper.isFullRowEdit()) {
	            this.renderedRow.stopRowEditing(cancel);
	        }
	        else {
	            this.stopEditing(cancel);
	        }
	    };
	    RenderedCell.prototype.stopEditing = function (cancel) {
	        if (cancel === void 0) { cancel = false; }
	        if (!this.editingCell) {
	            return;
	        }
	        this.editingCell = false;
	        if (!cancel) {
	            // also have another option here to cancel after editing, so for example user could have a popup editor and
	            // it is closed by user clicking outside the editor. then the editor will close automatically (with false
	            // passed above) and we need to see if the editor wants to accept the new value.
	            var userWantsToCancel = this.cellEditor.isCancelAfterEnd && this.cellEditor.isCancelAfterEnd();
	            if (!userWantsToCancel) {
	                var newValue = this.cellEditor.getValue();
	                this.valueService.setValue(this.node, this.column, newValue);
	                this.value = this.getValue();
	            }
	        }
	        if (this.cellEditor.destroy) {
	            this.cellEditor.destroy();
	        }
	        if (this.cellEditorInPopup) {
	            this.hideEditorPopup();
	            this.hideEditorPopup = null;
	        }
	        else {
	            utils_1.Utils.removeAllChildren(this.eGridCell);
	            // put the cell back the way it was before editing
	            if (this.checkboxSelection) {
	                // if wrapper, then put the wrapper back
	                this.eGridCell.appendChild(this.eCellWrapper);
	            }
	            else {
	                // if cellRenderer, then put the gui back in. if the renderer has
	                // a refresh, it will be called. however if it doesn't, then later
	                // the renderer will be destroyed and a new one will be created.
	                if (this.cellRenderer) {
	                    this.eGridCell.appendChild(this.cellRenderer.getGui());
	                }
	            }
	        }
	        this.setInlineEditingClass();
	        this.refreshCell();
	    };
	    RenderedCell.prototype.createParams = function () {
	        var params = {
	            node: this.node,
	            data: this.node.data,
	            value: this.value,
	            rowIndex: this.gridCell.rowIndex,
	            colDef: this.column.getColDef(),
	            $scope: this.scope,
	            context: this.gridOptionsWrapper.getContext(),
	            api: this.gridApi,
	            columnApi: this.columnApi
	        };
	        return params;
	    };
	    RenderedCell.prototype.createEvent = function (event) {
	        var agEvent = this.createParams();
	        agEvent.event = event;
	        return agEvent;
	    };
	    RenderedCell.prototype.getRenderedRow = function () {
	        return this.renderedRow;
	    };
	    RenderedCell.prototype.isSuppressNavigable = function () {
	        return this.column.isSuppressNavigable(this.node);
	    };
	    RenderedCell.prototype.isCellEditable = function () {
	        // never allow editing of groups
	        if (this.node.group) {
	            return false;
	        }
	        return this.column.isCellEditable(this.node);
	    };
	    RenderedCell.prototype.onMouseEvent = function (eventName, mouseEvent) {
	        switch (eventName) {
	            case 'click':
	                this.onCellClicked(mouseEvent);
	                break;
	            case 'mousedown':
	                this.onMouseDown();
	                break;
	            case 'dblclick':
	                this.onCellDoubleClicked(mouseEvent);
	                break;
	            case 'contextmenu':
	                this.onContextMenu(mouseEvent);
	                break;
	        }
	    };
	    RenderedCell.prototype.onContextMenu = function (mouseEvent) {
	        // to allow us to debug in chrome, we ignore the event if ctrl is pressed,
	        // thus the normal menu is displayed
	        if (mouseEvent.ctrlKey || mouseEvent.metaKey) {
	            return;
	        }
	        var colDef = this.column.getColDef();
	        var agEvent = this.createEvent(mouseEvent);
	        this.eventService.dispatchEvent(events_1.Events.EVENT_CELL_CONTEXT_MENU, agEvent);
	        if (colDef.onCellContextMenu) {
	            colDef.onCellContextMenu(agEvent);
	        }
	        if (this.contextMenuFactory && !this.gridOptionsWrapper.isSuppressContextMenu()) {
	            this.contextMenuFactory.showMenu(this.node, this.column, this.value, mouseEvent);
	            mouseEvent.preventDefault();
	        }
	    };
	    RenderedCell.prototype.onCellDoubleClicked = function (mouseEvent) {
	        var colDef = this.column.getColDef();
	        // always dispatch event to eventService
	        var agEvent = this.createEvent(mouseEvent);
	        this.eventService.dispatchEvent(events_1.Events.EVENT_CELL_DOUBLE_CLICKED, agEvent);
	        // check if colDef also wants to handle event
	        if (typeof colDef.onCellDoubleClicked === 'function') {
	            colDef.onCellDoubleClicked(agEvent);
	        }
	        if (!this.gridOptionsWrapper.isSingleClickEdit()) {
	            this.startRowOrCellEdit();
	        }
	    };
	    RenderedCell.prototype.onMouseDown = function () {
	        // we pass false to focusCell, as we don't want the cell to focus
	        // also get the browser focus. if we did, then the cellRenderer could
	        // have a text field in it, for example, and as the user clicks on the
	        // text field, the text field, the focus doesn't get to the text
	        // field, instead to goes to the div behind, making it impossible to
	        // select the text field.
	        this.focusCell(false);
	        // if it's a right click, then if the cell is already in range,
	        // don't change the range, however if the cell is not in a range,
	        // we set a new range
	        if (this.rangeController) {
	            var thisCell = this.gridCell;
	            var cellAlreadyInRange = this.rangeController.isCellInAnyRange(thisCell);
	            if (!cellAlreadyInRange) {
	                this.rangeController.setRangeToCell(thisCell);
	            }
	        }
	    };
	    RenderedCell.prototype.onCellClicked = function (mouseEvent) {
	        var agEvent = this.createEvent(mouseEvent);
	        this.eventService.dispatchEvent(events_1.Events.EVENT_CELL_CLICKED, agEvent);
	        var colDef = this.column.getColDef();
	        if (colDef.onCellClicked) {
	            colDef.onCellClicked(agEvent);
	        }
	        if (this.gridOptionsWrapper.isSingleClickEdit()) {
	            this.startRowOrCellEdit();
	        }
	        this.doIeFocusHack();
	    };
	    // https://ag-grid.com/forum/showthread.php?tid=4362
	    // when in IE or Edge, when you are editing a cell, then click on another cell,
	    // the other cell doesn't keep focus, so navigation keys, type to start edit etc
	    // don't work. appears that when you update the dom in IE it looses focus
	    RenderedCell.prototype.doIeFocusHack = function () {
	        if (utils_1.Utils.isBrowserIE() || utils_1.Utils.isBrowserEdge()) {
	            if (utils_1.Utils.missing(document.activeElement) || document.activeElement === document.body) {
	                // console.log('missing focus');
	                this.getGui().focus();
	            }
	        }
	    };
	    // if we are editing inline, then we don't have the padding in the cell (set in the themes)
	    // to allow the text editor full access to the entire cell
	    RenderedCell.prototype.setInlineEditingClass = function () {
	        var editingInline = this.editingCell && !this.cellEditorInPopup;
	        utils_1.Utils.addOrRemoveCssClass(this.eGridCell, 'ag-cell-inline-editing', editingInline);
	        utils_1.Utils.addOrRemoveCssClass(this.eGridCell, 'ag-cell-not-inline-editing', !editingInline);
	    };
	    RenderedCell.prototype.populateCell = function () {
	        // populate
	        this.putDataIntoCell();
	        // style
	        this.addStylesFromColDef();
	        this.addClassesFromColDef();
	        this.addClassesFromRules();
	    };
	    RenderedCell.prototype.addStylesFromColDef = function () {
	        var colDef = this.column.getColDef();
	        if (colDef.cellStyle) {
	            var cssToUse;
	            if (typeof colDef.cellStyle === 'function') {
	                var cellStyleParams = {
	                    value: this.value,
	                    data: this.node.data,
	                    node: this.node,
	                    colDef: colDef,
	                    column: this.column,
	                    $scope: this.scope,
	                    context: this.gridOptionsWrapper.getContext(),
	                    api: this.gridOptionsWrapper.getApi()
	                };
	                var cellStyleFunc = colDef.cellStyle;
	                cssToUse = cellStyleFunc(cellStyleParams);
	            }
	            else {
	                cssToUse = colDef.cellStyle;
	            }
	            if (cssToUse) {
	                utils_1.Utils.addStylesToElement(this.eGridCell, cssToUse);
	            }
	        }
	    };
	    RenderedCell.prototype.addClassesFromColDef = function () {
	        var _this = this;
	        var colDef = this.column.getColDef();
	        if (colDef.cellClass) {
	            var classToUse;
	            if (typeof colDef.cellClass === 'function') {
	                var cellClassParams = {
	                    value: this.value,
	                    data: this.node.data,
	                    node: this.node,
	                    colDef: colDef,
	                    $scope: this.scope,
	                    context: this.gridOptionsWrapper.getContext(),
	                    api: this.gridOptionsWrapper.getApi()
	                };
	                var cellClassFunc = colDef.cellClass;
	                classToUse = cellClassFunc(cellClassParams);
	            }
	            else {
	                classToUse = colDef.cellClass;
	            }
	            if (typeof classToUse === 'string') {
	                utils_1.Utils.addCssClass(this.eGridCell, classToUse);
	            }
	            else if (Array.isArray(classToUse)) {
	                classToUse.forEach(function (cssClassItem) {
	                    utils_1.Utils.addCssClass(_this.eGridCell, cssClassItem);
	                });
	            }
	        }
	    };
	    RenderedCell.prototype.addClassesFromRules = function () {
	        var colDef = this.column.getColDef();
	        var classRules = colDef.cellClassRules;
	        if (typeof classRules === 'object' && classRules !== null) {
	            var params = {
	                value: this.value,
	                data: this.node.data,
	                node: this.node,
	                colDef: colDef,
	                rowIndex: this.gridCell.rowIndex,
	                api: this.gridOptionsWrapper.getApi(),
	                context: this.gridOptionsWrapper.getContext()
	            };
	            var classNames = Object.keys(classRules);
	            for (var i = 0; i < classNames.length; i++) {
	                var className = classNames[i];
	                var rule = classRules[className];
	                var resultOfRule;
	                if (typeof rule === 'string') {
	                    resultOfRule = this.expressionService.evaluate(rule, params);
	                }
	                else if (typeof rule === 'function') {
	                    resultOfRule = rule(params);
	                }
	                if (resultOfRule) {
	                    utils_1.Utils.addCssClass(this.eGridCell, className);
	                }
	                else {
	                    utils_1.Utils.removeCssClass(this.eGridCell, className);
	                }
	            }
	        }
	    };
	    RenderedCell.prototype.createParentOfValue = function () {
	        if (this.checkboxSelection) {
	            this.eCellWrapper = document.createElement('span');
	            utils_1.Utils.addCssClass(this.eCellWrapper, 'ag-cell-wrapper');
	            this.eGridCell.appendChild(this.eCellWrapper);
	            var cbSelectionComponent = new checkboxSelectionComponent_1.CheckboxSelectionComponent();
	            this.context.wireBean(cbSelectionComponent);
	            cbSelectionComponent.init({ rowNode: this.node });
	            this.eCellWrapper.appendChild(cbSelectionComponent.getGui());
	            this.addDestroyFunc(function () { return cbSelectionComponent.destroy(); });
	            // eventually we call eSpanWithValue.innerHTML = xxx, so cannot include the checkbox (above) in this span
	            this.eSpanWithValue = document.createElement('span');
	            utils_1.Utils.addCssClass(this.eSpanWithValue, 'ag-cell-value');
	            this.eCellWrapper.appendChild(this.eSpanWithValue);
	            this.eParentOfValue = this.eSpanWithValue;
	        }
	        else {
	            utils_1.Utils.addCssClass(this.eGridCell, 'ag-cell-value');
	            this.eParentOfValue = this.eGridCell;
	        }
	    };
	    RenderedCell.prototype.isVolatile = function () {
	        return this.column.getColDef().volatile;
	    };
	    RenderedCell.prototype.refreshCell = function (animate, newData) {
	        if (animate === void 0) { animate = false; }
	        if (newData === void 0) { newData = false; }
	        this.value = this.getValue();
	        var refreshFailed = false;
	        var that = this;
	        // if it's 'new data', then we don't refresh the cellRenderer, even if refresh method is available.
	        // this is because if the whole data is new (ie we are showing stock price 'BBA' now and not 'SSD')
	        // then we are not showing a movement in the stock price, rather we are showing different stock.
	        var attemptRefresh = !newData && this.cellRenderer && this.cellRenderer.refresh;
	        if (attemptRefresh) {
	            try {
	                doRefresh();
	            }
	            catch (e) {
	                if (e instanceof methodNotImplementedException_1.MethodNotImplementedException) {
	                    refreshFailed = true;
	                }
	                else {
	                    throw e;
	                }
	            }
	        }
	        // we do the replace if not doing refresh, or if refresh was unsuccessful.
	        // the refresh can be unsuccessful if we are using a framework (eg ng2 or react) and the framework
	        // wrapper has the refresh method, but the underlying component doesn't
	        if (!attemptRefresh || refreshFailed) {
	            doReplace();
	        }
	        if (animate) {
	            this.animateCellWithDataChanged();
	        }
	        function doRefresh() {
	            // if the cell renderer has a refresh method, we call this instead of doing a refresh
	            // note: should pass in params here instead of value?? so that client has formattedValue
	            var valueFormatted = that.formatValue(that.value);
	            var cellRendererParams = that.column.getColDef().cellRendererParams;
	            var params = that.createRendererAndRefreshParams(valueFormatted, cellRendererParams);
	            that.cellRenderer.refresh(params);
	            // need to check rules. note, we ignore colDef classes and styles, these are assumed to be static
	            that.addClassesFromRules();
	        }
	        function doReplace() {
	            // otherwise we rip out the cell and replace it
	            utils_1.Utils.removeAllChildren(that.eParentOfValue);
	            // remove old renderer component if it exists
	            if (that.cellRenderer && that.cellRenderer.destroy) {
	                that.cellRenderer.destroy();
	            }
	            that.cellRenderer = null;
	            that.populateCell();
	            // if angular compiling, then need to also compile the cell again (angular compiling sucks, please wait...)
	            if (that.gridOptionsWrapper.isAngularCompileRows()) {
	                that.$compile(that.eGridCell)(that.scope);
	            }
	        }
	    };
	    RenderedCell.prototype.putDataIntoCell = function () {
	        // template gets preference, then cellRenderer, then do it ourselves
	        var colDef = this.column.getColDef();
	        var cellRenderer = this.column.getCellRenderer();
	        var floatingCellRenderer = this.column.getFloatingCellRenderer();
	        var valueFormatted = this.valueFormatterService.formatValue(this.column, this.node, this.scope, this.gridCell.rowIndex, this.value);
	        if (colDef.template) {
	            // template is really only used for angular 1 - as people using ng1 are used to providing templates with
	            // bindings in it. in ng2, people will hopefully want to provide components, not templates.
	            this.eParentOfValue.innerHTML = colDef.template;
	        }
	        else if (colDef.templateUrl) {
	            // likewise for templateUrl - it's for ng1 really - when we move away from ng1, we can take these out.
	            // niall was pro angular 1 when writing template and templateUrl, if writing from scratch now, would
	            // not do these, but would follow a pattern that was friendly towards components, not templates.
	            var template = this.templateService.getTemplate(colDef.templateUrl, this.refreshCell.bind(this, true));
	            if (template) {
	                this.eParentOfValue.innerHTML = template;
	            }
	        }
	        else if (floatingCellRenderer && this.node.floating) {
	            // if floating, then give preference to floating cell renderer
	            this.useCellRenderer(floatingCellRenderer, colDef.floatingCellRendererParams, valueFormatted);
	        }
	        else if (cellRenderer) {
	            // use normal cell renderer
	            this.useCellRenderer(cellRenderer, colDef.cellRendererParams, valueFormatted);
	        }
	        else {
	            // if we insert undefined, then it displays as the string 'undefined', ugly!
	            var valueFormattedExits = valueFormatted !== null && valueFormatted !== undefined;
	            var valueToRender = valueFormattedExits ? valueFormatted : this.value;
	            if (utils_1.Utils.exists(valueToRender) && valueToRender !== '') {
	                // not using innerHTML to prevent injection of HTML
	                // https://developer.mozilla.org/en-US/docs/Web/API/Element/innerHTML#Security_considerations
	                this.eParentOfValue.textContent = valueToRender.toString();
	            }
	        }
	        if (colDef.tooltipField) {
	            var data = this.getDataForRow();
	            if (utils_1.Utils.exists(data)) {
	                var tooltip = utils_1.Utils.getValueUsingField(data, colDef.tooltipField, this.column.isTooltipFieldContainsDots());
	                if (utils_1.Utils.exists(tooltip)) {
	                    this.eParentOfValue.setAttribute('title', tooltip);
	                }
	            }
	        }
	    };
	    RenderedCell.prototype.formatValue = function (value) {
	        return this.valueFormatterService.formatValue(this.column, this.node, this.scope, this.gridCell.rowIndex, value);
	    };
	    RenderedCell.prototype.createRendererAndRefreshParams = function (valueFormatted, cellRendererParams) {
	        var params = {
	            value: this.value,
	            valueFormatted: valueFormatted,
	            valueGetter: this.getValue,
	            formatValue: this.formatValue.bind(this),
	            data: this.node.data,
	            node: this.node,
	            colDef: this.column.getColDef(),
	            column: this.column,
	            $scope: this.scope,
	            rowIndex: this.gridCell.rowIndex,
	            api: this.gridOptionsWrapper.getApi(),
	            columnApi: this.gridOptionsWrapper.getColumnApi(),
	            context: this.gridOptionsWrapper.getContext(),
	            refreshCell: this.refreshCell.bind(this),
	            eGridCell: this.eGridCell,
	            eParentOfValue: this.eParentOfValue,
	            addRenderedRowListener: this.renderedRow.addEventListener.bind(this.renderedRow)
	        };
	        if (cellRendererParams) {
	            utils_1.Utils.assign(params, cellRendererParams);
	        }
	        return params;
	    };
	    RenderedCell.prototype.useCellRenderer = function (cellRendererKey, cellRendererParams, valueFormatted) {
	        var params = this.createRendererAndRefreshParams(valueFormatted, cellRendererParams);
	        this.cellRenderer = this.cellRendererService.useCellRenderer(cellRendererKey, this.eParentOfValue, params);
	    };
	    RenderedCell.prototype.addClasses = function () {
	        utils_1.Utils.addCssClass(this.eGridCell, 'ag-cell');
	        this.eGridCell.setAttribute("colId", this.column.getColId());
	        if (this.node.group && this.node.footer) {
	            utils_1.Utils.addCssClass(this.eGridCell, 'ag-footer-cell');
	        }
	        if (this.node.group && !this.node.footer) {
	            utils_1.Utils.addCssClass(this.eGridCell, 'ag-group-cell');
	        }
	    };
	    RenderedCell.PRINTABLE_CHARACTERS = 'qwertyuiopasdfghjklzxcvbnmQWERTYUIOPASDFGHJKLZXCVBNM1234567890!"£$%^&*()_+-=[];\'#,./\|<>?:@~{}';
	    __decorate([
	        context_1.Autowired('context'), 
	        __metadata('design:type', context_1.Context)
	    ], RenderedCell.prototype, "context", void 0);
	    __decorate([
	        context_1.Autowired('columnApi'), 
	        __metadata('design:type', columnController_1.ColumnApi)
	    ], RenderedCell.prototype, "columnApi", void 0);
	    __decorate([
	        context_1.Autowired('gridApi'), 
	        __metadata('design:type', gridApi_1.GridApi)
	    ], RenderedCell.prototype, "gridApi", void 0);
	    __decorate([
	        context_1.Autowired('gridOptionsWrapper'), 
	        __metadata('design:type', gridOptionsWrapper_1.GridOptionsWrapper)
	    ], RenderedCell.prototype, "gridOptionsWrapper", void 0);
	    __decorate([
	        context_1.Autowired('expressionService'), 
	        __metadata('design:type', expressionService_1.ExpressionService)
	    ], RenderedCell.prototype, "expressionService", void 0);
	    __decorate([
	        context_1.Autowired('rowRenderer'), 
	        __metadata('design:type', rowRenderer_1.RowRenderer)
	    ], RenderedCell.prototype, "rowRenderer", void 0);
	    __decorate([
	        context_1.Autowired('$compile'), 
	        __metadata('design:type', Object)
	    ], RenderedCell.prototype, "$compile", void 0);
	    __decorate([
	        context_1.Autowired('templateService'), 
	        __metadata('design:type', templateService_1.TemplateService)
	    ], RenderedCell.prototype, "templateService", void 0);
	    __decorate([
	        context_1.Autowired('valueService'), 
	        __metadata('design:type', valueService_1.ValueService)
	    ], RenderedCell.prototype, "valueService", void 0);
	    __decorate([
	        context_1.Autowired('eventService'), 
	        __metadata('design:type', eventService_1.EventService)
	    ], RenderedCell.prototype, "eventService", void 0);
	    __decorate([
	        context_1.Autowired('columnController'), 
	        __metadata('design:type', columnController_1.ColumnController)
	    ], RenderedCell.prototype, "columnController", void 0);
	    __decorate([
	        context_1.Optional('rangeController'), 
	        __metadata('design:type', Object)
	    ], RenderedCell.prototype, "rangeController", void 0);
	    __decorate([
	        context_1.Autowired('focusedCellController'), 
	        __metadata('design:type', focusedCellController_1.FocusedCellController)
	    ], RenderedCell.prototype, "focusedCellController", void 0);
	    __decorate([
	        context_1.Optional('contextMenuFactory'), 
	        __metadata('design:type', Object)
	    ], RenderedCell.prototype, "contextMenuFactory", void 0);
	    __decorate([
	        context_1.Autowired('focusService'), 
	        __metadata('design:type', focusService_1.FocusService)
	    ], RenderedCell.prototype, "focusService", void 0);
	    __decorate([
	        context_1.Autowired('cellEditorFactory'), 
	        __metadata('design:type', cellEditorFactory_1.CellEditorFactory)
	    ], RenderedCell.prototype, "cellEditorFactory", void 0);
	    __decorate([
	        context_1.Autowired('cellRendererFactory'), 
	        __metadata('design:type', cellRendererFactory_1.CellRendererFactory)
	    ], RenderedCell.prototype, "cellRendererFactory", void 0);
	    __decorate([
	        context_1.Autowired('popupService'), 
	        __metadata('design:type', popupService_1.PopupService)
	    ], RenderedCell.prototype, "popupService", void 0);
	    __decorate([
	        context_1.Autowired('cellRendererService'), 
	        __metadata('design:type', cellRendererService_1.CellRendererService)
	    ], RenderedCell.prototype, "cellRendererService", void 0);
	    __decorate([
	        context_1.Autowired('valueFormatterService'), 
	        __metadata('design:type', valueFormatterService_1.ValueFormatterService)
	    ], RenderedCell.prototype, "valueFormatterService", void 0);
	    __decorate([
	        context_1.PostConstruct, 
	        __metadata('design:type', Function), 
	        __metadata('design:paramtypes', []), 
	        __metadata('design:returntype', void 0)
	    ], RenderedCell.prototype, "init", null);
	    return RenderedCell;
	})(component_1.Component);
	exports.RenderedCell = RenderedCell;


/***/ },
/* 39 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
	 * @version v7.0.2
	 * @link http://www.ag-grid.com/
	 * @license MIT
	 */
	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var context_1 = __webpack_require__(6);
	var utils_1 = __webpack_require__(7);
	var gridCore_1 = __webpack_require__(40);
	var columnController_1 = __webpack_require__(13);
	var constants_1 = __webpack_require__(8);
	var gridCell_1 = __webpack_require__(33);
	// tracks when focus goes into a cell. cells listen to this, so they know to stop editing
	// if focus goes into another cell.
	/** THIS IS NOT USED - it was something Niall was working on, but doesn't work well with popup editors */
	var FocusService = (function () {
	    function FocusService() {
	        this.destroyMethods = [];
	        this.listeners = [];
	    }
	    FocusService.prototype.addListener = function (listener) {
	        this.listeners.push(listener);
	    };
	    FocusService.prototype.removeListener = function (listener) {
	        utils_1.Utils.removeFromArray(this.listeners, listener);
	    };
	    FocusService.prototype.init = function () {
	        var focusListener = this.onFocus.bind(this);
	        var eRootGui = this.gridCore.getRootGui();
	        eRootGui.addEventListener('focus', focusListener, true);
	        this.destroyMethods.push(function () {
	            eRootGui.removeEventListener('focus', focusListener);
	        });
	    };
	    FocusService.prototype.onFocus = function (focusEvent) {
	        var gridCell = this.getCellForFocus(focusEvent);
	        if (gridCell) {
	            this.informListeners({ gridCell: gridCell });
	        }
	    };
	    FocusService.prototype.getCellForFocus = function (focusEvent) {
	        var column = null;
	        var row = null;
	        var floating = null;
	        var that = this;
	        var eTarget = focusEvent.target;
	        while (eTarget) {
	            checkRow(eTarget);
	            checkColumn(eTarget);
	            eTarget = eTarget.parentNode;
	        }
	        if (utils_1.Utils.exists(column) && utils_1.Utils.exists(row)) {
	            var gridCell = new gridCell_1.GridCell(row, floating, column);
	            return gridCell;
	        }
	        else {
	            return null;
	        }
	        function checkRow(eTarget) {
	            // match the column by checking a) it has a valid colId and b) it has the 'ag-cell' class
	            var rowId = utils_1.Utils.getElementAttribute(eTarget, 'row');
	            if (utils_1.Utils.exists(rowId) && utils_1.Utils.containsClass(eTarget, 'ag-row')) {
	                if (rowId.indexOf('ft') === 0) {
	                    floating = constants_1.Constants.FLOATING_TOP;
	                    rowId = rowId.substr(3);
	                }
	                else if (rowId.indexOf('fb') === 0) {
	                    floating = constants_1.Constants.FLOATING_BOTTOM;
	                    rowId = rowId.substr(3);
	                }
	                else {
	                    floating = null;
	                }
	                row = parseInt(rowId);
	            }
	        }
	        function checkColumn(eTarget) {
	            // match the column by checking a) it has a valid colId and b) it has the 'ag-cell' class
	            var colId = utils_1.Utils.getElementAttribute(eTarget, 'colid');
	            if (utils_1.Utils.exists(colId) && utils_1.Utils.containsClass(eTarget, 'ag-cell')) {
	                var foundColumn = that.columnController.getGridColumn(colId);
	                if (foundColumn) {
	                    column = foundColumn;
	                }
	            }
	        }
	    };
	    FocusService.prototype.informListeners = function (event) {
	        this.listeners.forEach(function (listener) { return listener(event); });
	    };
	    FocusService.prototype.destroy = function () {
	        this.destroyMethods.forEach(function (destroyMethod) { return destroyMethod(); });
	    };
	    __decorate([
	        context_1.Autowired('gridCore'), 
	        __metadata('design:type', gridCore_1.GridCore)
	    ], FocusService.prototype, "gridCore", void 0);
	    __decorate([
	        context_1.Autowired('columnController'), 
	        __metadata('design:type', columnController_1.ColumnController)
	    ], FocusService.prototype, "columnController", void 0);
	    __decorate([
	        context_1.PostConstruct, 
	        __metadata('design:type', Function), 
	        __metadata('design:paramtypes', []), 
	        __metadata('design:returntype', void 0)
	    ], FocusService.prototype, "init", null);
	    __decorate([
	        context_1.PreDestroy, 
	        __metadata('design:type', Function), 
	        __metadata('design:paramtypes', []), 
	        __metadata('design:returntype', void 0)
	    ], FocusService.prototype, "destroy", null);
	    FocusService = __decorate([
	        context_1.Bean('focusService'), 
	        __metadata('design:paramtypes', [])
	    ], FocusService);
	    return FocusService;
	})();
	exports.FocusService = FocusService;


/***/ },
/* 40 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
	 * @version v7.0.2
	 * @link http://www.ag-grid.com/
	 * @license MIT
	 */
	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var __param = (this && this.__param) || function (paramIndex, decorator) {
	    return function (target, key) { decorator(target, key, paramIndex); }
	};
	var gridOptionsWrapper_1 = __webpack_require__(3);
	var paginationController_1 = __webpack_require__(41);
	var columnController_1 = __webpack_require__(13);
	var rowRenderer_1 = __webpack_require__(23);
	var filterManager_1 = __webpack_require__(43);
	var eventService_1 = __webpack_require__(4);
	var gridPanel_1 = __webpack_require__(24);
	var logger_1 = __webpack_require__(5);
	var constants_1 = __webpack_require__(8);
	var popupService_1 = __webpack_require__(44);
	var events_1 = __webpack_require__(10);
	var borderLayout_1 = __webpack_require__(30);
	var context_1 = __webpack_require__(6);
	var focusedCellController_1 = __webpack_require__(35);
	var component_1 = __webpack_require__(47);
	var GridCore = (function () {
	    function GridCore(loggerFactory) {
	        this.destroyFunctions = [];
	        this.logger = loggerFactory.create('GridCore');
	    }
	    GridCore.prototype.init = function () {
	        var _this = this;
	        // and the last bean, done in it's own section, as it's optional
	        var toolPanelGui;
	        var eSouthPanel = this.createSouthPanel();
	        if (this.toolPanel && !this.gridOptionsWrapper.isForPrint()) {
	            toolPanelGui = this.toolPanel.getGui();
	        }
	        var createTopPanelGui = this.createNorthPanel();
	        this.eRootPanel = new borderLayout_1.BorderLayout({
	            center: this.gridPanel.getLayout(),
	            east: toolPanelGui,
	            north: createTopPanelGui,
	            south: eSouthPanel,
	            dontFill: this.gridOptionsWrapper.isForPrint(),
	            name: 'eRootPanel'
	        });
	        // see what the grid options are for default of toolbar
	        this.showToolPanel(this.gridOptionsWrapper.isShowToolPanel());
	        this.eGridDiv.appendChild(this.eRootPanel.getGui());
	        // if using angular, watch for quickFilter changes
	        if (this.$scope) {
	            this.$scope.$watch(this.quickFilterOnScope, function (newFilter) { return _this.filterManager.setQuickFilter(newFilter); });
	        }
	        if (!this.gridOptionsWrapper.isForPrint()) {
	            this.addWindowResizeListener();
	        }
	        this.doLayout();
	        this.finished = false;
	        this.periodicallyDoLayout();
	        this.eventService.addEventListener(events_1.Events.EVENT_COLUMN_ROW_GROUP_CHANGED, this.onRowGroupChanged.bind(this));
	        this.eventService.addEventListener(events_1.Events.EVENT_COLUMN_EVERYTHING_CHANGED, this.onRowGroupChanged.bind(this));
	        this.onRowGroupChanged();
	        this.logger.log('ready');
	    };
	    GridCore.prototype.createNorthPanel = function () {
	        var _this = this;
	        if (!this.gridOptionsWrapper.isEnterprise()) {
	            return null;
	        }
	        var topPanelGui = document.createElement('div');
	        var dropPanelVisibleListener = this.onDropPanelVisible.bind(this);
	        this.rowGroupComp = this.rowGroupCompFactory.create();
	        this.pivotComp = this.pivotCompFactory.create();
	        topPanelGui.appendChild(this.rowGroupComp.getGui());
	        topPanelGui.appendChild(this.pivotComp.getGui());
	        this.rowGroupComp.addEventListener(component_1.Component.EVENT_VISIBLE_CHANGED, dropPanelVisibleListener);
	        this.pivotComp.addEventListener(component_1.Component.EVENT_VISIBLE_CHANGED, dropPanelVisibleListener);
	        this.destroyFunctions.push(function () {
	            _this.rowGroupComp.removeEventListener(component_1.Component.EVENT_VISIBLE_CHANGED, dropPanelVisibleListener);
	            _this.pivotComp.removeEventListener(component_1.Component.EVENT_VISIBLE_CHANGED, dropPanelVisibleListener);
	        });
	        this.onDropPanelVisible();
	        return topPanelGui;
	    };
	    GridCore.prototype.onDropPanelVisible = function () {
	        var bothVisible = this.rowGroupComp.isVisible() && this.pivotComp.isVisible();
	        this.rowGroupComp.addOrRemoveCssClass('ag-width-half', bothVisible);
	        this.pivotComp.addOrRemoveCssClass('ag-width-half', bothVisible);
	    };
	    GridCore.prototype.getRootGui = function () {
	        return this.eRootPanel.getGui();
	    };
	    GridCore.prototype.createSouthPanel = function () {
	        if (!this.statusBar && this.gridOptionsWrapper.isEnableStatusBar()) {
	            console.warn('ag-Grid: status bar is only available in ag-Grid-Enterprise');
	        }
	        var statusBarEnabled = this.statusBar && this.gridOptionsWrapper.isEnableStatusBar();
	        var paginationPanelEnabled = this.gridOptionsWrapper.isRowModelPagination() && !this.gridOptionsWrapper.isForPrint();
	        if (!statusBarEnabled && !paginationPanelEnabled) {
	            return null;
	        }
	        var eSouthPanel = document.createElement('div');
	        if (statusBarEnabled) {
	            eSouthPanel.appendChild(this.statusBar.getGui());
	        }
	        if (paginationPanelEnabled) {
	            eSouthPanel.appendChild(this.paginationController.getGui());
	        }
	        return eSouthPanel;
	    };
	    GridCore.prototype.onRowGroupChanged = function () {
	        if (!this.rowGroupComp) {
	            return;
	        }
	        var rowGroupPanelShow = this.gridOptionsWrapper.getRowGroupPanelShow();
	        if (rowGroupPanelShow === constants_1.Constants.ALWAYS) {
	            this.rowGroupComp.setVisible(true);
	        }
	        else if (rowGroupPanelShow === constants_1.Constants.ONLY_WHEN_GROUPING) {
	            var grouping = !this.columnController.isRowGroupEmpty();
	            this.rowGroupComp.setVisible(grouping);
	        }
	        else {
	            this.rowGroupComp.setVisible(false);
	        }
	        this.eRootPanel.doLayout();
	    };
	    GridCore.prototype.addWindowResizeListener = function () {
	        var eventListener = this.doLayout.bind(this);
	        window.addEventListener('resize', eventListener);
	        this.destroyFunctions.push(function () { return window.removeEventListener('resize', eventListener); });
	    };
	    GridCore.prototype.periodicallyDoLayout = function () {
	        var _this = this;
	        if (!this.finished) {
	            var intervalMillis = this.gridOptionsWrapper.getLayoutInterval();
	            // if interval is negative, this stops the layout from happening
	            if (intervalMillis > 0) {
	                this.frameworkFactory.setTimeout(function () {
	                    _this.doLayout();
	                    _this.gridPanel.periodicallyCheck();
	                    _this.periodicallyDoLayout();
	                }, intervalMillis);
	            }
	            else {
	                // if user provided negative number, we still do the check every 5 seconds,
	                // in case the user turns the number positive again
	                this.frameworkFactory.setTimeout(function () {
	                    _this.periodicallyDoLayout();
	                }, 5000);
	            }
	        }
	    };
	    GridCore.prototype.showToolPanel = function (show) {
	        if (show && !this.toolPanel) {
	            console.warn('ag-Grid: toolPanel is only available in ag-Grid Enterprise');
	            this.toolPanelShowing = false;
	            return;
	        }
	        this.toolPanelShowing = show;
	        if (this.toolPanel) {
	            this.toolPanel.setVisible(show);
	            this.eRootPanel.doLayout();
	        }
	    };
	    GridCore.prototype.isToolPanelShowing = function () {
	        return this.toolPanelShowing;
	    };
	    GridCore.prototype.destroy = function () {
	        this.finished = true;
	        this.eGridDiv.removeChild(this.eRootPanel.getGui());
	        this.logger.log('Grid DOM removed');
	        this.destroyFunctions.forEach(function (func) { return func(); });
	    };
	    GridCore.prototype.ensureNodeVisible = function (comparator) {
	        if (this.doingVirtualPaging) {
	            throw 'Cannot use ensureNodeVisible when doing virtual paging, as we cannot check rows that are not in memory';
	        }
	        // look for the node index we want to display
	        var rowCount = this.rowModel.getRowCount();
	        var comparatorIsAFunction = typeof comparator === 'function';
	        var indexToSelect = -1;
	        // go through all the nodes, find the one we want to show
	        for (var i = 0; i < rowCount; i++) {
	            var node = this.rowModel.getRow(i);
	            if (comparatorIsAFunction) {
	                if (comparator(node)) {
	                    indexToSelect = i;
	                    break;
	                }
	            }
	            else {
	                // check object equality against node and data
	                if (comparator === node || comparator === node.data) {
	                    indexToSelect = i;
	                    break;
	                }
	            }
	        }
	        if (indexToSelect >= 0) {
	            this.gridPanel.ensureIndexVisible(indexToSelect);
	        }
	    };
	    GridCore.prototype.doLayout = function () {
	        // need to do layout first, as drawVirtualRows and setPinnedColHeight
	        // need to know the result of the resizing of the panels.
	        var sizeChanged = this.eRootPanel.doLayout();
	        // both of the two below should be done in gridPanel, the gridPanel should register 'resize' to the panel
	        if (sizeChanged) {
	            this.rowRenderer.drawVirtualRowsWithLock();
	            var event = {
	                clientWidth: this.eRootPanel.getGui().clientWidth,
	                clientHeight: this.eRootPanel.getGui().clientHeight
	            };
	            this.eventService.dispatchEvent(events_1.Events.EVENT_GRID_SIZE_CHANGED, event);
	        }
	    };
	    __decorate([
	        context_1.Autowired('gridOptions'), 
	        __metadata('design:type', Object)
	    ], GridCore.prototype, "gridOptions", void 0);
	    __decorate([
	        context_1.Autowired('gridOptionsWrapper'), 
	        __metadata('design:type', gridOptionsWrapper_1.GridOptionsWrapper)
	    ], GridCore.prototype, "gridOptionsWrapper", void 0);
	    __decorate([
	        context_1.Autowired('paginationController'), 
	        __metadata('design:type', paginationController_1.PaginationController)
	    ], GridCore.prototype, "paginationController", void 0);
	    __decorate([
	        context_1.Autowired('rowModel'), 
	        __metadata('design:type', Object)
	    ], GridCore.prototype, "rowModel", void 0);
	    __decorate([
	        context_1.Autowired('frameworkFactory'), 
	        __metadata('design:type', Object)
	    ], GridCore.prototype, "frameworkFactory", void 0);
	    __decorate([
	        context_1.Autowired('columnController'), 
	        __metadata('design:type', columnController_1.ColumnController)
	    ], GridCore.prototype, "columnController", void 0);
	    __decorate([
	        context_1.Autowired('rowRenderer'), 
	        __metadata('design:type', rowRenderer_1.RowRenderer)
	    ], GridCore.prototype, "rowRenderer", void 0);
	    __decorate([
	        context_1.Autowired('filterManager'), 
	        __metadata('design:type', filterManager_1.FilterManager)
	    ], GridCore.prototype, "filterManager", void 0);
	    __decorate([
	        context_1.Autowired('eventService'), 
	        __metadata('design:type', eventService_1.EventService)
	    ], GridCore.prototype, "eventService", void 0);
	    __decorate([
	        context_1.Autowired('gridPanel'), 
	        __metadata('design:type', gridPanel_1.GridPanel)
	    ], GridCore.prototype, "gridPanel", void 0);
	    __decorate([
	        context_1.Autowired('eGridDiv'), 
	        __metadata('design:type', HTMLElement)
	    ], GridCore.prototype, "eGridDiv", void 0);
	    __decorate([
	        context_1.Autowired('$scope'), 
	        __metadata('design:type', Object)
	    ], GridCore.prototype, "$scope", void 0);
	    __decorate([
	        context_1.Autowired('quickFilterOnScope'), 
	        __metadata('design:type', String)
	    ], GridCore.prototype, "quickFilterOnScope", void 0);
	    __decorate([
	        context_1.Autowired('popupService'), 
	        __metadata('design:type', popupService_1.PopupService)
	    ], GridCore.prototype, "popupService", void 0);
	    __decorate([
	        context_1.Autowired('focusedCellController'), 
	        __metadata('design:type', focusedCellController_1.FocusedCellController)
	    ], GridCore.prototype, "focusedCellController", void 0);
	    __decorate([
	        context_1.Optional('rowGroupCompFactory'), 
	        __metadata('design:type', Object)
	    ], GridCore.prototype, "rowGroupCompFactory", void 0);
	    __decorate([
	        context_1.Optional('pivotCompFactory'), 
	        __metadata('design:type', Object)
	    ], GridCore.prototype, "pivotCompFactory", void 0);
	    __decorate([
	        context_1.Optional('toolPanel'), 
	        __metadata('design:type', component_1.Component)
	    ], GridCore.prototype, "toolPanel", void 0);
	    __decorate([
	        context_1.Optional('statusBar'), 
	        __metadata('design:type', component_1.Component)
	    ], GridCore.prototype, "statusBar", void 0);
	    __decorate([
	        context_1.PostConstruct, 
	        __metadata('design:type', Function), 
	        __metadata('design:paramtypes', []), 
	        __metadata('design:returntype', void 0)
	    ], GridCore.prototype, "init", null);
	    __decorate([
	        context_1.PreDestroy, 
	        __metadata('design:type', Function), 
	        __metadata('design:paramtypes', []), 
	        __metadata('design:returntype', void 0)
	    ], GridCore.prototype, "destroy", null);
	    GridCore = __decorate([
	        context_1.Bean('gridCore'),
	        __param(0, context_1.Qualifier('loggerFactory')), 
	        __metadata('design:paramtypes', [logger_1.LoggerFactory])
	    ], GridCore);
	    return GridCore;
	})();
	exports.GridCore = GridCore;


/***/ },
/* 41 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
	 * @version v7.0.2
	 * @link http://www.ag-grid.com/
	 * @license MIT
	 */
	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var utils_1 = __webpack_require__(7);
	var gridOptionsWrapper_1 = __webpack_require__(3);
	var context_1 = __webpack_require__(6);
	var gridPanel_1 = __webpack_require__(24);
	var selectionController_1 = __webpack_require__(28);
	var sortController_1 = __webpack_require__(42);
	var eventService_1 = __webpack_require__(4);
	var events_1 = __webpack_require__(10);
	var filterManager_1 = __webpack_require__(43);
	var constants_1 = __webpack_require__(8);
	var template = '<div class="ag-paging-panel ag-font-style">' +
	    '<span id="pageRowSummaryPanel" class="ag-paging-row-summary-panel">' +
	    '<span id="firstRowOnPage"></span>' +
	    ' [TO] ' +
	    '<span id="lastRowOnPage"></span>' +
	    ' [OF] ' +
	    '<span id="recordCount"></span>' +
	    '</span>' +
	    '<span class="ag-paging-page-summary-panel">' +
	    '<button type="button" class="ag-paging-button" id="btFirst">[FIRST]</button>' +
	    '<button type="button" class="ag-paging-button" id="btPrevious">[PREVIOUS]</button>' +
	    '[PAGE] ' +
	    '<span id="current"></span>' +
	    ' [OF] ' +
	    '<span id="total"></span>' +
	    '<button type="button" class="ag-paging-button" id="btNext">[NEXT]</button>' +
	    '<button type="button" class="ag-paging-button" id="btLast">[LAST]</button>' +
	    '</span>' +
	    '</div>';
	var PaginationController = (function () {
	    function PaginationController() {
	    }
	    PaginationController.prototype.init = function () {
	        var _this = this;
	        // if we are doing pagination, we are guaranteed that the model type
	        // is normal. if it is not, then this paginationController service
	        // will never be called.
	        if (this.rowModel.getType() === constants_1.Constants.ROW_MODEL_TYPE_NORMAL) {
	            this.inMemoryRowModel = this.rowModel;
	        }
	        this.setupComponents();
	        this.callVersion = 0;
	        var paginationEnabled = this.gridOptionsWrapper.isRowModelPagination();
	        this.eventService.addEventListener(events_1.Events.EVENT_FILTER_CHANGED, function () {
	            if (paginationEnabled && _this.gridOptionsWrapper.isEnableServerSideFilter()) {
	                _this.reset(false);
	            }
	        });
	        this.eventService.addEventListener(events_1.Events.EVENT_SORT_CHANGED, function () {
	            if (paginationEnabled && _this.gridOptionsWrapper.isEnableServerSideSorting()) {
	                _this.reset(false);
	            }
	        });
	        if (paginationEnabled && this.gridOptionsWrapper.getDatasource()) {
	            this.setDatasource(this.gridOptionsWrapper.getDatasource());
	        }
	    };
	    PaginationController.prototype.setDatasource = function (datasource) {
	        this.datasource = datasource;
	        if (!datasource) {
	            // only continue if we have a valid datasource to work with
	            return;
	        }
	        this.reset(true);
	    };
	    PaginationController.prototype.checkForDeprecated = function () {
	        var ds = this.datasource;
	        if (utils_1.Utils.exists(ds.pageSize)) {
	            console.error('ag-Grid: since version 5.1.x, pageSize is replaced with grid property paginationPageSize');
	        }
	    };
	    PaginationController.prototype.reset = function (freshDatasource) {
	        // important to return here, as the user could be setting filter or sort before
	        // data-source is set
	        if (utils_1.Utils.missing(this.datasource)) {
	            return;
	        }
	        this.checkForDeprecated();
	        // if user is providing id's, then this means we can keep the selection between datsource hits,
	        // as the rows will keep their unique id's even if, for example, server side sorting or filtering
	        // is done. if it's a new datasource, then always clear the selection.
	        var userGeneratingRows = utils_1.Utils.exists(this.gridOptionsWrapper.getRowNodeIdFunc());
	        var resetSelectionController = freshDatasource || !userGeneratingRows;
	        if (resetSelectionController) {
	            this.selectionController.reset();
	        }
	        // copy pageSize, to guard against it changing the the datasource between calls
	        this.pageSize = this.gridOptionsWrapper.getPaginationPageSize();
	        if (!(this.pageSize >= 1)) {
	            this.pageSize = 100;
	        }
	        // see if we know the total number of pages, or if it's 'to be decided'
	        if (typeof this.datasource.rowCount === 'number' && this.datasource.rowCount >= 0) {
	            this.rowCount = this.datasource.rowCount;
	            this.foundMaxRow = true;
	            this.calculateTotalPages();
	        }
	        else {
	            this.rowCount = 0;
	            this.foundMaxRow = false;
	            this.totalPages = null;
	        }
	        this.currentPage = 0;
	        // hide the summary panel until something is loaded
	        this.ePageRowSummaryPanel.style.visibility = 'hidden';
	        this.setTotalLabels();
	        this.loadPage();
	    };
	    // the native method number.toLocaleString(undefined, {minimumFractionDigits: 0}) puts in decimal places in IE
	    PaginationController.prototype.myToLocaleString = function (input) {
	        if (typeof input !== 'number') {
	            return '';
	        }
	        else {
	            // took this from: http://blog.tompawlak.org/number-currency-formatting-javascript
	            return input.toString().replace(/(\d)(?=(\d{3})+(?!\d))/g, "$1,");
	        }
	    };
	    PaginationController.prototype.setTotalLabels = function () {
	        if (this.foundMaxRow) {
	            this.lbTotal.innerHTML = this.myToLocaleString(this.totalPages);
	            this.lbRecordCount.innerHTML = this.myToLocaleString(this.rowCount);
	        }
	        else {
	            var moreText = this.gridOptionsWrapper.getLocaleTextFunc()('more', 'more');
	            this.lbTotal.innerHTML = moreText;
	            this.lbRecordCount.innerHTML = moreText;
	        }
	    };
	    PaginationController.prototype.calculateTotalPages = function () {
	        this.totalPages = Math.floor((this.rowCount - 1) / this.pageSize) + 1;
	    };
	    PaginationController.prototype.pageLoaded = function (rows, lastRowIndex) {
	        var firstId = this.currentPage * this.pageSize;
	        this.inMemoryRowModel.setRowData(rows, true, firstId);
	        // see if we hit the last row
	        if (!this.foundMaxRow && typeof lastRowIndex === 'number' && lastRowIndex >= 0) {
	            this.foundMaxRow = true;
	            this.rowCount = lastRowIndex;
	            this.calculateTotalPages();
	            this.setTotalLabels();
	            // if overshot pages, go back
	            if (this.currentPage > this.totalPages) {
	                this.currentPage = this.totalPages - 1;
	                this.loadPage();
	            }
	        }
	        this.enableOrDisableButtons();
	        this.updateRowLabels();
	    };
	    PaginationController.prototype.updateRowLabels = function () {
	        var startRow;
	        var endRow;
	        if (this.isZeroPagesToDisplay()) {
	            startRow = 0;
	            endRow = 0;
	        }
	        else {
	            startRow = (this.pageSize * this.currentPage) + 1;
	            endRow = startRow + this.pageSize - 1;
	            if (this.foundMaxRow && endRow > this.rowCount) {
	                endRow = this.rowCount;
	            }
	        }
	        this.lbFirstRowOnPage.innerHTML = this.myToLocaleString(startRow);
	        this.lbLastRowOnPage.innerHTML = this.myToLocaleString(endRow);
	        // show the summary panel, when first shown, this is blank
	        this.ePageRowSummaryPanel.style.visibility = "";
	    };
	    PaginationController.prototype.loadPage = function () {
	        var _this = this;
	        this.enableOrDisableButtons();
	        var startRow = this.currentPage * this.pageSize;
	        var endRow = (this.currentPage + 1) * this.pageSize;
	        this.lbCurrent.innerHTML = this.myToLocaleString(this.currentPage + 1);
	        this.callVersion++;
	        var callVersionCopy = this.callVersion;
	        var that = this;
	        this.gridPanel.showLoadingOverlay();
	        var sortModel;
	        if (this.gridOptionsWrapper.isEnableServerSideSorting()) {
	            sortModel = this.sortController.getSortModel();
	        }
	        var filterModel;
	        if (this.gridOptionsWrapper.isEnableServerSideFilter()) {
	            filterModel = this.filterManager.getFilterModel();
	        }
	        var params = {
	            startRow: startRow,
	            endRow: endRow,
	            successCallback: successCallback,
	            failCallback: failCallback,
	            sortModel: sortModel,
	            filterModel: filterModel,
	            context: this.gridOptionsWrapper.getContext()
	        };
	        // check if old version of datasource used
	        var getRowsParams = utils_1.Utils.getFunctionParameters(this.datasource.getRows);
	        if (getRowsParams.length > 1) {
	            console.warn('ag-grid: It looks like your paging datasource is of the old type, taking more than one parameter.');
	            console.warn('ag-grid: From ag-grid 1.9.0, now the getRows takes one parameter. See the documentation for details.');
	        }
	        // put in timeout, to force result to be async
	        setTimeout(function () {
	            _this.datasource.getRows(params);
	        }, 0);
	        function successCallback(rows, lastRowIndex) {
	            if (that.isCallDaemon(callVersionCopy)) {
	                return;
	            }
	            that.pageLoaded(rows, lastRowIndex);
	        }
	        function failCallback() {
	            if (that.isCallDaemon(callVersionCopy)) {
	                return;
	            }
	            // set in an empty set of rows, this will at
	            // least get rid of the loading panel, and
	            // stop blocking things
	            that.inMemoryRowModel.setRowData([], true);
	        }
	    };
	    PaginationController.prototype.isCallDaemon = function (versionCopy) {
	        return versionCopy !== this.callVersion;
	    };
	    PaginationController.prototype.onBtNext = function () {
	        this.currentPage++;
	        this.loadPage();
	    };
	    PaginationController.prototype.onBtPrevious = function () {
	        this.currentPage--;
	        this.loadPage();
	    };
	    PaginationController.prototype.onBtFirst = function () {
	        this.currentPage = 0;
	        this.loadPage();
	    };
	    PaginationController.prototype.onBtLast = function () {
	        this.currentPage = this.totalPages - 1;
	        this.loadPage();
	    };
	    PaginationController.prototype.isZeroPagesToDisplay = function () {
	        return this.foundMaxRow && this.totalPages === 0;
	    };
	    PaginationController.prototype.enableOrDisableButtons = function () {
	        var disablePreviousAndFirst = this.currentPage === 0;
	        this.btPrevious.disabled = disablePreviousAndFirst;
	        this.btFirst.disabled = disablePreviousAndFirst;
	        var zeroPagesToDisplay = this.isZeroPagesToDisplay();
	        var onLastPage = this.foundMaxRow && this.currentPage === (this.totalPages - 1);
	        var disableNext = onLastPage || zeroPagesToDisplay;
	        this.btNext.disabled = disableNext;
	        var disableLast = !this.foundMaxRow || zeroPagesToDisplay || this.currentPage === (this.totalPages - 1);
	        this.btLast.disabled = disableLast;
	    };
	    PaginationController.prototype.createTemplate = function () {
	        var localeTextFunc = this.gridOptionsWrapper.getLocaleTextFunc();
	        return template
	            .replace('[PAGE]', localeTextFunc('page', 'Page'))
	            .replace('[TO]', localeTextFunc('to', 'to'))
	            .replace('[OF]', localeTextFunc('of', 'of'))
	            .replace('[OF]', localeTextFunc('of', 'of'))
	            .replace('[FIRST]', localeTextFunc('first', 'First'))
	            .replace('[PREVIOUS]', localeTextFunc('previous', 'Previous'))
	            .replace('[NEXT]', localeTextFunc('next', 'Next'))
	            .replace('[LAST]', localeTextFunc('last', 'Last'));
	    };
	    PaginationController.prototype.getGui = function () {
	        return this.eGui;
	    };
	    PaginationController.prototype.setupComponents = function () {
	        this.eGui = utils_1.Utils.loadTemplate(this.createTemplate());
	        this.btNext = this.eGui.querySelector('#btNext');
	        this.btPrevious = this.eGui.querySelector('#btPrevious');
	        this.btFirst = this.eGui.querySelector('#btFirst');
	        this.btLast = this.eGui.querySelector('#btLast');
	        this.lbCurrent = this.eGui.querySelector('#current');
	        this.lbTotal = this.eGui.querySelector('#total');
	        this.lbRecordCount = this.eGui.querySelector('#recordCount');
	        this.lbFirstRowOnPage = this.eGui.querySelector('#firstRowOnPage');
	        this.lbLastRowOnPage = this.eGui.querySelector('#lastRowOnPage');
	        this.ePageRowSummaryPanel = this.eGui.querySelector('#pageRowSummaryPanel');
	        var that = this;
	        this.btNext.addEventListener('click', function () {
	            that.onBtNext();
	        });
	        this.btPrevious.addEventListener('click', function () {
	            that.onBtPrevious();
	        });
	        this.btFirst.addEventListener('click', function () {
	            that.onBtFirst();
	        });
	        this.btLast.addEventListener('click', function () {
	            that.onBtLast();
	        });
	    };
	    __decorate([
	        context_1.Autowired('filterManager'), 
	        __metadata('design:type', filterManager_1.FilterManager)
	    ], PaginationController.prototype, "filterManager", void 0);
	    __decorate([
	        context_1.Autowired('gridPanel'), 
	        __metadata('design:type', gridPanel_1.GridPanel)
	    ], PaginationController.prototype, "gridPanel", void 0);
	    __decorate([
	        context_1.Autowired('gridOptionsWrapper'), 
	        __metadata('design:type', gridOptionsWrapper_1.GridOptionsWrapper)
	    ], PaginationController.prototype, "gridOptionsWrapper", void 0);
	    __decorate([
	        context_1.Autowired('selectionController'), 
	        __metadata('design:type', selectionController_1.SelectionController)
	    ], PaginationController.prototype, "selectionController", void 0);
	    __decorate([
	        context_1.Autowired('sortController'), 
	        __metadata('design:type', sortController_1.SortController)
	    ], PaginationController.prototype, "sortController", void 0);
	    __decorate([
	        context_1.Autowired('eventService'), 
	        __metadata('design:type', eventService_1.EventService)
	    ], PaginationController.prototype, "eventService", void 0);
	    __decorate([
	        context_1.Autowired('rowModel'), 
	        __metadata('design:type', Object)
	    ], PaginationController.prototype, "rowModel", void 0);
	    __decorate([
	        context_1.PostConstruct, 
	        __metadata('design:type', Function), 
	        __metadata('design:paramtypes', []), 
	        __metadata('design:returntype', void 0)
	    ], PaginationController.prototype, "init", null);
	    PaginationController = __decorate([
	        context_1.Bean('paginationController'), 
	        __metadata('design:paramtypes', [])
	    ], PaginationController);
	    return PaginationController;
	})();
	exports.PaginationController = PaginationController;


/***/ },
/* 42 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
	 * @version v7.0.2
	 * @link http://www.ag-grid.com/
	 * @license MIT
	 */
	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var column_1 = __webpack_require__(15);
	var context_1 = __webpack_require__(6);
	var gridOptionsWrapper_1 = __webpack_require__(3);
	var columnController_1 = __webpack_require__(13);
	var eventService_1 = __webpack_require__(4);
	var events_1 = __webpack_require__(10);
	var context_2 = __webpack_require__(6);
	var utils_1 = __webpack_require__(7);
	var SortController = (function () {
	    function SortController() {
	    }
	    SortController.prototype.progressSort = function (column, multiSort) {
	        // update sort on current col
	        column.setSort(this.getNextSortDirection(column));
	        // sortedAt used for knowing order of cols when multi-col sort
	        if (column.getSort()) {
	            var sortedAt = Number(new Date().valueOf());
	            column.setSortedAt(sortedAt);
	        }
	        else {
	            column.setSortedAt(null);
	        }
	        var doingMultiSort = multiSort && !this.gridOptionsWrapper.isSuppressMultiSort();
	        // clear sort on all columns except this one, and update the icons
	        if (!doingMultiSort) {
	            this.clearSortBarThisColumn(column);
	        }
	        this.dispatchSortChangedEvents();
	    };
	    SortController.prototype.dispatchSortChangedEvents = function () {
	        this.eventService.dispatchEvent(events_1.Events.EVENT_BEFORE_SORT_CHANGED);
	        this.eventService.dispatchEvent(events_1.Events.EVENT_SORT_CHANGED);
	        this.eventService.dispatchEvent(events_1.Events.EVENT_AFTER_SORT_CHANGED);
	    };
	    SortController.prototype.clearSortBarThisColumn = function (columnToSkip) {
	        this.columnController.getPrimaryAndSecondaryAndAutoColumns().forEach(function (columnToClear) {
	            // Do not clear if either holding shift, or if column in question was clicked
	            if (!(columnToClear === columnToSkip)) {
	                columnToClear.setSort(null);
	            }
	        });
	    };
	    SortController.prototype.getNextSortDirection = function (column) {
	        var sortingOrder;
	        if (column.getColDef().sortingOrder) {
	            sortingOrder = column.getColDef().sortingOrder;
	        }
	        else if (this.gridOptionsWrapper.getSortingOrder()) {
	            sortingOrder = this.gridOptionsWrapper.getSortingOrder();
	        }
	        else {
	            sortingOrder = SortController.DEFAULT_SORTING_ORDER;
	        }
	        if (!Array.isArray(sortingOrder) || sortingOrder.length <= 0) {
	            console.warn('ag-grid: sortingOrder must be an array with at least one element, currently it\'s ' + sortingOrder);
	            return;
	        }
	        var currentIndex = sortingOrder.indexOf(column.getSort());
	        var notInArray = currentIndex < 0;
	        var lastItemInArray = currentIndex == sortingOrder.length - 1;
	        var result;
	        if (notInArray || lastItemInArray) {
	            result = sortingOrder[0];
	        }
	        else {
	            result = sortingOrder[currentIndex + 1];
	        }
	        // verify the sort type exists, as the user could provide the sortOrder, need to make sure it's valid
	        if (SortController.DEFAULT_SORTING_ORDER.indexOf(result) < 0) {
	            console.warn('ag-grid: invalid sort type ' + result);
	            return null;
	        }
	        return result;
	    };
	    // used by the public api, for saving the sort model
	    SortController.prototype.getSortModel = function () {
	        var columnsWithSorting = this.getColumnsWithSortingOrdered();
	        return utils_1.Utils.map(columnsWithSorting, function (column) {
	            return {
	                colId: column.getColId(),
	                sort: column.getSort()
	            };
	        });
	    };
	    SortController.prototype.setSortModel = function (sortModel) {
	        if (!this.gridOptionsWrapper.isEnableSorting()) {
	            console.warn('ag-grid: You are setting the sort model on a grid that does not have sorting enabled');
	            return;
	        }
	        // first up, clear any previous sort
	        var sortModelProvided = sortModel && sortModel.length > 0;
	        var allColumnsIncludingAuto = this.columnController.getPrimaryAndSecondaryAndAutoColumns();
	        allColumnsIncludingAuto.forEach(function (column) {
	            var sortForCol = null;
	            var sortedAt = -1;
	            if (sortModelProvided && !column.getColDef().suppressSorting) {
	                for (var j = 0; j < sortModel.length; j++) {
	                    var sortModelEntry = sortModel[j];
	                    if (typeof sortModelEntry.colId === 'string'
	                        && typeof column.getColId() === 'string'
	                        && sortModelEntry.colId === column.getColId()) {
	                        sortForCol = sortModelEntry.sort;
	                        sortedAt = j;
	                    }
	                }
	            }
	            if (sortForCol) {
	                column.setSort(sortForCol);
	                column.setSortedAt(sortedAt);
	            }
	            else {
	                column.setSort(null);
	                column.setSortedAt(null);
	            }
	        });
	        this.dispatchSortChangedEvents();
	    };
	    SortController.prototype.getColumnsWithSortingOrdered = function () {
	        // pull out all the columns that have sorting set
	        var allColumnsIncludingAuto = this.columnController.getPrimaryAndSecondaryAndAutoColumns();
	        var columnsWithSorting = utils_1.Utils.filter(allColumnsIncludingAuto, function (column) { return !!column.getSort(); });
	        // put the columns in order of which one got sorted first
	        columnsWithSorting.sort(function (a, b) { return a.sortedAt - b.sortedAt; });
	        return columnsWithSorting;
	    };
	    // used by row controller, when doing the sorting
	    SortController.prototype.getSortForRowController = function () {
	        var columnsWithSorting = this.getColumnsWithSortingOrdered();
	        return utils_1.Utils.map(columnsWithSorting, function (column) {
	            var ascending = column.getSort() === column_1.Column.SORT_ASC;
	            return {
	                inverter: ascending ? 1 : -1,
	                column: column
	            };
	        });
	    };
	    SortController.DEFAULT_SORTING_ORDER = [column_1.Column.SORT_ASC, column_1.Column.SORT_DESC, null];
	    __decorate([
	        context_1.Autowired('gridOptionsWrapper'), 
	        __metadata('design:type', gridOptionsWrapper_1.GridOptionsWrapper)
	    ], SortController.prototype, "gridOptionsWrapper", void 0);
	    __decorate([
	        context_1.Autowired('columnController'), 
	        __metadata('design:type', columnController_1.ColumnController)
	    ], SortController.prototype, "columnController", void 0);
	    __decorate([
	        context_1.Autowired('eventService'), 
	        __metadata('design:type', eventService_1.EventService)
	    ], SortController.prototype, "eventService", void 0);
	    SortController = __decorate([
	        context_2.Bean('sortController'), 
	        __metadata('design:paramtypes', [])
	    ], SortController);
	    return SortController;
	})();
	exports.SortController = SortController;


/***/ },
/* 43 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
	 * @version v7.0.2
	 * @link http://www.ag-grid.com/
	 * @license MIT
	 */
	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var utils_1 = __webpack_require__(7);
	var gridOptionsWrapper_1 = __webpack_require__(3);
	var popupService_1 = __webpack_require__(44);
	var valueService_1 = __webpack_require__(29);
	var columnController_1 = __webpack_require__(13);
	var textFilter_1 = __webpack_require__(45);
	var numberFilter_1 = __webpack_require__(46);
	var context_1 = __webpack_require__(6);
	var eventService_1 = __webpack_require__(4);
	var events_1 = __webpack_require__(10);
	var FilterManager = (function () {
	    function FilterManager() {
	        this.allFilters = {};
	        this.quickFilter = null;
	        this.availableFilters = {
	            'text': textFilter_1.TextFilter,
	            'number': numberFilter_1.NumberFilter
	        };
	    }
	    FilterManager.prototype.init = function () {
	        this.eventService.addEventListener(events_1.Events.EVENT_ROW_DATA_CHANGED, this.onNewRowsLoaded.bind(this));
	        this.eventService.addEventListener(events_1.Events.EVENT_NEW_COLUMNS_LOADED, this.onNewColumnsLoaded.bind(this));
	        this.quickFilter = this.parseQuickFilter(this.gridOptionsWrapper.getQuickFilterText());
	        // check this here, in case there is a filter from the start
	        this.checkExternalFilter();
	    };
	    FilterManager.prototype.registerFilter = function (key, Filter) {
	        this.availableFilters[key] = Filter;
	    };
	    FilterManager.prototype.setFilterModel = function (model) {
	        var _this = this;
	        if (model) {
	            // mark the filters as we set them, so any active filters left over we stop
	            var modelKeys = Object.keys(model);
	            utils_1.Utils.iterateObject(this.allFilters, function (colId, filterWrapper) {
	                utils_1.Utils.removeFromArray(modelKeys, colId);
	                var newModel = model[colId];
	                _this.setModelOnFilterWrapper(filterWrapper.filter, newModel);
	            });
	            // at this point, processedFields contains data for which we don't have a filter working yet
	            utils_1.Utils.iterateArray(modelKeys, function (colId) {
	                var column = _this.columnController.getPrimaryColumn(colId);
	                if (!column) {
	                    console.warn('Warning ag-grid setFilterModel - no column found for colId ' + colId);
	                    return;
	                }
	                var filterWrapper = _this.getOrCreateFilterWrapper(column);
	                _this.setModelOnFilterWrapper(filterWrapper.filter, model[colId]);
	            });
	        }
	        else {
	            utils_1.Utils.iterateObject(this.allFilters, function (key, filterWrapper) {
	                _this.setModelOnFilterWrapper(filterWrapper.filter, null);
	            });
	        }
	        this.onFilterChanged();
	    };
	    FilterManager.prototype.setModelOnFilterWrapper = function (filter, newModel) {
	        if (typeof filter.setModel !== 'function') {
	            console.warn('Warning ag-grid - filter missing setModel method, which is needed for setFilterModel');
	            return;
	        }
	        filter.setModel(newModel);
	    };
	    FilterManager.prototype.getFilterModel = function () {
	        var result = {};
	        utils_1.Utils.iterateObject(this.allFilters, function (key, filterWrapper) {
	            // because user can provide filters, we provide useful error checking and messages
	            var filter = filterWrapper.filter;
	            if (typeof filter.getModel !== 'function') {
	                console.warn('Warning ag-grid - filter API missing getModel method, which is needed for getFilterModel');
	                return;
	            }
	            var model = filter.getModel();
	            if (utils_1.Utils.exists(model)) {
	                result[key] = model;
	            }
	        });
	        return result;
	    };
	    // returns true if any advanced filter (ie not quick filter) active
	    FilterManager.prototype.isAdvancedFilterPresent = function () {
	        var atLeastOneActive = false;
	        utils_1.Utils.iterateObject(this.allFilters, function (key, filterWrapper) {
	            if (filterWrapper.filter.isFilterActive()) {
	                atLeastOneActive = true;
	            }
	        });
	        return atLeastOneActive;
	    };
	    FilterManager.prototype.updateFilterFlagInColumns = function () {
	        utils_1.Utils.iterateObject(this.allFilters, function (key, filterWrapper) {
	            var filterActive = filterWrapper.filter.isFilterActive();
	            filterWrapper.column.setFilterActive(filterActive);
	        });
	    };
	    // returns true if quickFilter or advancedFilter
	    FilterManager.prototype.isAnyFilterPresent = function () {
	        return this.isQuickFilterPresent() || this.advancedFilterPresent || this.externalFilterPresent;
	    };
	    FilterManager.prototype.doesFilterPass = function (node, filterToSkip) {
	        var data = node.data;
	        var colKeys = Object.keys(this.allFilters);
	        for (var i = 0, l = colKeys.length; i < l; i++) {
	            var colId = colKeys[i];
	            var filterWrapper = this.allFilters[colId];
	            // if no filter, always pass
	            if (filterWrapper === undefined) {
	                continue;
	            }
	            if (filterWrapper.filter === filterToSkip) {
	                continue;
	            }
	            // don't bother with filters that are not active
	            if (!filterWrapper.filter.isFilterActive()) {
	                continue;
	            }
	            if (!filterWrapper.filter.doesFilterPass) {
	                console.error('Filter is missing method doesFilterPass');
	            }
	            var params = {
	                node: node,
	                data: data
	            };
	            if (!filterWrapper.filter.doesFilterPass(params)) {
	                return false;
	            }
	        }
	        // all filters passed
	        return true;
	    };
	    FilterManager.prototype.parseQuickFilter = function (newFilter) {
	        if (utils_1.Utils.missing(newFilter) || newFilter === "") {
	            return null;
	        }
	        if (this.gridOptionsWrapper.isRowModelVirtual()) {
	            console.warn('ag-grid: cannot do quick filtering when doing virtual paging');
	            return null;
	        }
	        return newFilter.toUpperCase();
	    };
	    // returns true if it has changed (not just same value again)
	    FilterManager.prototype.setQuickFilter = function (newFilter) {
	        var parsedFilter = this.parseQuickFilter(newFilter);
	        if (this.quickFilter !== parsedFilter) {
	            this.quickFilter = parsedFilter;
	            this.onFilterChanged();
	        }
	    };
	    FilterManager.prototype.checkExternalFilter = function () {
	        this.externalFilterPresent = this.gridOptionsWrapper.isExternalFilterPresent();
	    };
	    FilterManager.prototype.onFilterChanged = function () {
	        this.eventService.dispatchEvent(events_1.Events.EVENT_BEFORE_FILTER_CHANGED);
	        this.advancedFilterPresent = this.isAdvancedFilterPresent();
	        this.updateFilterFlagInColumns();
	        this.checkExternalFilter();
	        utils_1.Utils.iterateObject(this.allFilters, function (key, filterWrapper) {
	            if (filterWrapper.filter.onAnyFilterChanged) {
	                filterWrapper.filter.onAnyFilterChanged();
	            }
	        });
	        this.eventService.dispatchEvent(events_1.Events.EVENT_FILTER_CHANGED);
	        this.eventService.dispatchEvent(events_1.Events.EVENT_AFTER_FILTER_CHANGED);
	    };
	    FilterManager.prototype.isQuickFilterPresent = function () {
	        return this.quickFilter !== null;
	    };
	    FilterManager.prototype.doesRowPassOtherFilters = function (filterToSkip, node) {
	        return this.doesRowPassFilter(node, filterToSkip);
	    };
	    FilterManager.prototype.doesRowPassFilter = function (node, filterToSkip) {
	        //first up, check quick filter
	        if (this.isQuickFilterPresent()) {
	            if (!node.quickFilterAggregateText) {
	                this.aggregateRowForQuickFilter(node);
	            }
	            if (node.quickFilterAggregateText.indexOf(this.quickFilter) < 0) {
	                //quick filter fails, so skip item
	                return false;
	            }
	        }
	        //secondly, give the client a chance to reject this row
	        if (this.externalFilterPresent) {
	            if (!this.gridOptionsWrapper.doesExternalFilterPass(node)) {
	                return false;
	            }
	        }
	        //lastly, check our internal advanced filter
	        if (this.advancedFilterPresent) {
	            if (!this.doesFilterPass(node, filterToSkip)) {
	                return false;
	            }
	        }
	        //got this far, all filters pass
	        return true;
	    };
	    FilterManager.prototype.aggregateRowForQuickFilter = function (node) {
	        var _this = this;
	        var stringParts = [];
	        var columns = this.columnController.getAllPrimaryColumns();
	        columns.forEach(function (column) {
	            var value = _this.valueService.getValue(column, node);
	            var valueAfterCallback;
	            var colDef = column.getColDef();
	            if (column.getColDef().getQuickFilterText) {
	                var params = {
	                    value: value,
	                    node: node,
	                    data: node.data,
	                    column: column,
	                    colDef: colDef
	                };
	                valueAfterCallback = column.getColDef().getQuickFilterText(params);
	            }
	            else {
	                valueAfterCallback = value;
	            }
	            if (valueAfterCallback && valueAfterCallback !== '') {
	                stringParts.push(valueAfterCallback.toString().toUpperCase());
	            }
	        });
	        node.quickFilterAggregateText = stringParts.join('_');
	    };
	    FilterManager.prototype.onNewRowsLoaded = function () {
	        utils_1.Utils.iterateObject(this.allFilters, function (key, filterWrapper) {
	            if (filterWrapper.filter.onNewRowsLoaded) {
	                filterWrapper.filter.onNewRowsLoaded();
	            }
	        });
	        this.updateFilterFlagInColumns();
	    };
	    FilterManager.prototype.createValueGetter = function (column) {
	        var that = this;
	        return function valueGetter(node) {
	            return that.valueService.getValue(column, node);
	        };
	    };
	    FilterManager.prototype.getFilterComponent = function (column) {
	        var filterWrapper = this.getOrCreateFilterWrapper(column);
	        return filterWrapper.filter;
	    };
	    FilterManager.prototype.getOrCreateFilterWrapper = function (column) {
	        var filterWrapper = this.allFilters[column.getColId()];
	        if (!filterWrapper) {
	            filterWrapper = this.createFilterWrapper(column);
	            this.allFilters[column.getColId()] = filterWrapper;
	        }
	        return filterWrapper;
	    };
	    FilterManager.prototype.createFilterInstance = function (column) {
	        var filter = column.getFilter();
	        var filterIsComponent = typeof filter === 'function';
	        var filterIsName = utils_1.Utils.missing(filter) || typeof filter === 'string';
	        var FilterClass;
	        if (filterIsComponent) {
	            // if user provided a filter, just use it
	            FilterClass = filter;
	            // now create filter (had to cast to any to get 'new' working)
	            this.assertMethodHasNoParameters(FilterClass);
	        }
	        else if (filterIsName) {
	            var filterName = filter;
	            FilterClass = this.getFilterFromCache(filterName);
	        }
	        else {
	            console.error('ag-Grid: colDef.filter should be function or a string');
	            return null;
	        }
	        var filterInstance = new FilterClass();
	        this.checkFilterHasAllMandatoryMethods(filterInstance, column);
	        this.context.wireBean(filterInstance);
	        return filterInstance;
	    };
	    FilterManager.prototype.checkFilterHasAllMandatoryMethods = function (filterInstance, column) {
	        // help the user, check the mandatory methods exist
	        ['getGui', 'isFilterActive', 'doesFilterPass', 'getModel', 'setModel'].forEach(function (methodName) {
	            var methodIsMissing = !filterInstance[methodName];
	            if (methodIsMissing) {
	                throw "Filter for column " + column.getColId() + " is missing method " + methodName;
	            }
	        });
	    };
	    FilterManager.prototype.createParams = function (filterWrapper) {
	        var _this = this;
	        var filterChangedCallback = this.onFilterChanged.bind(this);
	        var filterModifiedCallback = function () { return _this.eventService.dispatchEvent(events_1.Events.EVENT_FILTER_MODIFIED); };
	        var doesRowPassOtherFilters = this.doesRowPassOtherFilters.bind(this, filterWrapper.filter);
	        var colDef = filterWrapper.column.getColDef();
	        var params = {
	            column: filterWrapper.column,
	            colDef: colDef,
	            rowModel: this.rowModel,
	            filterChangedCallback: filterChangedCallback,
	            filterModifiedCallback: filterModifiedCallback,
	            valueGetter: this.createValueGetter(filterWrapper.column),
	            doesRowPassOtherFilter: doesRowPassOtherFilters,
	            context: this.gridOptionsWrapper.getContext(),
	            $scope: filterWrapper.scope
	        };
	        if (colDef.filterParams) {
	            utils_1.Utils.assign(params, colDef.filterParams);
	        }
	        return params;
	    };
	    FilterManager.prototype.createFilterWrapper = function (column) {
	        var filterWrapper = {
	            column: column,
	            filter: null,
	            scope: null,
	            gui: null
	        };
	        filterWrapper.filter = this.createFilterInstance(column);
	        this.initialiseFilterAndPutIntoGui(filterWrapper);
	        return filterWrapper;
	    };
	    FilterManager.prototype.initialiseFilterAndPutIntoGui = function (filterWrapper) {
	        // first up, create child scope if needed
	        if (this.gridOptionsWrapper.isAngularCompileFilters()) {
	            filterWrapper.scope = this.$scope.$new();
	            filterWrapper.scope.context = this.gridOptionsWrapper.getContext();
	        }
	        var params = this.createParams(filterWrapper);
	        filterWrapper.filter.init(params);
	        var eFilterGui = document.createElement('div');
	        eFilterGui.className = 'ag-filter';
	        var guiFromFilter = filterWrapper.filter.getGui();
	        if (utils_1.Utils.isNodeOrElement(guiFromFilter)) {
	            //a dom node or element was returned, so add child
	            eFilterGui.appendChild(guiFromFilter);
	        }
	        else {
	            //otherwise assume it was html, so just insert
	            var eTextSpan = document.createElement('span');
	            eTextSpan.innerHTML = guiFromFilter;
	            eFilterGui.appendChild(eTextSpan);
	        }
	        if (filterWrapper.scope) {
	            filterWrapper.gui = this.$compile(eFilterGui)(filterWrapper.scope)[0];
	        }
	        else {
	            filterWrapper.gui = eFilterGui;
	        }
	    };
	    FilterManager.prototype.getFilterFromCache = function (filterType) {
	        var defaultFilterType = this.enterprise ? 'set' : 'text';
	        var defaultFilter = this.availableFilters[defaultFilterType];
	        if (utils_1.Utils.missing(filterType)) {
	            return defaultFilter;
	        }
	        if (!this.enterprise && filterType === 'set') {
	            console.warn('ag-Grid: Set filter is only available in Enterprise ag-Grid');
	            filterType = 'text';
	        }
	        if (this.availableFilters[filterType]) {
	            return this.availableFilters[filterType];
	        }
	        else {
	            console.error('ag-Grid: Could not find filter type ' + filterType);
	            return this.availableFilters[defaultFilter];
	        }
	    };
	    FilterManager.prototype.onNewColumnsLoaded = function () {
	        this.destroy();
	    };
	    // destroys the filter, so it not longer takes part
	    FilterManager.prototype.destroyFilter = function (column) {
	        var filterWrapper = this.allFilters[column.getColId()];
	        if (filterWrapper) {
	            this.disposeFilterWrapper(filterWrapper);
	            this.onFilterChanged();
	        }
	    };
	    FilterManager.prototype.disposeFilterWrapper = function (filterWrapper) {
	        if (filterWrapper.filter.destroy) {
	            filterWrapper.filter.destroy();
	        }
	        filterWrapper.column.setFilterActive(false);
	        delete this.allFilters[filterWrapper.column.getColId()];
	    };
	    FilterManager.prototype.destroy = function () {
	        var _this = this;
	        utils_1.Utils.iterateObject(this.allFilters, function (key, filterWrapper) {
	            _this.disposeFilterWrapper(filterWrapper);
	        });
	    };
	    FilterManager.prototype.assertMethodHasNoParameters = function (theMethod) {
	        var getRowsParams = utils_1.Utils.getFunctionParameters(theMethod);
	        if (getRowsParams.length > 0) {
	            console.warn('ag-grid: It looks like your filter is of the old type and expecting parameters in the constructor.');
	            console.warn('ag-grid: From ag-grid 1.14, the constructor should take no parameters and init() used instead.');
	        }
	    };
	    __decorate([
	        context_1.Autowired('$compile'), 
	        __metadata('design:type', Object)
	    ], FilterManager.prototype, "$compile", void 0);
	    __decorate([
	        context_1.Autowired('$scope'), 
	        __metadata('design:type', Object)
	    ], FilterManager.prototype, "$scope", void 0);
	    __decorate([
	        context_1.Autowired('gridOptionsWrapper'), 
	        __metadata('design:type', gridOptionsWrapper_1.GridOptionsWrapper)
	    ], FilterManager.prototype, "gridOptionsWrapper", void 0);
	    __decorate([
	        context_1.Autowired('gridCore'), 
	        __metadata('design:type', Object)
	    ], FilterManager.prototype, "gridCore", void 0);
	    __decorate([
	        context_1.Autowired('popupService'), 
	        __metadata('design:type', popupService_1.PopupService)
	    ], FilterManager.prototype, "popupService", void 0);
	    __decorate([
	        context_1.Autowired('valueService'), 
	        __metadata('design:type', valueService_1.ValueService)
	    ], FilterManager.prototype, "valueService", void 0);
	    __decorate([
	        context_1.Autowired('columnController'), 
	        __metadata('design:type', columnController_1.ColumnController)
	    ], FilterManager.prototype, "columnController", void 0);
	    __decorate([
	        context_1.Autowired('rowModel'), 
	        __metadata('design:type', Object)
	    ], FilterManager.prototype, "rowModel", void 0);
	    __decorate([
	        context_1.Autowired('eventService'), 
	        __metadata('design:type', eventService_1.EventService)
	    ], FilterManager.prototype, "eventService", void 0);
	    __decorate([
	        context_1.Autowired('enterprise'), 
	        __metadata('design:type', Boolean)
	    ], FilterManager.prototype, "enterprise", void 0);
	    __decorate([
	        context_1.Autowired('context'), 
	        __metadata('design:type', context_1.Context)
	    ], FilterManager.prototype, "context", void 0);
	    __decorate([
	        context_1.PostConstruct, 
	        __metadata('design:type', Function), 
	        __metadata('design:paramtypes', []), 
	        __metadata('design:returntype', void 0)
	    ], FilterManager.prototype, "init", null);
	    __decorate([
	        context_1.PreDestroy, 
	        __metadata('design:type', Function), 
	        __metadata('design:paramtypes', []), 
	        __metadata('design:returntype', void 0)
	    ], FilterManager.prototype, "destroy", null);
	    FilterManager = __decorate([
	        context_1.Bean('filterManager'), 
	        __metadata('design:paramtypes', [])
	    ], FilterManager);
	    return FilterManager;
	})();
	exports.FilterManager = FilterManager;


/***/ },
/* 44 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
	 * @version v7.0.2
	 * @link http://www.ag-grid.com/
	 * @license MIT
	 */
	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var utils_1 = __webpack_require__(7);
	var constants_1 = __webpack_require__(8);
	var context_1 = __webpack_require__(6);
	var gridCore_1 = __webpack_require__(40);
	var PopupService = (function () {
	    function PopupService() {
	    }
	    // this.popupService.setPopupParent(this.eRootPanel.getGui());
	    PopupService.prototype.getPopupParent = function () {
	        return this.gridCore.getRootGui();
	    };
	    PopupService.prototype.positionPopupForMenu = function (params) {
	        var sourceRect = params.eventSource.getBoundingClientRect();
	        var parentRect = this.getPopupParent().getBoundingClientRect();
	        var x = sourceRect.right - parentRect.left - 2;
	        var y = sourceRect.top - parentRect.top;
	        var minWidth;
	        if (params.ePopup.clientWidth > 0) {
	            minWidth = params.ePopup.clientWidth;
	        }
	        else {
	            minWidth = 200;
	        }
	        var widthOfParent = parentRect.right - parentRect.left;
	        var maxX = widthOfParent - minWidth;
	        if (x > maxX) {
	            // try putting menu to the left
	            x = sourceRect.left - parentRect.left - minWidth;
	        }
	        if (x < 0) {
	            x = 0;
	        }
	        params.ePopup.style.left = x + "px";
	        params.ePopup.style.top = y + "px";
	    };
	    PopupService.prototype.positionPopupUnderMouseEvent = function (params) {
	        var parentRect = this.getPopupParent().getBoundingClientRect();
	        this.positionPopup({
	            ePopup: params.ePopup,
	            x: params.mouseEvent.clientX - parentRect.left,
	            y: params.mouseEvent.clientY - parentRect.top,
	            keepWithinBounds: true
	        });
	    };
	    PopupService.prototype.positionPopupUnderComponent = function (params) {
	        var sourceRect = params.eventSource.getBoundingClientRect();
	        var parentRect = this.getPopupParent().getBoundingClientRect();
	        this.positionPopup({
	            ePopup: params.ePopup,
	            minWidth: params.minWidth,
	            nudgeX: params.nudgeX,
	            nudgeY: params.nudgeY,
	            x: sourceRect.left - parentRect.left,
	            y: sourceRect.top - parentRect.top + sourceRect.height,
	            keepWithinBounds: params.keepWithinBounds
	        });
	    };
	    PopupService.prototype.positionPopupOverComponent = function (params) {
	        var sourceRect = params.eventSource.getBoundingClientRect();
	        var parentRect = this.getPopupParent().getBoundingClientRect();
	        this.positionPopup({
	            ePopup: params.ePopup,
	            minWidth: params.minWidth,
	            nudgeX: params.nudgeX,
	            nudgeY: params.nudgeY,
	            x: sourceRect.left - parentRect.left,
	            y: sourceRect.top - parentRect.top,
	            keepWithinBounds: params.keepWithinBounds
	        });
	    };
	    PopupService.prototype.positionPopup = function (params) {
	        var parentRect = this.getPopupParent().getBoundingClientRect();
	        var x = params.x;
	        var y = params.y;
	        if (params.nudgeX) {
	            x += params.nudgeX;
	        }
	        if (params.nudgeY) {
	            y += params.nudgeY;
	        }
	        // if popup is overflowing to the bottom, move it up
	        if (params.keepWithinBounds) {
	            checkHorizontalOverflow();
	            checkVerticalOverflow();
	        }
	        params.ePopup.style.left = x + "px";
	        params.ePopup.style.top = y + "px";
	        function checkHorizontalOverflow() {
	            var minWidth;
	            if (params.minWidth > 0) {
	                minWidth = params.minWidth;
	            }
	            else if (params.ePopup.clientWidth > 0) {
	                minWidth = params.ePopup.clientWidth;
	            }
	            else {
	                minWidth = 200;
	            }
	            var widthOfParent = parentRect.right - parentRect.left;
	            var maxX = widthOfParent - minWidth - 5;
	            if (x > maxX) {
	                x = maxX;
	            }
	            if (x < 0) {
	                x = 0;
	            }
	        }
	        function checkVerticalOverflow() {
	            var minHeight;
	            if (params.ePopup.clientWidth > 0) {
	                minHeight = params.ePopup.clientHeight;
	            }
	            else {
	                minHeight = 200;
	            }
	            var heightOfParent = parentRect.bottom - parentRect.top;
	            var maxY = heightOfParent - minHeight - 5;
	            if (y > maxY) {
	                y = maxY;
	            }
	            if (y < 0) {
	                y = 0;
	            }
	        }
	    };
	    //adds an element to a div, but also listens to background checking for clicks,
	    //so that when the background is clicked, the child is removed again, giving
	    //a model look to popups.
	    PopupService.prototype.addAsModalPopup = function (eChild, closeOnEsc, closedCallback) {
	        var eBody = document.body;
	        if (!eBody) {
	            console.warn('ag-grid: could not find the body of the document, document.body is empty');
	            return;
	        }
	        eChild.style.top = '0px';
	        eChild.style.left = '0px';
	        var popupAlreadyShown = utils_1.Utils.isVisible(eChild);
	        if (popupAlreadyShown) {
	            return;
	        }
	        this.getPopupParent().appendChild(eChild);
	        var that = this;
	        var popupHidden = false;
	        // if we add these listeners now, then the current mouse
	        // click will be included, which we don't want
	        setTimeout(function () {
	            if (closeOnEsc) {
	                eBody.addEventListener('keydown', hidePopupOnEsc);
	            }
	            eBody.addEventListener('click', hidePopup);
	            eBody.addEventListener('touchstart', hidePopup);
	            eBody.addEventListener('contextmenu', hidePopup);
	            //eBody.addEventListener('mousedown', hidePopup);
	            eChild.addEventListener('click', consumeMouseClick);
	            eChild.addEventListener('touchstart', consumeTouchClick);
	            //eChild.addEventListener('mousedown', consumeClick);
	        }, 0);
	        // var timeOfMouseEventOnChild = new Date().getTime();
	        var childMouseClick = null;
	        var childTouch = null;
	        function hidePopupOnEsc(event) {
	            var key = event.which || event.keyCode;
	            if (key === constants_1.Constants.KEY_ESCAPE) {
	                hidePopup(null);
	            }
	        }
	        function hidePopup(event) {
	            // we don't hide popup if the event was on the child
	            if (event && event === childMouseClick) {
	                return;
	            }
	            if (event && event === childTouch) {
	                return;
	            }
	            // this method should only be called once. the client can have different
	            // paths, each one wanting to close, so this method may be called multiple
	            // times.
	            if (popupHidden) {
	                return;
	            }
	            popupHidden = true;
	            that.getPopupParent().removeChild(eChild);
	            eBody.removeEventListener('keydown', hidePopupOnEsc);
	            //eBody.removeEventListener('mousedown', hidePopupOnEsc);
	            eBody.removeEventListener('click', hidePopup);
	            eBody.removeEventListener('touchstart', hidePopup);
	            eBody.removeEventListener('contextmenu', hidePopup);
	            eChild.removeEventListener('click', consumeMouseClick);
	            eChild.removeEventListener('touchstart', consumeTouchClick);
	            //eChild.removeEventListener('mousedown', consumeClick);
	            if (closedCallback) {
	                closedCallback();
	            }
	        }
	        function consumeMouseClick(event) {
	            childMouseClick = event;
	        }
	        function consumeTouchClick(event) {
	            childTouch = event;
	        }
	        return hidePopup;
	    };
	    __decorate([
	        context_1.Autowired('gridCore'), 
	        __metadata('design:type', gridCore_1.GridCore)
	    ], PopupService.prototype, "gridCore", void 0);
	    PopupService = __decorate([
	        context_1.Bean('popupService'), 
	        __metadata('design:paramtypes', [])
	    ], PopupService);
	    return PopupService;
	})();
	exports.PopupService = PopupService;


/***/ },
/* 45 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
	 * @version v7.0.2
	 * @link http://www.ag-grid.com/
	 * @license MIT
	 */
	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var utils_1 = __webpack_require__(7);
	var context_1 = __webpack_require__(6);
	var gridOptionsWrapper_1 = __webpack_require__(3);
	var TextFilter = (function () {
	    function TextFilter() {
	    }
	    TextFilter.prototype.init = function (params) {
	        this.filterParams = params;
	        this.applyActive = params.apply === true;
	        this.newRowsActionKeep = params.newRowsAction === 'keep';
	        this.filterText = null;
	        this.filterType = TextFilter.CONTAINS;
	        this.createGui();
	    };
	    TextFilter.prototype.onNewRowsLoaded = function () {
	        if (!this.newRowsActionKeep) {
	            this.setType(TextFilter.CONTAINS);
	            this.setFilter(null);
	        }
	    };
	    TextFilter.prototype.afterGuiAttached = function () {
	        this.eFilterTextField.focus();
	    };
	    TextFilter.prototype.doesFilterPass = function (params) {
	        if (!this.filterText) {
	            return true;
	        }
	        var value = this.filterParams.valueGetter(params.node);
	        if (!value) {
	            if (this.filterType === TextFilter.NOT_EQUALS) {
	                // if there is no value, but the filter type was 'not equals',
	                // then it should pass, as a missing value is not equal whatever
	                // the user is filtering on
	                return true;
	            }
	            else {
	                // otherwise it's some type of comparison, to which empty value
	                // will always fail
	                return false;
	            }
	        }
	        var valueLowerCase = value.toString().toLowerCase();
	        switch (this.filterType) {
	            case TextFilter.CONTAINS:
	                return valueLowerCase.indexOf(this.filterText) >= 0;
	            case TextFilter.EQUALS:
	                return valueLowerCase === this.filterText;
	            case TextFilter.NOT_EQUALS:
	                return valueLowerCase != this.filterText;
	            case TextFilter.STARTS_WITH:
	                return valueLowerCase.indexOf(this.filterText) === 0;
	            case TextFilter.ENDS_WITH:
	                var index = valueLowerCase.lastIndexOf(this.filterText);
	                return index >= 0 && index === (valueLowerCase.length - this.filterText.length);
	            default:
	                // should never happen
	                console.warn('invalid filter type ' + this.filterType);
	                return false;
	        }
	    };
	    TextFilter.prototype.getGui = function () {
	        return this.eGui;
	    };
	    TextFilter.prototype.isFilterActive = function () {
	        return this.filterText !== null;
	    };
	    TextFilter.prototype.createTemplate = function () {
	        var translate = this.gridOptionsWrapper.getLocaleTextFunc();
	        return "<div>\n                    <div>\n                        <select class=\"ag-filter-select\" id=\"filterType\">\n                        <option value=\"" + TextFilter.CONTAINS + "\">" + translate('contains', 'Contains') + "</option>\n                        <option value=\"" + TextFilter.EQUALS + "\">" + translate('equals', 'Equals') + "</option>\n                        <option value=\"" + TextFilter.NOT_EQUALS + "\">" + translate('notEquals', 'Not equals') + "</option>\n                        <option value=\"" + TextFilter.STARTS_WITH + "\">" + translate('startsWith', 'Starts with') + "</option>\n                        <option value=\"" + TextFilter.ENDS_WITH + "\">" + translate('endsWith', 'Ends with') + "</option>\n                        </select>\n                    </div>\n                    <div>\n                        <input class=\"ag-filter-filter\" id=\"filterText\" type=\"text\" placeholder=\"" + translate('filterOoo', 'Filter...') + "\"/>\n                    </div>\n                    <div class=\"ag-filter-apply-panel\" id=\"applyPanel\">\n                        <button type=\"button\" id=\"applyButton\">" + translate('applyFilter', 'Apply Filter') + "</button>\n                    </div>\n                </div>";
	    };
	    TextFilter.prototype.createGui = function () {
	        this.eGui = utils_1.Utils.loadTemplate(this.createTemplate());
	        this.eFilterTextField = this.eGui.querySelector("#filterText");
	        this.eTypeSelect = this.eGui.querySelector("#filterType");
	        utils_1.Utils.addChangeListener(this.eFilterTextField, this.onFilterChanged.bind(this));
	        this.eTypeSelect.addEventListener("change", this.onTypeChanged.bind(this));
	        this.setupApply();
	    };
	    TextFilter.prototype.setupApply = function () {
	        var _this = this;
	        if (this.applyActive) {
	            this.eApplyButton = this.eGui.querySelector('#applyButton');
	            this.eApplyButton.addEventListener('click', function () {
	                _this.filterParams.filterChangedCallback();
	            });
	        }
	        else {
	            utils_1.Utils.removeElement(this.eGui, '#applyPanel');
	        }
	    };
	    TextFilter.prototype.onTypeChanged = function () {
	        this.filterType = this.eTypeSelect.value;
	        this.filterChanged();
	    };
	    TextFilter.prototype.onFilterChanged = function () {
	        var filterText = utils_1.Utils.makeNull(this.eFilterTextField.value);
	        if (filterText && filterText.trim() === '') {
	            filterText = null;
	        }
	        var newFilterText;
	        if (filterText !== null && filterText !== undefined) {
	            newFilterText = filterText.toLowerCase();
	        }
	        else {
	            newFilterText = null;
	        }
	        if (this.filterText !== newFilterText) {
	            this.filterText = newFilterText;
	            this.filterChanged();
	        }
	    };
	    TextFilter.prototype.filterChanged = function () {
	        this.filterParams.filterModifiedCallback();
	        if (!this.applyActive) {
	            this.filterParams.filterChangedCallback();
	        }
	    };
	    TextFilter.prototype.setType = function (type) {
	        this.filterType = type;
	        this.eTypeSelect.value = type;
	    };
	    TextFilter.prototype.setFilter = function (filter) {
	        filter = utils_1.Utils.makeNull(filter);
	        if (filter) {
	            this.filterText = filter.toLowerCase();
	            this.eFilterTextField.value = filter;
	        }
	        else {
	            this.filterText = null;
	            this.eFilterTextField.value = null;
	        }
	    };
	    TextFilter.prototype.getType = function () {
	        return this.filterType;
	    };
	    TextFilter.prototype.getFilter = function () {
	        return this.filterText;
	    };
	    TextFilter.prototype.getModel = function () {
	        if (this.isFilterActive()) {
	            return {
	                type: this.filterType,
	                filter: this.filterText
	            };
	        }
	        else {
	            return null;
	        }
	    };
	    TextFilter.prototype.setModel = function (model) {
	        if (model) {
	            this.setType(model.type);
	            this.setFilter(model.filter);
	        }
	        else {
	            this.setFilter(null);
	        }
	    };
	    TextFilter.CONTAINS = 'contains'; //1;
	    TextFilter.EQUALS = 'equals'; //2;
	    TextFilter.NOT_EQUALS = 'notEquals'; //3;
	    TextFilter.STARTS_WITH = 'startsWith'; //4;
	    TextFilter.ENDS_WITH = 'endsWith'; //5;
	    __decorate([
	        context_1.Autowired('gridOptionsWrapper'), 
	        __metadata('design:type', gridOptionsWrapper_1.GridOptionsWrapper)
	    ], TextFilter.prototype, "gridOptionsWrapper", void 0);
	    return TextFilter;
	})();
	exports.TextFilter = TextFilter;


/***/ },
/* 46 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
	 * @version v7.0.2
	 * @link http://www.ag-grid.com/
	 * @license MIT
	 */
	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var utils_1 = __webpack_require__(7);
	var context_1 = __webpack_require__(6);
	var gridOptionsWrapper_1 = __webpack_require__(3);
	var NumberFilter = (function () {
	    function NumberFilter() {
	    }
	    NumberFilter.prototype.init = function (params) {
	        this.filterParams = params;
	        this.applyActive = params.apply === true;
	        this.newRowsActionKeep = params.newRowsAction === 'keep';
	        this.filterNumber = null;
	        this.filterType = NumberFilter.EQUALS;
	        this.createGui();
	    };
	    NumberFilter.prototype.onNewRowsLoaded = function () {
	        if (!this.newRowsActionKeep) {
	            this.setType(NumberFilter.EQUALS);
	            this.setFilter(null);
	        }
	    };
	    NumberFilter.prototype.afterGuiAttached = function () {
	        this.eFilterTextField.focus();
	    };
	    NumberFilter.prototype.doesFilterPass = function (params) {
	        if (this.filterNumber === null) {
	            return true;
	        }
	        var value = this.filterParams.valueGetter(params.node);
	        if (!value && value !== 0) {
	            return false;
	        }
	        var valueAsNumber;
	        if (typeof value === 'number') {
	            valueAsNumber = value;
	        }
	        else {
	            valueAsNumber = parseFloat(value);
	        }
	        switch (this.filterType) {
	            case NumberFilter.EQUALS:
	                return valueAsNumber === this.filterNumber;
	            case NumberFilter.LESS_THAN:
	                return valueAsNumber < this.filterNumber;
	            case NumberFilter.GREATER_THAN:
	                return valueAsNumber > this.filterNumber;
	            case NumberFilter.LESS_THAN_OR_EQUAL:
	                return valueAsNumber <= this.filterNumber;
	            case NumberFilter.GREATER_THAN_OR_EQUAL:
	                return valueAsNumber >= this.filterNumber;
	            case NumberFilter.NOT_EQUAL:
	                return valueAsNumber != this.filterNumber;
	            default:
	                // should never happen
	                console.warn('invalid filter type ' + this.filterType);
	                return false;
	        }
	    };
	    NumberFilter.prototype.getGui = function () {
	        return this.eGui;
	    };
	    NumberFilter.prototype.isFilterActive = function () {
	        return this.filterNumber !== null;
	    };
	    NumberFilter.prototype.createTemplate = function () {
	        var translate = this.gridOptionsWrapper.getLocaleTextFunc();
	        return "<div>\n                    <div>\n                        <select class=\"ag-filter-select\" id=\"filterType\">\n                            <option value=\"" + NumberFilter.EQUALS + "\">" + translate('equals', 'Equals') + "</option>\n                            <option value=\"" + NumberFilter.NOT_EQUAL + "\">" + translate('notEqual', 'Not equal') + "</option>\n                            <option value=\"" + NumberFilter.LESS_THAN + "\">" + translate('lessThan', 'Less than') + "</option>\n                            <option value=\"" + NumberFilter.LESS_THAN_OR_EQUAL + "\">" + translate('lessThanOrEqual', 'Less than or equal') + "</option>\n                            <option value=\"" + NumberFilter.GREATER_THAN + "\">" + translate('greaterThan', 'Greater than') + "</option>\n                            <option value=\"" + NumberFilter.GREATER_THAN_OR_EQUAL + "\">" + translate('greaterThanOrEqual', 'Greater than or equal') + "</option>\n                        </select>\n                    </div>\n                    <div>\n                        <input class=\"ag-filter-filter\" id=\"filterText\" type=\"text\" placeholder=\"" + translate('filterOoo', 'Filter...') + "\"/>\n                    </div>\n                    <div class=\"ag-filter-apply-panel\" id=\"applyPanel\">\n                        <button type=\"button\" id=\"applyButton\">" + translate('applyFilter', 'Apply Filter') + "</button>\n                    </div>\n                </div>";
	    };
	    NumberFilter.prototype.createGui = function () {
	        this.eGui = utils_1.Utils.loadTemplate(this.createTemplate());
	        this.eFilterTextField = this.eGui.querySelector("#filterText");
	        this.eTypeSelect = this.eGui.querySelector("#filterType");
	        utils_1.Utils.addChangeListener(this.eFilterTextField, this.onFilterChanged.bind(this));
	        this.eTypeSelect.addEventListener("change", this.onTypeChanged.bind(this));
	        this.setupApply();
	    };
	    NumberFilter.prototype.setupApply = function () {
	        var _this = this;
	        if (this.applyActive) {
	            this.eApplyButton = this.eGui.querySelector('#applyButton');
	            this.eApplyButton.addEventListener('click', function () {
	                _this.filterParams.filterChangedCallback();
	            });
	        }
	        else {
	            utils_1.Utils.removeElement(this.eGui, '#applyPanel');
	        }
	    };
	    NumberFilter.prototype.onTypeChanged = function () {
	        this.filterType = this.eTypeSelect.value;
	        this.filterChanged();
	    };
	    NumberFilter.prototype.filterChanged = function () {
	        this.filterParams.filterModifiedCallback();
	        if (!this.applyActive) {
	            this.filterParams.filterChangedCallback();
	        }
	    };
	    NumberFilter.prototype.onFilterChanged = function () {
	        var filterText = utils_1.Utils.makeNull(this.eFilterTextField.value);
	        if (filterText && filterText.trim() === '') {
	            filterText = null;
	        }
	        var newFilter;
	        if (filterText !== null && filterText !== undefined) {
	            newFilter = parseFloat(filterText);
	        }
	        else {
	            newFilter = null;
	        }
	        if (this.filterNumber !== newFilter) {
	            this.filterNumber = newFilter;
	            this.filterChanged();
	        }
	    };
	    NumberFilter.prototype.setType = function (type) {
	        this.filterType = type;
	        this.eTypeSelect.value = type;
	    };
	    NumberFilter.prototype.setFilter = function (filter) {
	        filter = utils_1.Utils.makeNull(filter);
	        if (filter !== null && !(typeof filter === 'number')) {
	            filter = parseFloat(filter);
	        }
	        this.filterNumber = filter;
	        this.eFilterTextField.value = filter;
	    };
	    NumberFilter.prototype.getFilter = function () {
	        return this.filterNumber;
	    };
	    NumberFilter.prototype.getModel = function () {
	        if (this.isFilterActive()) {
	            return {
	                type: this.filterType,
	                filter: this.filterNumber
	            };
	        }
	        else {
	            return null;
	        }
	    };
	    NumberFilter.prototype.setModel = function (model) {
	        if (model) {
	            this.setType(model.type);
	            this.setFilter(model.filter);
	        }
	        else {
	            this.setFilter(null);
	        }
	    };
	    NumberFilter.EQUALS = 'equals'; // 1;
	    NumberFilter.NOT_EQUAL = 'notEqual'; //2;
	    NumberFilter.LESS_THAN = 'lessThan'; //3;
	    NumberFilter.LESS_THAN_OR_EQUAL = 'lessThanOrEqual'; //4;
	    NumberFilter.GREATER_THAN = 'greaterThan'; //5;
	    NumberFilter.GREATER_THAN_OR_EQUAL = 'greaterThanOrEqual'; //6;
	    __decorate([
	        context_1.Autowired('gridOptionsWrapper'), 
	        __metadata('design:type', gridOptionsWrapper_1.GridOptionsWrapper)
	    ], NumberFilter.prototype, "gridOptionsWrapper", void 0);
	    return NumberFilter;
	})();
	exports.NumberFilter = NumberFilter;


/***/ },
/* 47 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
	 * @version v7.0.2
	 * @link http://www.ag-grid.com/
	 * @license MIT
	 */
	var utils_1 = __webpack_require__(7);
	var eventService_1 = __webpack_require__(4);
	var gridOptionsWrapper_1 = __webpack_require__(3);
	var Component = (function () {
	    function Component(template) {
	        this.destroyFunctions = [];
	        this.childComponents = [];
	        this.annotatedEventListeners = [];
	        this.visible = true;
	        if (template) {
	            this.setTemplate(template);
	        }
	    }
	    Component.prototype.instantiate = function (context) {
	        this.instantiateRecurse(this.getGui(), context);
	    };
	    Component.prototype.instantiateRecurse = function (parentNode, context) {
	        var childCount = parentNode.childNodes ? parentNode.childNodes.length : 0;
	        for (var i = 0; i < childCount; i++) {
	            var childNode = parentNode.childNodes[i];
	            var newComponent = context.createComponent(childNode);
	            if (newComponent) {
	                this.swapComponentForNode(newComponent, parentNode, childNode);
	            }
	            else {
	                if (childNode.childNodes) {
	                    this.instantiateRecurse(childNode, context);
	                }
	            }
	        }
	    };
	    Component.prototype.swapComponentForNode = function (newComponent, parentNode, childNode) {
	        parentNode.replaceChild(newComponent.getGui(), childNode);
	        this.childComponents.push(newComponent);
	        this.swapInComponentForQuerySelectors(newComponent, childNode);
	    };
	    Component.prototype.swapInComponentForQuerySelectors = function (newComponent, childNode) {
	        var metaData = this.__agComponentMetaData;
	        if (!metaData || !metaData.querySelectors) {
	            return;
	        }
	        var thisNoType = this;
	        metaData.querySelectors.forEach(function (querySelector) {
	            if (thisNoType[querySelector.attributeName] === childNode) {
	                thisNoType[querySelector.attributeName] = newComponent;
	            }
	        });
	    };
	    Component.prototype.setTemplate = function (template) {
	        this.eGui = utils_1.Utils.loadTemplate(template);
	        this.eGui.__agComponent = this;
	        this.addAnnotatedEventListeners();
	        this.wireQuerySelectors();
	    };
	    Component.prototype.wireQuerySelectors = function () {
	        var _this = this;
	        var metaData = this.__agComponentMetaData;
	        if (!metaData || !metaData.querySelectors) {
	            return;
	        }
	        if (!this.eGui) {
	            return;
	        }
	        var thisNoType = this;
	        metaData.querySelectors.forEach(function (querySelector) {
	            var resultOfQuery = _this.eGui.querySelector(querySelector.querySelector);
	            if (resultOfQuery) {
	                var backingComponent = resultOfQuery.__agComponent;
	                if (backingComponent) {
	                    thisNoType[querySelector.attributeName] = backingComponent;
	                }
	                else {
	                    thisNoType[querySelector.attributeName] = resultOfQuery;
	                }
	            }
	            else {
	            }
	        });
	    };
	    Component.prototype.addAnnotatedEventListeners = function () {
	        var _this = this;
	        this.removeAnnotatedEventListeners();
	        var metaData = this.__agComponentMetaData;
	        if (!metaData || !metaData.listenerMethods) {
	            return;
	        }
	        if (!this.eGui) {
	            return;
	        }
	        if (!this.annotatedEventListeners) {
	            this.annotatedEventListeners = [];
	        }
	        metaData.listenerMethods.forEach(function (eventListener) {
	            var listener = _this[eventListener.methodName].bind(_this);
	            _this.eGui.addEventListener(eventListener.eventName, listener);
	            _this.annotatedEventListeners.push({ eventName: eventListener.eventName, listener: listener });
	        });
	    };
	    Component.prototype.removeAnnotatedEventListeners = function () {
	        var _this = this;
	        if (!this.annotatedEventListeners) {
	            return;
	        }
	        if (!this.eGui) {
	            return;
	        }
	        this.annotatedEventListeners.forEach(function (eventListener) {
	            _this.eGui.removeEventListener(eventListener.eventName, eventListener.listener);
	        });
	        this.annotatedEventListeners = null;
	    };
	    Component.prototype.addEventListener = function (eventType, listener) {
	        if (!this.localEventService) {
	            this.localEventService = new eventService_1.EventService();
	        }
	        this.localEventService.addEventListener(eventType, listener);
	    };
	    Component.prototype.removeEventListener = function (eventType, listener) {
	        if (this.localEventService) {
	            this.localEventService.removeEventListener(eventType, listener);
	        }
	    };
	    Component.prototype.dispatchEventAsync = function (eventType, event) {
	        var _this = this;
	        setTimeout(function () { return _this.dispatchEvent(eventType, event); }, 0);
	    };
	    Component.prototype.dispatchEvent = function (eventType, event) {
	        if (this.localEventService) {
	            this.localEventService.dispatchEvent(eventType, event);
	        }
	    };
	    Component.prototype.getGui = function () {
	        return this.eGui;
	    };
	    Component.prototype.queryForHtmlElement = function (cssSelector) {
	        return this.eGui.querySelector(cssSelector);
	    };
	    Component.prototype.queryForHtmlInputElement = function (cssSelector) {
	        return this.eGui.querySelector(cssSelector);
	    };
	    Component.prototype.appendChild = function (newChild) {
	        if (utils_1.Utils.isNodeOrElement(newChild)) {
	            this.eGui.appendChild(newChild);
	        }
	        else {
	            var childComponent = newChild;
	            this.eGui.appendChild(childComponent.getGui());
	            this.childComponents.push(childComponent);
	        }
	    };
	    Component.prototype.isVisible = function () {
	        return this.visible;
	    };
	    Component.prototype.setVisible = function (visible) {
	        if (visible !== this.visible) {
	            this.visible = visible;
	            utils_1.Utils.addOrRemoveCssClass(this.eGui, 'ag-hidden', !visible);
	            this.dispatchEvent(Component.EVENT_VISIBLE_CHANGED, { visible: this.visible });
	        }
	    };
	    Component.prototype.addOrRemoveCssClass = function (className, addOrRemove) {
	        utils_1.Utils.addOrRemoveCssClass(this.eGui, className, addOrRemove);
	    };
	    Component.prototype.destroy = function () {
	        this.childComponents.forEach(function (childComponent) { return childComponent.destroy(); });
	        this.destroyFunctions.forEach(function (func) { return func(); });
	        this.childComponents.length = 0;
	        this.destroyFunctions.length = 0;
	        this.removeAnnotatedEventListeners();
	    };
	    Component.prototype.addGuiEventListener = function (event, listener) {
	        var _this = this;
	        this.getGui().addEventListener(event, listener);
	        this.destroyFunctions.push(function () { return _this.getGui().removeEventListener(event, listener); });
	    };
	    Component.prototype.addDestroyableEventListener = function (eElement, event, listener) {
	        if (eElement instanceof HTMLElement) {
	            eElement.addEventListener(event, listener);
	        }
	        else if (eElement instanceof gridOptionsWrapper_1.GridOptionsWrapper) {
	            eElement.addEventListener(event, listener);
	        }
	        else {
	            eElement.addEventListener(event, listener);
	        }
	        this.destroyFunctions.push(function () {
	            if (eElement instanceof HTMLElement) {
	                eElement.removeEventListener(event, listener);
	            }
	            else if (eElement instanceof gridOptionsWrapper_1.GridOptionsWrapper) {
	                eElement.removeEventListener(event, listener);
	            }
	            else {
	                eElement.removeEventListener(event, listener);
	            }
	        });
	    };
	    Component.prototype.addDestroyFunc = function (func) {
	        this.destroyFunctions.push(func);
	    };
	    Component.prototype.addCssClass = function (className) {
	        utils_1.Utils.addCssClass(this.getGui(), className);
	    };
	    Component.prototype.getAttribute = function (key) {
	        var eGui = this.getGui();
	        if (eGui) {
	            return eGui.getAttribute(key);
	        }
	        else {
	            return null;
	        }
	    };
	    Component.EVENT_VISIBLE_CHANGED = 'visibleChanged';
	    return Component;
	})();
	exports.Component = Component;


/***/ },
/* 48 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
	 * @version v7.0.2
	 * @link http://www.ag-grid.com/
	 * @license MIT
	 */
	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var context_1 = __webpack_require__(6);
	var utils_1 = __webpack_require__(7);
	var textCellEditor_1 = __webpack_require__(49);
	var selectCellEditor_1 = __webpack_require__(50);
	var popupEditorWrapper_1 = __webpack_require__(51);
	var popupTextCellEditor_1 = __webpack_require__(52);
	var popupSelectCellEditor_1 = __webpack_require__(53);
	var gridOptionsWrapper_1 = __webpack_require__(3);
	var largeTextCellEditor_1 = __webpack_require__(54);
	var CellEditorFactory = (function () {
	    function CellEditorFactory() {
	        this.cellEditorMap = {};
	    }
	    CellEditorFactory.prototype.init = function () {
	        this.cellEditorMap[CellEditorFactory.TEXT] = textCellEditor_1.TextCellEditor;
	        this.cellEditorMap[CellEditorFactory.SELECT] = selectCellEditor_1.SelectCellEditor;
	        this.cellEditorMap[CellEditorFactory.POPUP_TEXT] = popupTextCellEditor_1.PopupTextCellEditor;
	        this.cellEditorMap[CellEditorFactory.POPUP_SELECT] = popupSelectCellEditor_1.PopupSelectCellEditor;
	        this.cellEditorMap[CellEditorFactory.LARGE_TEXT] = largeTextCellEditor_1.LargeTextCellEditor;
	    };
	    CellEditorFactory.prototype.addCellEditor = function (key, cellEditor) {
	        this.cellEditorMap[key] = cellEditor;
	    };
	    // private registerEditorsFromGridOptions(): void {
	    //     var userProvidedCellEditors = this.gridOptionsWrapper.getCellEditors();
	    //     _.iterateObject(userProvidedCellEditors, (key: string, cellEditor: {new(): ICellEditor})=> {
	    //         this.addCellEditor(key, cellEditor);
	    //     });
	    // }
	    CellEditorFactory.prototype.createCellEditor = function (key, params) {
	        var CellEditorClass;
	        if (utils_1.Utils.missing(key)) {
	            CellEditorClass = this.cellEditorMap[CellEditorFactory.TEXT];
	        }
	        else if (typeof key === 'string') {
	            CellEditorClass = this.cellEditorMap[key];
	            if (utils_1.Utils.missing(CellEditorClass)) {
	                console.warn('ag-Grid: unable to find cellEditor for key ' + key);
	                CellEditorClass = this.cellEditorMap[CellEditorFactory.TEXT];
	            }
	        }
	        else {
	            CellEditorClass = key;
	        }
	        var cellEditor = new CellEditorClass();
	        this.context.wireBean(cellEditor);
	        // we have to call init first, otherwise when using the frameworks, the wrapper
	        // classes won't be set up
	        if (cellEditor.init) {
	            cellEditor.init(params);
	        }
	        if (cellEditor.isPopup && cellEditor.isPopup()) {
	            if (this.gridOptionsWrapper.isFullRowEdit()) {
	                console.warn('ag-Grid: popup cellEditor does not work with fullRowEdit - you cannot use them both ' +
	                    '- either turn off fullRowEdit, or stop using popup editors.');
	            }
	            cellEditor = new popupEditorWrapper_1.PopupEditorWrapper(cellEditor);
	            cellEditor.init(params);
	        }
	        return cellEditor;
	    };
	    CellEditorFactory.TEXT = 'text';
	    CellEditorFactory.SELECT = 'select';
	    CellEditorFactory.POPUP_TEXT = 'popupText';
	    CellEditorFactory.POPUP_SELECT = 'popupSelect';
	    CellEditorFactory.LARGE_TEXT = 'largeText';
	    __decorate([
	        context_1.Autowired('context'), 
	        __metadata('design:type', context_1.Context)
	    ], CellEditorFactory.prototype, "context", void 0);
	    __decorate([
	        context_1.Autowired('gridOptionsWrapper'), 
	        __metadata('design:type', gridOptionsWrapper_1.GridOptionsWrapper)
	    ], CellEditorFactory.prototype, "gridOptionsWrapper", void 0);
	    __decorate([
	        context_1.PostConstruct, 
	        __metadata('design:type', Function), 
	        __metadata('design:paramtypes', []), 
	        __metadata('design:returntype', void 0)
	    ], CellEditorFactory.prototype, "init", null);
	    CellEditorFactory = __decorate([
	        context_1.Bean('cellEditorFactory'), 
	        __metadata('design:paramtypes', [])
	    ], CellEditorFactory);
	    return CellEditorFactory;
	})();
	exports.CellEditorFactory = CellEditorFactory;


/***/ },
/* 49 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
	 * @version v7.0.2
	 * @link http://www.ag-grid.com/
	 * @license MIT
	 */
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var constants_1 = __webpack_require__(8);
	var component_1 = __webpack_require__(47);
	var utils_1 = __webpack_require__(7);
	var TextCellEditor = (function (_super) {
	    __extends(TextCellEditor, _super);
	    function TextCellEditor() {
	        _super.call(this, TextCellEditor.TEMPLATE);
	    }
	    TextCellEditor.prototype.init = function (params) {
	        var eInput = this.getGui();
	        var startValue;
	        // cellStartedEdit is only false if we are doing fullRow editing
	        if (params.cellStartedEdit) {
	            this.focusAfterAttached = true;
	            var keyPressBackspaceOrDelete = params.keyPress === constants_1.Constants.KEY_BACKSPACE
	                || params.keyPress === constants_1.Constants.KEY_DELETE;
	            if (keyPressBackspaceOrDelete) {
	                startValue = '';
	            }
	            else if (params.charPress) {
	                startValue = params.charPress;
	            }
	            else {
	                startValue = params.value;
	                if (params.keyPress !== constants_1.Constants.KEY_F2) {
	                    this.highlightAllOnFocus = true;
	                }
	            }
	        }
	        else {
	            this.focusAfterAttached = false;
	            startValue = params.value;
	        }
	        if (utils_1.Utils.exists(startValue)) {
	            eInput.value = startValue;
	        }
	        this.addDestroyableEventListener(eInput, 'keydown', function (event) {
	            var isNavigationKey = event.keyCode === constants_1.Constants.KEY_LEFT || event.keyCode === constants_1.Constants.KEY_RIGHT;
	            if (isNavigationKey) {
	                event.stopPropagation();
	            }
	        });
	    };
	    TextCellEditor.prototype.afterGuiAttached = function () {
	        if (!this.focusAfterAttached) {
	            return;
	        }
	        var eInput = this.getGui();
	        eInput.focus();
	        if (this.highlightAllOnFocus) {
	            eInput.select();
	        }
	        else {
	            // when we started editing, we want the carot at the end, not the start.
	            // this comes into play in two scenarios: a) when user hits F2 and b)
	            // when user hits a printable character, then on IE (and only IE) the carot
	            // was placed after the first character, thus 'apply' would end up as 'pplea'
	            var length = eInput.value ? eInput.value.length : 0;
	            if (length > 0) {
	                eInput.setSelectionRange(length, length);
	            }
	        }
	    };
	    // gets called when tabbing trough cells and in full row edit mode
	    TextCellEditor.prototype.focusIn = function () {
	        var eInput = this.getGui();
	        eInput.focus();
	        eInput.select();
	    };
	    TextCellEditor.prototype.getValue = function () {
	        var eInput = this.getGui();
	        return eInput.value;
	    };
	    TextCellEditor.TEMPLATE = '<input class="ag-cell-edit-input" type="text"/>';
	    return TextCellEditor;
	})(component_1.Component);
	exports.TextCellEditor = TextCellEditor;


/***/ },
/* 50 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
	 * @version v7.0.2
	 * @link http://www.ag-grid.com/
	 * @license MIT
	 */
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var component_1 = __webpack_require__(47);
	var utils_1 = __webpack_require__(7);
	var constants_1 = __webpack_require__(8);
	var SelectCellEditor = (function (_super) {
	    __extends(SelectCellEditor, _super);
	    function SelectCellEditor() {
	        _super.call(this, '<div class="ag-cell-edit-input"><select class="ag-cell-edit-input"/></div>');
	        this.eSelect = this.getGui().querySelector('select');
	    }
	    SelectCellEditor.prototype.init = function (params) {
	        var _this = this;
	        this.focusAfterAttached = params.cellStartedEdit;
	        if (utils_1.Utils.missing(params.values)) {
	            console.log('ag-Grid: no values found for select cellEditor');
	            return;
	        }
	        params.values.forEach(function (value) {
	            var option = document.createElement('option');
	            option.value = value;
	            option.text = value;
	            if (params.value === value) {
	                option.selected = true;
	            }
	            _this.eSelect.appendChild(option);
	        });
	        this.addDestroyableEventListener(this.eSelect, 'change', function () { return params.stopEditing(); });
	        this.addDestroyableEventListener(this.eSelect, 'keydown', function (event) {
	            var isNavigationKey = event.keyCode === constants_1.Constants.KEY_UP || event.keyCode === constants_1.Constants.KEY_DOWN;
	            if (isNavigationKey) {
	                event.stopPropagation();
	            }
	        });
	        this.addDestroyableEventListener(this.eSelect, 'mousedown', function (event) {
	            event.stopPropagation();
	        });
	    };
	    SelectCellEditor.prototype.afterGuiAttached = function () {
	        if (this.focusAfterAttached) {
	            this.eSelect.focus();
	        }
	    };
	    SelectCellEditor.prototype.focusIn = function () {
	        this.eSelect.focus();
	    };
	    SelectCellEditor.prototype.getValue = function () {
	        return this.eSelect.value;
	    };
	    return SelectCellEditor;
	})(component_1.Component);
	exports.SelectCellEditor = SelectCellEditor;


/***/ },
/* 51 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
	 * @version v7.0.2
	 * @link http://www.ag-grid.com/
	 * @license MIT
	 */
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var component_1 = __webpack_require__(47);
	var PopupEditorWrapper = (function (_super) {
	    __extends(PopupEditorWrapper, _super);
	    function PopupEditorWrapper(cellEditor) {
	        _super.call(this, '<div class="ag-popup-editor"/>');
	        this.getGuiCalledOnChild = false;
	        this.cellEditor = cellEditor;
	        this.addDestroyFunc(function () { return cellEditor.destroy(); });
	        this.addDestroyableEventListener(
	        // this needs to be 'super' and not 'this' as if we call 'this',
	        // it ends up called 'getGui()' on the child before 'init' was called,
	        // which is not good
	        _super.prototype.getGui.call(this), 'keydown', this.onKeyDown.bind(this));
	    }
	    PopupEditorWrapper.prototype.onKeyDown = function (event) {
	        this.params.onKeyDown(event);
	    };
	    PopupEditorWrapper.prototype.getGui = function () {
	        // we call getGui() on child here (rather than in the constructor)
	        // as we should wait for 'init' to be called on child first.
	        if (!this.getGuiCalledOnChild) {
	            this.appendChild(this.cellEditor.getGui());
	            this.getGuiCalledOnChild = true;
	        }
	        return _super.prototype.getGui.call(this);
	    };
	    PopupEditorWrapper.prototype.init = function (params) {
	        this.params = params;
	    };
	    PopupEditorWrapper.prototype.afterGuiAttached = function () {
	        if (this.cellEditor.afterGuiAttached) {
	            this.cellEditor.afterGuiAttached();
	        }
	    };
	    PopupEditorWrapper.prototype.getValue = function () {
	        return this.cellEditor.getValue();
	    };
	    PopupEditorWrapper.prototype.isPopup = function () {
	        return true;
	    };
	    PopupEditorWrapper.prototype.isCancelBeforeStart = function () {
	        if (this.cellEditor.isCancelBeforeStart) {
	            return this.cellEditor.isCancelBeforeStart();
	        }
	    };
	    PopupEditorWrapper.prototype.isCancelAfterEnd = function () {
	        if (this.cellEditor.isCancelAfterEnd) {
	            return this.cellEditor.isCancelAfterEnd();
	        }
	    };
	    PopupEditorWrapper.prototype.focusIn = function () {
	        if (this.cellEditor.focusIn) {
	            this.cellEditor.focusIn();
	        }
	    };
	    PopupEditorWrapper.prototype.focusOut = function () {
	        if (this.cellEditor.focusOut) {
	            this.cellEditor.focusOut();
	        }
	    };
	    return PopupEditorWrapper;
	})(component_1.Component);
	exports.PopupEditorWrapper = PopupEditorWrapper;


/***/ },
/* 52 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
	 * @version v7.0.2
	 * @link http://www.ag-grid.com/
	 * @license MIT
	 */
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var textCellEditor_1 = __webpack_require__(49);
	var PopupTextCellEditor = (function (_super) {
	    __extends(PopupTextCellEditor, _super);
	    function PopupTextCellEditor() {
	        _super.apply(this, arguments);
	    }
	    PopupTextCellEditor.prototype.isPopup = function () {
	        return true;
	    };
	    return PopupTextCellEditor;
	})(textCellEditor_1.TextCellEditor);
	exports.PopupTextCellEditor = PopupTextCellEditor;


/***/ },
/* 53 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
	 * @version v7.0.2
	 * @link http://www.ag-grid.com/
	 * @license MIT
	 */
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var selectCellEditor_1 = __webpack_require__(50);
	var PopupSelectCellEditor = (function (_super) {
	    __extends(PopupSelectCellEditor, _super);
	    function PopupSelectCellEditor() {
	        _super.apply(this, arguments);
	    }
	    PopupSelectCellEditor.prototype.isPopup = function () {
	        return true;
	    };
	    return PopupSelectCellEditor;
	})(selectCellEditor_1.SelectCellEditor);
	exports.PopupSelectCellEditor = PopupSelectCellEditor;


/***/ },
/* 54 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
	 * @version v7.0.2
	 * @link http://www.ag-grid.com/
	 * @license MIT
	 */
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var component_1 = __webpack_require__(47);
	var constants_1 = __webpack_require__(8);
	var utils_1 = __webpack_require__(7);
	var LargeTextCellEditor = (function (_super) {
	    __extends(LargeTextCellEditor, _super);
	    function LargeTextCellEditor() {
	        _super.call(this, LargeTextCellEditor.TEMPLATE);
	    }
	    LargeTextCellEditor.prototype.init = function (params) {
	        this.params = params;
	        this.focusAfterAttached = params.cellStartedEdit;
	        this.textarea = document.createElement("textarea");
	        this.textarea.maxLength = params.maxLength ? params.maxLength : "200";
	        this.textarea.cols = params.cols ? params.cols : "60";
	        this.textarea.rows = params.rows ? params.rows : "10";
	        if (utils_1.Utils.exists(params.value)) {
	            this.textarea.value = params.value.toString();
	        }
	        this.getGui().querySelector('.ag-large-textarea').appendChild(this.textarea);
	        this.addGuiEventListener('keydown', this.onKeyDown.bind(this));
	    };
	    LargeTextCellEditor.prototype.onKeyDown = function (event) {
	        var key = event.which || event.keyCode;
	        if (key == constants_1.Constants.KEY_LEFT ||
	            key == constants_1.Constants.KEY_UP ||
	            key == constants_1.Constants.KEY_RIGHT ||
	            key == constants_1.Constants.KEY_DOWN ||
	            (event.shiftKey && key == constants_1.Constants.KEY_ENTER)) {
	            event.stopPropagation();
	        }
	    };
	    LargeTextCellEditor.prototype.afterGuiAttached = function () {
	        if (this.focusAfterAttached) {
	            this.textarea.focus();
	        }
	    };
	    LargeTextCellEditor.prototype.getValue = function () {
	        return this.textarea.value;
	    };
	    LargeTextCellEditor.prototype.isPopup = function () {
	        return true;
	    };
	    LargeTextCellEditor.TEMPLATE = 
	    // tab index is needed so we can focus, which is needed for keyboard events
	    '<div class="ag-large-text" tabindex="0">' +
	        '<div class="ag-large-textarea"></div>' +
	        '</div>';
	    return LargeTextCellEditor;
	})(component_1.Component);
	exports.LargeTextCellEditor = LargeTextCellEditor;


/***/ },
/* 55 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
	 * @version v7.0.2
	 * @link http://www.ag-grid.com/
	 * @license MIT
	 */
	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var context_1 = __webpack_require__(6);
	var utils_1 = __webpack_require__(7);
	var gridOptionsWrapper_1 = __webpack_require__(3);
	var eventService_1 = __webpack_require__(4);
	var expressionService_1 = __webpack_require__(18);
	var animateSlideCellRenderer_1 = __webpack_require__(56);
	var animateShowChangeCellRenderer_1 = __webpack_require__(57);
	var groupCellRenderer_1 = __webpack_require__(58);
	var CellRendererFactory = (function () {
	    function CellRendererFactory() {
	        this.cellRendererMap = {};
	    }
	    CellRendererFactory.prototype.init = function () {
	        this.cellRendererMap[CellRendererFactory.ANIMATE_SLIDE] = animateSlideCellRenderer_1.AnimateSlideCellRenderer;
	        this.cellRendererMap[CellRendererFactory.ANIMATE_SHOW_CHANGE] = animateShowChangeCellRenderer_1.AnimateShowChangeCellRenderer;
	        this.cellRendererMap[CellRendererFactory.GROUP] = groupCellRenderer_1.GroupCellRenderer;
	        // this.registerRenderersFromGridOptions();
	    };
	    // private registerRenderersFromGridOptions(): void {
	    //     var userProvidedCellRenderers = this.gridOptionsWrapper.getCellRenderers();
	    //     _.iterateObject(userProvidedCellRenderers, (key: string, cellRenderer: {new(): ICellRenderer} | ICellRendererFunc)=> {
	    //         this.addCellRenderer(key, cellRenderer);
	    //     });
	    // }
	    CellRendererFactory.prototype.addCellRenderer = function (key, cellRenderer) {
	        this.cellRendererMap[key] = cellRenderer;
	    };
	    CellRendererFactory.prototype.getCellRenderer = function (key) {
	        var result = this.cellRendererMap[key];
	        if (utils_1.Utils.missing(result)) {
	            console.warn('ag-Grid: unable to find cellRenderer for key ' + key);
	            return null;
	        }
	        return result;
	    };
	    CellRendererFactory.ANIMATE_SLIDE = 'animateSlide';
	    CellRendererFactory.ANIMATE_SHOW_CHANGE = 'animateShowChange';
	    CellRendererFactory.GROUP = 'group';
	    __decorate([
	        context_1.Autowired('gridOptionsWrapper'), 
	        __metadata('design:type', gridOptionsWrapper_1.GridOptionsWrapper)
	    ], CellRendererFactory.prototype, "gridOptionsWrapper", void 0);
	    __decorate([
	        context_1.Autowired('expressionService'), 
	        __metadata('design:type', expressionService_1.ExpressionService)
	    ], CellRendererFactory.prototype, "expressionService", void 0);
	    __decorate([
	        context_1.Autowired('eventService'), 
	        __metadata('design:type', eventService_1.EventService)
	    ], CellRendererFactory.prototype, "eventService", void 0);
	    __decorate([
	        context_1.PostConstruct, 
	        __metadata('design:type', Function), 
	        __metadata('design:paramtypes', []), 
	        __metadata('design:returntype', void 0)
	    ], CellRendererFactory.prototype, "init", null);
	    CellRendererFactory = __decorate([
	        context_1.Bean('cellRendererFactory'), 
	        __metadata('design:paramtypes', [])
	    ], CellRendererFactory);
	    return CellRendererFactory;
	})();
	exports.CellRendererFactory = CellRendererFactory;


/***/ },
/* 56 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
	 * @version v7.0.2
	 * @link http://www.ag-grid.com/
	 * @license MIT
	 */
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var utils_1 = __webpack_require__(7);
	var component_1 = __webpack_require__(47);
	var AnimateSlideCellRenderer = (function (_super) {
	    __extends(AnimateSlideCellRenderer, _super);
	    function AnimateSlideCellRenderer() {
	        _super.call(this, AnimateSlideCellRenderer.TEMPLATE);
	        this.refreshCount = 0;
	        this.eCurrent = this.queryForHtmlElement('.ag-value-slide-current');
	    }
	    AnimateSlideCellRenderer.prototype.init = function (params) {
	        this.params = params;
	        this.refresh(params);
	    };
	    AnimateSlideCellRenderer.prototype.addSlideAnimation = function () {
	        var _this = this;
	        this.refreshCount++;
	        // below we keep checking this, and stop working on the animation
	        // if it no longer matches - this means another animation has started
	        // and this one is stale.
	        var refreshCountCopy = this.refreshCount;
	        // if old animation, remove it
	        if (this.ePrevious) {
	            this.getGui().removeChild(this.ePrevious);
	        }
	        this.ePrevious = utils_1.Utils.loadTemplate('<span class="ag-value-slide-previous ag-value-slide-out"></span>');
	        this.ePrevious.innerHTML = this.eCurrent.innerHTML;
	        this.getGui().insertBefore(this.ePrevious, this.eCurrent);
	        // having timeout of 0 allows use to skip to the next css turn,
	        // so we know the previous css classes have been applied. so the
	        // complex set of setTimeout below creates the animation
	        setTimeout(function () {
	            if (refreshCountCopy !== _this.refreshCount) {
	                return;
	            }
	            utils_1.Utils.addCssClass(_this.ePrevious, 'ag-value-slide-out-end');
	        }, 50);
	        setTimeout(function () {
	            if (refreshCountCopy !== _this.refreshCount) {
	                return;
	            }
	            _this.getGui().removeChild(_this.ePrevious);
	            _this.ePrevious = null;
	        }, 3000);
	    };
	    AnimateSlideCellRenderer.prototype.refresh = function (params) {
	        var value = params.value;
	        if (utils_1.Utils.missing(value)) {
	            value = '';
	        }
	        if (value === this.lastValue) {
	            return;
	        }
	        this.addSlideAnimation();
	        this.lastValue = value;
	        if (utils_1.Utils.exists(params.valueFormatted)) {
	            this.eCurrent.innerHTML = params.valueFormatted;
	        }
	        else if (utils_1.Utils.exists(params.value)) {
	            this.eCurrent.innerHTML = value;
	        }
	        else {
	            this.eCurrent.innerHTML = '';
	        }
	    };
	    AnimateSlideCellRenderer.TEMPLATE = '<span>' +
	        '<span class="ag-value-slide-current"></span>' +
	        '</span>';
	    return AnimateSlideCellRenderer;
	})(component_1.Component);
	exports.AnimateSlideCellRenderer = AnimateSlideCellRenderer;


/***/ },
/* 57 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
	 * @version v7.0.2
	 * @link http://www.ag-grid.com/
	 * @license MIT
	 */
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var utils_1 = __webpack_require__(7);
	var component_1 = __webpack_require__(47);
	var ARROW_UP = '&#65514;';
	var ARROW_DOWN = '&#65516;';
	var AnimateShowChangeCellRenderer = (function (_super) {
	    __extends(AnimateShowChangeCellRenderer, _super);
	    function AnimateShowChangeCellRenderer() {
	        _super.call(this, AnimateShowChangeCellRenderer.TEMPLATE);
	        this.refreshCount = 0;
	    }
	    AnimateShowChangeCellRenderer.prototype.init = function (params) {
	        this.params = params;
	        this.eValue = this.queryForHtmlElement('.ag-value-change-value');
	        this.eDelta = this.queryForHtmlElement('.ag-value-change-delta');
	        this.refresh(params);
	    };
	    AnimateShowChangeCellRenderer.prototype.showDelta = function (params, delta) {
	        var absDelta = Math.abs(delta);
	        var valueFormatted = params.formatValue(absDelta);
	        var valueToUse = utils_1.Utils.exists(valueFormatted) ? valueFormatted : absDelta;
	        var deltaUp = (delta >= 0);
	        if (deltaUp) {
	            this.eDelta.innerHTML = ARROW_UP + valueToUse;
	        }
	        else {
	            // because negative, use ABS to remove sign
	            this.eDelta.innerHTML = ARROW_DOWN + valueToUse;
	        }
	        // class makes it green (in ag-fresh)
	        utils_1.Utils.addOrRemoveCssClass(this.eDelta, 'ag-value-change-delta-up', deltaUp);
	        // class makes it red (in ag-fresh)
	        utils_1.Utils.addOrRemoveCssClass(this.eDelta, 'ag-value-change-delta-down', !deltaUp);
	    };
	    AnimateShowChangeCellRenderer.prototype.setTimerToRemoveDelta = function () {
	        var _this = this;
	        // the refreshCount makes sure that if the value updates again while
	        // the below timer is waiting, then the below timer will realise it
	        // is not the most recent and will not try to remove the delta value.
	        this.refreshCount++;
	        var refreshCountCopy = this.refreshCount;
	        setTimeout(function () {
	            if (refreshCountCopy === _this.refreshCount) {
	                _this.hideDeltaValue();
	            }
	        }, 2000);
	    };
	    AnimateShowChangeCellRenderer.prototype.hideDeltaValue = function () {
	        utils_1.Utils.removeCssClass(this.eValue, 'ag-value-change-value-highlight');
	        this.eDelta.innerHTML = '';
	    };
	    AnimateShowChangeCellRenderer.prototype.refresh = function (params) {
	        var value = params.value;
	        if (value === this.lastValue) {
	            return;
	        }
	        if (utils_1.Utils.exists(params.valueFormatted)) {
	            this.eValue.innerHTML = params.valueFormatted;
	        }
	        else if (utils_1.Utils.exists(params.value)) {
	            this.eValue.innerHTML = value;
	        }
	        else {
	            this.eValue.innerHTML = '';
	        }
	        if (typeof value === 'number' && typeof this.lastValue === 'number') {
	            var delta = value - this.lastValue;
	            this.showDelta(params, delta);
	        }
	        // highlight the current value, but only if it's not new, otherwise it
	        // would get highlighted first time the value is shown
	        if (this.lastValue) {
	            utils_1.Utils.addCssClass(this.eValue, 'ag-value-change-value-highlight');
	        }
	        this.setTimerToRemoveDelta();
	        this.lastValue = value;
	    };
	    AnimateShowChangeCellRenderer.TEMPLATE = '<span>' +
	        '<span class="ag-value-change-delta"></span>' +
	        '<span class="ag-value-change-value"></span>' +
	        '</span>';
	    return AnimateShowChangeCellRenderer;
	})(component_1.Component);
	exports.AnimateShowChangeCellRenderer = AnimateShowChangeCellRenderer;


/***/ },
/* 58 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
	 * @version v7.0.2
	 * @link http://www.ag-grid.com/
	 * @license MIT
	 */
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var svgFactory_1 = __webpack_require__(59);
	var gridOptionsWrapper_1 = __webpack_require__(3);
	var expressionService_1 = __webpack_require__(18);
	var eventService_1 = __webpack_require__(4);
	var constants_1 = __webpack_require__(8);
	var utils_1 = __webpack_require__(7);
	var events_1 = __webpack_require__(10);
	var context_1 = __webpack_require__(6);
	var component_1 = __webpack_require__(47);
	var rowNode_1 = __webpack_require__(27);
	var cellRendererService_1 = __webpack_require__(60);
	var valueFormatterService_1 = __webpack_require__(61);
	var checkboxSelectionComponent_1 = __webpack_require__(62);
	var columnController_1 = __webpack_require__(13);
	var svgFactory = svgFactory_1.SvgFactory.getInstance();
	var GroupCellRenderer = (function (_super) {
	    __extends(GroupCellRenderer, _super);
	    function GroupCellRenderer() {
	        _super.call(this, GroupCellRenderer.TEMPLATE);
	        this.eExpanded = this.queryForHtmlElement('.ag-group-expanded');
	        this.eContracted = this.queryForHtmlElement('.ag-group-contracted');
	        this.eCheckbox = this.queryForHtmlElement('.ag-group-checkbox');
	        this.eValue = this.queryForHtmlElement('.ag-group-value');
	        this.eChildCount = this.queryForHtmlElement('.ag-group-child-count');
	    }
	    GroupCellRenderer.prototype.init = function (params) {
	        this.rowNode = params.node;
	        this.rowIndex = params.rowIndex;
	        this.gridApi = params.api;
	        this.addExpandAndContract(params.eGridCell);
	        this.addCheckboxIfNeeded(params);
	        this.addValueElement(params);
	        this.addPadding(params);
	    };
	    GroupCellRenderer.prototype.addPadding = function (params) {
	        // only do this if an indent - as this overwrites the padding that
	        // the theme set, which will make things look 'not aligned' for the
	        // first group level.
	        var node = this.rowNode;
	        var suppressPadding = params.suppressPadding;
	        if (!suppressPadding && (node.footer || node.level > 0)) {
	            var paddingFactor;
	            if (params.colDef && params.padding >= 0) {
	                paddingFactor = params.padding;
	            }
	            else {
	                paddingFactor = 10;
	            }
	            var paddingPx = node.level * paddingFactor;
	            var reducedLeafNode = this.columnController.isPivotMode() && this.rowNode.leafGroup;
	            if (node.footer) {
	                paddingPx += 15;
	            }
	            else if (!node.isExpandable() || reducedLeafNode) {
	                paddingPx += 10;
	            }
	            this.getGui().style.paddingLeft = paddingPx + 'px';
	        }
	    };
	    GroupCellRenderer.prototype.addValueElement = function (params) {
	        if (params.innerRenderer) {
	            this.createFromInnerRenderer(params);
	        }
	        else if (this.rowNode.footer) {
	            this.createFooterCell(params);
	        }
	        else if (this.rowNode.group) {
	            this.createGroupCell(params);
	            this.addChildCount(params);
	        }
	        else {
	            this.createLeafCell(params);
	        }
	    };
	    GroupCellRenderer.prototype.createFromInnerRenderer = function (params) {
	        var innerComponent = this.cellRendererService.useCellRenderer(params.innerRenderer, this.eValue, params);
	        this.addDestroyFunc(function () {
	            if (innerComponent && innerComponent.destroy) {
	                innerComponent.destroy();
	            }
	        });
	    };
	    GroupCellRenderer.prototype.createFooterCell = function (params) {
	        var footerValue;
	        var groupName = this.getGroupName(params);
	        if (params.footerValueGetter) {
	            var footerValueGetter = params.footerValueGetter;
	            // params is same as we were given, except we set the value as the item to display
	            var paramsClone = utils_1.Utils.cloneObject(params);
	            paramsClone.value = groupName;
	            if (typeof footerValueGetter === 'function') {
	                footerValue = footerValueGetter(paramsClone);
	            }
	            else if (typeof footerValueGetter === 'string') {
	                footerValue = this.expressionService.evaluate(footerValueGetter, paramsClone);
	            }
	            else {
	                console.warn('ag-Grid: footerValueGetter should be either a function or a string (expression)');
	            }
	        }
	        else {
	            footerValue = 'Total ' + groupName;
	        }
	        this.eValue.innerHTML = footerValue;
	    };
	    GroupCellRenderer.prototype.createGroupCell = function (params) {
	        // pull out the column that the grouping is on
	        var rowGroupColumns = params.columnApi.getRowGroupColumns();
	        // if we are using in memory grid grouping, then we try to look up the column that
	        // we did the grouping on. however if it is not possible (happens when user provides
	        // the data already grouped) then we just the current col, ie use cellrenderer of current col
	        var columnOfGroupedCol = rowGroupColumns[params.node.rowGroupIndex];
	        if (utils_1.Utils.missing(columnOfGroupedCol)) {
	            columnOfGroupedCol = params.column;
	        }
	        var colDefOfGroupedCol = columnOfGroupedCol.getColDef();
	        var groupName = this.getGroupName(params);
	        var valueFormatted = this.valueFormatterService.formatValue(columnOfGroupedCol, params.node, params.scope, this.rowIndex, groupName);
	        // reuse the params but change the value
	        if (colDefOfGroupedCol && typeof colDefOfGroupedCol.cellRenderer === 'function') {
	            // reuse the params but change the value
	            params.value = groupName;
	            params.valueFormatted = valueFormatted;
	            // because we are talking about the different column to the original, any user provided params
	            // are for the wrong column, so need to copy them in again.
	            if (colDefOfGroupedCol.cellRendererParams) {
	                utils_1.Utils.assign(params, colDefOfGroupedCol.cellRendererParams);
	            }
	            this.cellRendererService.useCellRenderer(colDefOfGroupedCol.cellRenderer, this.eValue, params);
	        }
	        else {
	            var valueToRender = utils_1.Utils.exists(valueFormatted) ? valueFormatted : groupName;
	            if (utils_1.Utils.exists(valueToRender) && valueToRender !== '') {
	                this.eValue.appendChild(document.createTextNode(valueToRender));
	            }
	        }
	    };
	    GroupCellRenderer.prototype.addChildCount = function (params) {
	        var _this = this;
	        // only include the child count if it's included, eg if user doing custom aggregation,
	        // then this could be left out, or set to -1, ie no child count
	        if (params.suppressCount) {
	            return;
	        }
	        var listener = function () {
	            if (params.node.allChildrenCount >= 0) {
	                _this.eChildCount.innerHTML = "(" + params.node.allChildrenCount + ")";
	            }
	            else {
	                _this.eChildCount.innerHTML = '';
	            }
	        };
	        // filtering changes the child count, so need to cater for it
	        this.addDestroyableEventListener(this.eventService, events_1.Events.EVENT_AFTER_FILTER_CHANGED, listener);
	        listener();
	    };
	    GroupCellRenderer.prototype.getGroupName = function (params) {
	        if (params.keyMap && typeof params.keyMap === 'object') {
	            var valueFromMap = params.keyMap[params.node.key];
	            if (valueFromMap) {
	                return valueFromMap;
	            }
	            else {
	                return params.node.key;
	            }
	        }
	        else {
	            return params.node.key;
	        }
	    };
	    GroupCellRenderer.prototype.createLeafCell = function (params) {
	        if (utils_1.Utils.exists(params.value)) {
	            this.eValue.innerHTML = params.value;
	        }
	    };
	    GroupCellRenderer.prototype.isUserWantsSelected = function (params) {
	        if (typeof params.checkbox === 'function') {
	            return params.checkbox(params);
	        }
	        else {
	            return params.checkbox === true;
	        }
	    };
	    GroupCellRenderer.prototype.addCheckboxIfNeeded = function (params) {
	        var checkboxNeeded = this.isUserWantsSelected(params)
	            && !this.rowNode.footer
	            && !this.rowNode.floating
	            && !this.rowNode.flower;
	        if (checkboxNeeded) {
	            var cbSelectionComponent = new checkboxSelectionComponent_1.CheckboxSelectionComponent();
	            this.context.wireBean(cbSelectionComponent);
	            cbSelectionComponent.init({ rowNode: this.rowNode });
	            this.eCheckbox.appendChild(cbSelectionComponent.getGui());
	            this.addDestroyFunc(function () { return cbSelectionComponent.destroy(); });
	        }
	    };
	    GroupCellRenderer.prototype.addExpandAndContract = function (eGroupCell) {
	        var eExpandedIcon = utils_1.Utils.createIconNoSpan('groupExpanded', this.gridOptionsWrapper, null, svgFactory.createGroupContractedIcon);
	        var eContractedIcon = utils_1.Utils.createIconNoSpan('groupContracted', this.gridOptionsWrapper, null, svgFactory.createGroupExpandedIcon);
	        this.eExpanded.appendChild(eExpandedIcon);
	        this.eContracted.appendChild(eContractedIcon);
	        this.addDestroyableEventListener(this.eExpanded, 'click', this.onExpandOrContract.bind(this));
	        this.addDestroyableEventListener(this.eContracted, 'click', this.onExpandOrContract.bind(this));
	        this.addDestroyableEventListener(eGroupCell, 'dblclick', this.onExpandOrContract.bind(this));
	        // expand / contract as the user hits enter
	        this.addDestroyableEventListener(eGroupCell, 'keydown', this.onKeyDown.bind(this));
	        this.addDestroyableEventListener(this.rowNode, rowNode_1.RowNode.EVENT_EXPANDED_CHANGED, this.showExpandAndContractIcons.bind(this));
	        this.showExpandAndContractIcons();
	    };
	    GroupCellRenderer.prototype.onKeyDown = function (event) {
	        if (utils_1.Utils.isKeyPressed(event, constants_1.Constants.KEY_ENTER)) {
	            this.onExpandOrContract();
	            event.preventDefault();
	        }
	    };
	    GroupCellRenderer.prototype.onExpandOrContract = function () {
	        this.rowNode.setExpanded(!this.rowNode.expanded);
	        if (this.gridOptionsWrapper.isGroupIncludeFooter()) {
	            this.gridApi.refreshRows([this.rowNode]);
	        }
	    };
	    GroupCellRenderer.prototype.showExpandAndContractIcons = function () {
	        var reducedLeafNode = this.columnController.isPivotMode() && this.rowNode.leafGroup;
	        var expandable = this.rowNode.isExpandable() && !this.rowNode.footer && !reducedLeafNode;
	        if (expandable) {
	            // if expandable, show one based on expand state
	            utils_1.Utils.setVisible(this.eExpanded, this.rowNode.expanded);
	            utils_1.Utils.setVisible(this.eContracted, !this.rowNode.expanded);
	        }
	        else {
	            // it not expandable, show neither
	            utils_1.Utils.setVisible(this.eExpanded, false);
	            utils_1.Utils.setVisible(this.eContracted, false);
	        }
	    };
	    GroupCellRenderer.TEMPLATE = '<span>' +
	        '<span class="ag-group-expanded"></span>' +
	        '<span class="ag-group-contracted"></span>' +
	        '<span class="ag-group-checkbox"></span>' +
	        '<span class="ag-group-value"></span>' +
	        '<span class="ag-group-child-count"></span>' +
	        '</span>';
	    __decorate([
	        context_1.Autowired('gridOptionsWrapper'), 
	        __metadata('design:type', gridOptionsWrapper_1.GridOptionsWrapper)
	    ], GroupCellRenderer.prototype, "gridOptionsWrapper", void 0);
	    __decorate([
	        context_1.Autowired('expressionService'), 
	        __metadata('design:type', expressionService_1.ExpressionService)
	    ], GroupCellRenderer.prototype, "expressionService", void 0);
	    __decorate([
	        context_1.Autowired('eventService'), 
	        __metadata('design:type', eventService_1.EventService)
	    ], GroupCellRenderer.prototype, "eventService", void 0);
	    __decorate([
	        context_1.Autowired('cellRendererService'), 
	        __metadata('design:type', cellRendererService_1.CellRendererService)
	    ], GroupCellRenderer.prototype, "cellRendererService", void 0);
	    __decorate([
	        context_1.Autowired('valueFormatterService'), 
	        __metadata('design:type', valueFormatterService_1.ValueFormatterService)
	    ], GroupCellRenderer.prototype, "valueFormatterService", void 0);
	    __decorate([
	        context_1.Autowired('context'), 
	        __metadata('design:type', context_1.Context)
	    ], GroupCellRenderer.prototype, "context", void 0);
	    __decorate([
	        context_1.Autowired('columnController'), 
	        __metadata('design:type', columnController_1.ColumnController)
	    ], GroupCellRenderer.prototype, "columnController", void 0);
	    return GroupCellRenderer;
	})(component_1.Component);
	exports.GroupCellRenderer = GroupCellRenderer;


/***/ },
/* 59 */
/***/ function(module, exports) {

	/**
	 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
	 * @version v7.0.2
	 * @link http://www.ag-grid.com/
	 * @license MIT
	 */
	var SVG_NS = "http://www.w3.org/2000/svg";
	var SvgFactory = (function () {
	    function SvgFactory() {
	    }
	    SvgFactory.getInstance = function () {
	        if (!this.theInstance) {
	            this.theInstance = new SvgFactory();
	        }
	        return this.theInstance;
	    };
	    SvgFactory.prototype.createFilterSvg = function () {
	        var eSvg = createIconSvg();
	        var eFunnel = document.createElementNS(SVG_NS, "polygon");
	        eFunnel.setAttribute("points", "0,0 4,4 4,10 6,10 6,4 10,0");
	        eFunnel.setAttribute("class", "ag-header-icon");
	        eSvg.appendChild(eFunnel);
	        return eSvg;
	    };
	    SvgFactory.prototype.createFilterSvg12 = function () {
	        var eSvg = createIconSvg(12);
	        var eFunnel = document.createElementNS(SVG_NS, "polygon");
	        eFunnel.setAttribute("points", "0,0 5,5 5,12 7,12 7,5 12,0");
	        eFunnel.setAttribute("class", "ag-header-icon");
	        eSvg.appendChild(eFunnel);
	        return eSvg;
	    };
	    SvgFactory.prototype.createMenuSvg = function () {
	        var eSvg = document.createElementNS(SVG_NS, "svg");
	        var size = "12";
	        eSvg.setAttribute("width", size);
	        eSvg.setAttribute("height", size);
	        ["0", "5", "10"].forEach(function (y) {
	            var eLine = document.createElementNS(SVG_NS, "rect");
	            eLine.setAttribute("y", y);
	            eLine.setAttribute("width", size);
	            eLine.setAttribute("height", "2");
	            eLine.setAttribute("class", "ag-header-icon");
	            eSvg.appendChild(eLine);
	        });
	        return eSvg;
	    };
	    SvgFactory.prototype.createColumnsSvg12 = function () {
	        var eSvg = createIconSvg(12);
	        [0, 4, 8].forEach(function (y) {
	            [0, 7].forEach(function (x) {
	                var eBar = document.createElementNS(SVG_NS, "rect");
	                eBar.setAttribute("y", y.toString());
	                eBar.setAttribute("x", x.toString());
	                eBar.setAttribute("width", "5");
	                eBar.setAttribute("height", "3");
	                eBar.setAttribute("class", "ag-header-icon");
	                eSvg.appendChild(eBar);
	            });
	        });
	        return eSvg;
	    };
	    SvgFactory.prototype.createArrowUpSvg = function () {
	        return createPolygonSvg("0,10 5,0 10,10");
	    };
	    SvgFactory.prototype.createArrowLeftSvg = function () {
	        return createPolygonSvg("10,0 0,5 10,10");
	    };
	    SvgFactory.prototype.createArrowDownSvg = function () {
	        return createPolygonSvg("0,0 5,10 10,0");
	    };
	    SvgFactory.prototype.createArrowRightSvg = function () {
	        return createPolygonSvg("0,0 10,5 0,10");
	    };
	    SvgFactory.prototype.createSmallArrowRightSvg = function () {
	        return createPolygonSvg("0,0 6,3 0,6", 6);
	    };
	    SvgFactory.prototype.createSmallArrowDownSvg = function () {
	        return createPolygonSvg("0,0 3,6 6,0", 6);
	    };
	    //public createOpenSvg() {
	    //    return createPlusMinus(true);
	    //}
	    //
	    //public createCloseSvg() {
	    //    return createPlusMinus(false);
	    //}
	    // UnSort Icon SVG
	    SvgFactory.prototype.createArrowUpDownSvg = function () {
	        var svg = createIconSvg();
	        var eAscIcon = document.createElementNS(SVG_NS, "polygon");
	        eAscIcon.setAttribute("points", '0,4 5,0 10,4');
	        svg.appendChild(eAscIcon);
	        var eDescIcon = document.createElementNS(SVG_NS, "polygon");
	        eDescIcon.setAttribute("points", '0,6 5,10 10,6');
	        svg.appendChild(eDescIcon);
	        return svg;
	    };
	    //public createFolderOpen(size: number): HTMLElement {
	    //    var svg = `<svg width="${size}" height="${size}" viewBox="0 0 1792 1792" xmlns="http://www.w3.org/2000/svg"><path d="M1717 931q0-35-53-35h-1088q-40 0-85.5 21.5t-71.5 52.5l-294 363q-18 24-18 40 0 35 53 35h1088q40 0 86-22t71-53l294-363q18-22 18-39zm-1141-163h768v-160q0-40-28-68t-68-28h-576q-40 0-68-28t-28-68v-64q0-40-28-68t-68-28h-320q-40 0-68 28t-28 68v853l256-315q44-53 116-87.5t140-34.5zm1269 163q0 62-46 120l-295 363q-43 53-116 87.5t-140 34.5h-1088q-92 0-158-66t-66-158v-960q0-92 66-158t158-66h320q92 0 158 66t66 158v32h544q92 0 158 66t66 158v160h192q54 0 99 24.5t67 70.5q15 32 15 68z"/></svg>`;
	    //    return _.loadTemplate(svg);
	    //}
	    //
	    //public createFolderClosed(size: number): HTMLElement {
	    //    var svg = `<svg width="${size}" height="${size}" viewBox="0 0 1792 1792" xmlns="http://www.w3.org/2000/svg"><path d="M1600 1312v-704q0-40-28-68t-68-28h-704q-40 0-68-28t-28-68v-64q0-40-28-68t-68-28h-320q-40 0-68 28t-28 68v960q0 40 28 68t68 28h1216q40 0 68-28t28-68zm128-704v704q0 92-66 158t-158 66h-1216q-92 0-158-66t-66-158v-960q0-92 66-158t158-66h320q92 0 158 66t66 158v32h672q92 0 158 66t66 158z"/></svg>`;
	    //    return _.loadTemplate(svg);
	    //}
	    SvgFactory.getFromCacheOrCreate = function (key, data) {
	        // return document.createElement('img');
	        var eCachedImg = this.imageCache[key];
	        if (!eCachedImg) {
	            eCachedImg = document.createElement('img');
	            eCachedImg.src = data;
	            this.imageCache[key] = eCachedImg;
	        }
	        return eCachedImg.cloneNode();
	    };
	    SvgFactory.prototype.createFolderOpen = function () {
	        return SvgFactory.getFromCacheOrCreate('FolderOpen', 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAZpJREFUeNqkU0tLQkEUPjN3ShAzF66CaNGiaNEviFpLgbSpXf2ACIqgFkELaVFhtAratQ8qokU/oFVbMQtJvWpWGvYwtet9TWfu1QorvOGBb84M5/WdOTOEcw7tCKHBlT8sMIhr4BfLGXC4BrALM8QUoveHG9oPQ/NhwVCQbOjp0C5F6zDiwE7Aed/p5tKWruufTlY8bkqliqVN8wvH6wvhydWd5UYdkYCqqgaKotQTCEewnJuDBSqVmshOrWhKgCJVqeHcKtiGKdqTgGIOQmwGum7AxVUKinXKzX1/1y5Xp6g8gpe8iBxuGZhcKjyXQZIkmBkfczS62YnRQCKX75/b3t8QDNhD8QX83V5Ipe7Bybug2Pt5NJ7A4nEqGOQKT+Bzu0HTDNB1syUYYxCJy0kwzIRogb0rKjAiQVXXHLVQrqqvsZtsFu8hbyXwe73WeMQtO5GonJGxuiyeC+Oa4fF5PEirw9nbx9FdxtN5eMwkzcgRnoeCa9DVM/CvH/R2l+axkz3clQguOFjw1f+FUzEQCqJG2v3OHwIMAOW1JPnAAAJxAAAAAElFTkSuQmCC');
	    };
	    SvgFactory.prototype.createFolderClosed = function () {
	        return SvgFactory.getFromCacheOrCreate('FolderClosed', 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAARlJREFUeNqsUz1PwzAUPDtOUASpYKkQVWcQA/+DhbLA32CoKAMSTAwgFsQfQWLoX4GRDFXGIiqiyk4e7wUWmg8phJPOtvzunc6WrYgIXaD06KKhij0eD2uqUxBeDC9OmcNKCYd7ujm7ryodXz5ong6UPpqcP9+O76y1vwS+7yOOY1jr0OttlQyiaB0n148TAyK9XFqkaboiSTEYDNnkDUkyKxkkiSQkzQbwsiyHcBXz+Tv6/W1m+QiSEDT1igTO5RBWYbH4rNwPw/AnQU5ek0EdCj33SgLjHEHYzoAkgfmHBDmZuktsQqHPvxN0MyCbbWjtIQjWWhlIj/QqtT+6QrSz+6ef9DF7VTwFzE2madnu5K2prt/5S4ABADcIlSf6Ag8YAAAAAElFTkSuQmCC');
	    };
	    SvgFactory.prototype.createColumnIcon = function () {
	        return SvgFactory.getFromCacheOrCreate('ColumnIcon', 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAYAAAAOCAYAAAAMn20lAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyJpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMy1jMDExIDY2LjE0NTY2MSwgMjAxMi8wMi8wNi0xNDo1NjoyNyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNiAoV2luZG93cykiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6RTcwQ0JFMzlENjZEMTFFNUFEQ0U5RDRCNjFFRENGMUMiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6RTcwQ0JFM0FENjZEMTFFNUFEQ0U5RDRCNjFFRENGMUMiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDpFNzBDQkUzN0Q2NkQxMUU1QURDRTlENEI2MUVEQ0YxQyIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDpFNzBDQkUzOEQ2NkQxMUU1QURDRTlENEI2MUVEQ0YxQyIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/PqDOrJYAAABxSURBVHjalJBBDsAgCAQXxXvj2/o/X9Cvmd4lUpV4MXroJMTAuihQSklVMSCysxSBW4uWKzjG6zZLDxrlWis5EVEThoWmi3N+nxAYs2WnXQY34L3HisMWPQlHB+2FPtNW6D/8+ziBRcroOXc0B/wEGABY6TPS1FU0bwAAAABJRU5ErkJggg==');
	    };
	    SvgFactory.prototype.createColumnsIcon = function () {
	        return SvgFactory.getFromCacheOrCreate('ColumnsIcon', 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyJpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMy1jMDExIDY2LjE0NTY2MSwgMjAxMi8wMi8wNi0xNDo1NjoyNyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNiAoV2luZG93cykiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6OENFQkI4NDhENzJDMTFFNUJDNEVFRjgwRDI3MkU1Q0EiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6OENFQkI4NDlENzJDMTFFNUJDNEVFRjgwRDI3MkU1Q0EiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDo4Q0VCQjg0NkQ3MkMxMUU1QkM0RUVGODBEMjcyRTVDQSIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDo4Q0VCQjg0N0Q3MkMxMUU1QkM0RUVGODBEMjcyRTVDQSIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/Pj6ozGQAAAAuSURBVHjaYmRgYPjPgBswQml8anBK/idGDQsxNpCghnTAOBoGo2EwGgZgABBgAHbrH/l4grETAAAAAElFTkSuQmCC');
	    };
	    SvgFactory.prototype.createPinIcon = function () {
	        return SvgFactory.getFromCacheOrCreate('PinIcon', 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAedJREFUeNqkUktLG1EYPTN31CIN0oWbIAWhKJR0FXcG6gOqkKGKVvEXCKULC91YSBcK7jXgQoIbFxn3ErFgFlIfCxUsQsCoIJYEm9LWNsGmJjPTM+Oo44Aa6IUzd+bec77H+UYyTRP/s5SsLFfCCxEjOhD9CXw64ccXJj7nLleYaMSvaa/+Au9Y73P3RUUBDIuXyaAxGu35A7xnkM57A7icCZXIO8/nkVleRn1/f9cv0xzjfVclFdi9N8ZivfnDQxQKBTwoFvFicLCVQSesJIpHMEY8dSqQWa54Eov1fF9ZQVHXsZNMblhnNE/wPmJPIX1zjOG2+fkgslnozHR2eopLcSIe3yoD48y45FbIxoVJNjimyMehoW3T58PvdBq53V18zeWwFo+vUfyBlCVvj0Li4/M1DnaAUtXCQkNDR4f/294eaoTAwdHRCROMWlzJZfC+1cKcJF07b5o+btWvV1eDyVBouyUcDj5UFDg924tVYtERpz0mCkmSulOp1GQgEIj0yvKPYiKBlwMDQXfPU47walEEmb8z0a5p2qaiKMPEoz6ezQLdM8DWNDDzltym24YthHimquoshSoDicvzZkK9S+h48pjCN4ZhrBPHTptlD0qevezwdCtAHVHrMti4A7rr3eb+E2AAoGnGkgkzpg8AAAAASUVORK5CYII=');
	    };
	    SvgFactory.prototype.createPlusIcon = function () {
	        return SvgFactory.getFromCacheOrCreate('PlusIcon', 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAatJREFUeNqkU71KA0EQ/vaiib+lWCiordidpSg+QHwDBSt7n8DGhwhYCPoEgqCCINomARuLVIqgYKFG5f6z68xOzrvzYuXA3P7MzLffN7unjDH4jw3xx91bQXuxU4woNDjUX7VgsFOIH3/BnHgC0J65AzwFjDpZgoG7vb7lMsPDq6MiuK+B+kjGwFpCUjwK1DIQ3/dl0ssVh5TTM0UJP8aBgBKGleSGIWyP0oKYRm3KPSgYJ0Q0EpEgCASA2WmWZQY3kazBmjP9UhBFEbTWAgA0f9W2yHeG+vrd+tqGy5r5xNTT9erSqpvfdxwHN7fXOQZ0QhzH1oWArLsfXXieJ/KTGEZLcbVaTVn9ALTOLk9L+mYX5lxd0Xh6eGyVgspK6APwI8n3x9hmNpORJOuBo5ah8GcTc7dAHmkhNpYQlpHr47Hq2NspA1yEwHkoO/MVYLMmWJNarjEUQBzQw7rPvardFC8tZuOEwwB4p9PHqXgCdm738sUDJPB8mnwKj7qCTtJ527+XyAs6tOf2Bb6SP0OeGxRTVMp2h9nweWMoKS20l3+QT/vwqfZbgAEAUCrnlLQ+w4QAAAAASUVORK5CYII=');
	    };
	    SvgFactory.prototype.createMinusIcon = function () {
	        return SvgFactory.getFromCacheOrCreate('MinusIcon', 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAKVJREFUeNpi/P//PwMlgImBQjBqAAMDy3JGRgZGBoaZQGxMikZg3J0F4nSWHxC+cUBamvHXr18Zfv36Bca/f/8G43///oExKLphmImJieHagQMQF7QDiSwg/vnzJ8P3799RDPj79y+KRhhmBLr6I1DPNJABtxkYZM4xMFx7uXAhSX5/CtQD0gv0OgMfyCAgZgViZiL1/wXi30D8h3E0KVNuAECAAQDr51qtGxzf1wAAAABJRU5ErkJggg==');
	    };
	    SvgFactory.prototype.createMoveIcon = function () {
	        return SvgFactory.getFromCacheOrCreate('MoveIcon', 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAoZJREFUeNpsU81rE0EUf7uzu2lNVJL6Eb0IBWusepqcKm3wEFkvxqDgQbwUtYeeg5cccwj4F7QKChEPipRcdMGDiaAoJAexLYViwYsfbU1JYkx3Zz98b8220Wbg7ez7vXm/mffmN9Kh1G2QGQOmMDiRyYEkSaCoKjDGdAAooOUdxzFsIcDzPPhSvgeO7YDrOLBRmQdlJHULVE0DNRSCvqFjUuHqhWP8+etvhR5m0CeengVhmiAsywdl2Dt03K1wZSrO220XaCaf8AFrQel32s0mrDcaWfovrq3Vc9OTvHj/Tb0Xzh6JxQwNyxtIgPXpqqJk94fDM+1Oh6CaEF4QTiIOGJ/DdQtBObsEmGxbll/rkCyDPDwMzW4XhHD88EH0NcRxDUeX4/qdnsi0s8Aas+kEp8Zg82pMkmpDigKbjSbQTD7hFL94/jin9ZRHBNLo3Wrt+uUkbzQsiEZVMPGKfv76DaawodnahkhY86+PNnXxs77ZgVOjMahWVuufi1NJRZhWvvT0beHGtQn++Nm7en+DzqXO8vfVxX+wsYnT/JWxWEe95P0eILsvkkdPKn4PUEBJmunILab5992PLVU++skoNmOniT7JX2Fkt5GM1EjqbMohXzQmqo7KwCQ6zYKiabu30PpQAnZ0HKSRMcMRwnBddw4ZOO4GLRYKFFdDhrrteTMMdWB9/QTdH8sIp0EKmNT4GWDjGZAPJ3TcrbBv+ibfwtwDqBvzYck/truxYjjLZRDflwLt7JUmEoAymdPV7INa5IXn0Uw+4f8PIqATMLQIWpQ0E/RFTmQ4nLx0B1Zfzrsr5eAmbLQW2hYpHwkcqfegNBJhzwY9sGC4aCZaF81CAvePAAMAcwtApJX/Wo0AAAAASUVORK5CYII=');
	    };
	    SvgFactory.prototype.createLeftIcon = function () {
	        return SvgFactory.getFromCacheOrCreate('LeftIcon', 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAe9JREFUeNqkUz1oE2EYfu7uuyRKLCFt6g+4VNQWWod+mQRRR1En0UFOHKoNCMKNju4SEQsOzsFNcRGl4CS42AzaKhKcsqhk0Etj7u+773y/6+USbOLSF5574b33eX+e906L4xh7MaYeC/c/IFcowMznEzDTBGPMoldnqEFtkPy708mIqvHHe0s7BcaYJYSwRwPu9vbYRH1XJI4tEYb2jYtHOHko9LvdxE9cYZQcBoF9+9oJ7jgRQt+HFAJSyv9rkO6UkGvXF3mr9QelkpkUINsYR6T8Jrkay8i+b9+5yfnmppMmSFw6e4yrIynBBsdS3jQ1PH/zeTiBIt+9dZpvbTlZh1+Oh/Z3F33XRUj7R1GUxA3DwMx0EYHnDUUMPe9Rfe1tc26uiL6M8aXno+UH6O7PIShPIapMQx6sQMxW4JbL+MkKCKhwNgGN2FD7Pnz82j63coF/aoc4ekDHtxfrzUniaZrW/FfEBomI9Scv7fnVq7zdBwIqajBWpeTd99d3vgBNCaQSzMOLyJ+6ApSPWxSzD61a/MfThupSjVuvxk2A3sazYYGBGbML0OcvW9rMyeRLFO8eVGXnKyacMiug5ikSplLs05dXzqNQWpbv6/URjpK+m6JH3GhQQI2QI+RTmBO0EwQ/RUBcqe31d/4rwAB0lPTXqN6HzgAAAABJRU5ErkJggg==');
	    };
	    SvgFactory.prototype.createRightIcon = function () {
	        return SvgFactory.getFromCacheOrCreate('RightIcon', 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAfBJREFUeNqkUz1s00AU/hwSh1SEhiFCYuhCVSExgHRiYKjEVCEyMMGAsjCxZunesWM7dIgEA8JISPyoUhFDFoZOSE2GgtrSIAYWSEPb1HUS23c+8+7iuE5/JKQ+6fOdz/e+970fG2EY4jyWVo9b819hGEZ8WCgW4z2dV2lZFUJYgnNwz9PwXRebc3cGBMfN6XSQy+eHryyCMuv43dRpBCpSz7b1qlB+cI3RWkEYlv+LQFkgBLxuV8s9OAhQLk0w7vsnSHQKVMhqQuYRSRBouK5AqyXwpHSdvfywUYkKb8UEFIU9fXybOY6A+jbszGAP7O/7RBKg2eR4dH+KvV5ej0k0gaqobXO0214c3acUDnt99Pp9cKqDUqLsx68LuHd3gtU+b1eOCOiSaaZQKJjgMsSOy7EnJcSYCZnLwKbojic1weTVMXz81KhTexeSKdSXqrUzh2X84Qxr9SQmx1P48q6mnTPZrJUs4jMp5QlHlSd1Y203fRGFK8DPV28HzqZpjXShW3+D00bamCrpNU9DuvvcGsjea1rO+nvw39+AxRCGckyO8ciQFG8gPT27ptX8/b4gt1asYGdzRGE6MVCXCJcj5NShbG9B/NnYhttpyMYL5XmTYEdw1KgMFSgJJiEbIXNGPQXBi+CTrzTO+zv/E2AA3Y8Nbp4Kn1sAAAAASUVORK5CYII=');
	    };
	    SvgFactory.prototype.createColumnVisibleIcon = function () {
	        return SvgFactory.getFromCacheOrCreate('ColumnVisibleIcon', 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAdhJREFUeNrUk01LAlEUhu845QdRUxZBhIIWtFBso2AwRAVNLqKltHCb63b9A/9AixZCELhyYdAmEyYCBcOlNa1CSQoxog/DMY3x9p5B27Zw1YGH8XrO+55759wROOdsmLCwIWNoAwFh/ugfZQKsAQV4gbNf9woqIAeuQHOgGxgIMNix2Wx7iqIsxmKxWU3TxgqFgpWSsix3fT5fK5VKPedyuftOp5OE7oz60hHsYD8UCh3k83k5k8ksGYYx5XK5rK2WzgiIrPQf5aiGakljakVRjKDrZaPR6Oi6zglVVTlFMnnMZXmdK8o2x674IE+1pCHtCFx2w+GwE9u3drtd81yJRAKdDXZ4eGSuFxb87PHxjg3yVEsaNNolg5NSqTTVbDaX7Agq8Hg8TFWLbGVl0xTY7TY2Our5NfhCQPNAWtFisdSr1WqvWCwawWBwRpKkcZyXadoN83qXmSQ50V1jGxurpnGlUqnH4/FzvItTmoo5ApjQNMIOh2MrEon4o9Gov1arzZXL5XHKBwKBT7fbXU+n07fZbPa23W5f4BVd93o9TgYimATTMHHCbB5PN9ZSf0LmrsEHRDWInvB8w/oFvAv920iFDkBzF/64fHTjvoFOxsL//5h+BBgAwjbgRLl5ImwAAAAASUVORK5CYII=');
	    };
	    SvgFactory.prototype.createColumnHiddenIcon = function () {
	        return SvgFactory.getFromCacheOrCreate('ColumnHiddenIcon', 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyJpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMy1jMDExIDY2LjE0NTY2MSwgMjAxMi8wMi8wNi0xNDo1NjoyNyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNiAoV2luZG93cykiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6N0ZGNDRBMkJENkU3MTFFNUIwOTBGRTc0MTA3OTI2OEYiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6N0ZGNDRBMkNENkU3MTFFNUIwOTBGRTc0MTA3OTI2OEYiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDo3RkY0NEEyOUQ2RTcxMUU1QjA5MEZFNzQxMDc5MjY4RiIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDo3RkY0NEEyQUQ2RTcxMUU1QjA5MEZFNzQxMDc5MjY4RiIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/PjQ0mkwAAACISURBVHjaYvz//z8DJYCJgUIwDAxgKSwspMwAIOYDYlcgtgNiJSBWBGJhIGaHyoHAJyD+CcRvgfg+EN8D4kNAvBtkwGEg1iNgkSCUlgBibSg7D4gvgwywRXKBChArALEIELMCsQBU8Qcg/g3Eb4D4ARDfBeKDMBeAnLcWikkGjKMpcRAYABBgACqXGpPEq63VAAAAAElFTkSuQmCC');
	    };
	    SvgFactory.prototype.createColumnIndeterminateIcon = function () {
	        return SvgFactory.getFromCacheOrCreate('ColumnIndeterminateIcon', 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyJpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMy1jMDExIDY2LjE0NTY2MSwgMjAxMi8wMi8wNi0xNDo1NjoyNyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNiAoV2luZG93cykiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6OUY1QTkyNDUxRTkzMTFFNkFEQzVDNjE1NDE4RDlEQUMiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6OUY1QTkyNDYxRTkzMTFFNkFEQzVDNjE1NDE4RDlEQUMiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDo5RjVBOTI0MzFFOTMxMUU2QURDNUM2MTU0MThEOURBQyIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDo5RjVBOTI0NDFFOTMxMUU2QURDNUM2MTU0MThEOURBQyIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/Por9Q7gAAAGzSURBVHja1JOxSwJRHMffqXcqSoVBQ0FDNN7iIBxO5WA3NYoEjm0u/T2Bkw2ONZlgNEk4Bw6GiGiippmRnp76+n4PbWhpcOoHH57P+36/7/e8n4qUUmxSLrFhbRygoJwPq6tsgRMQB0cgtNINQA0UwCMYrX3rAAUB516v9zIejx+nUqm90WgUDIfDaq1WE9PpdK6q6mc2m+0WCoUX7K/hu+O5TPCBq0gkUiqXy0PbtqVlWXK5XDqwuE4mEzmfzyU11NJDr3C73SZOfeh0OtPxeCyR7oixlzhdVqtV2ev1nCB+Tw219NDrQRtJwzBCaF+bzWbsSGQyGVEsFoWmacLj8YjBYCBisZhIp9MC3Qhq6YEmyQ5OTdO8bTQak263K8m69d+FIOc5tfTQywAvTrmIRqM3pVLptd1uy3q9/nN3slgsZLPZlHxGDbX00Ou8ApfLxbdh+P3+MyTriURC7/f7+7hCsFKpCF3XvwKBQCuXyz3n8/ln/Bb3yH9iOAPcYAfsIiSEsAOsh9hvA99qDizwAVMDphbWd+zfwFBZTSOFfqBxJv4YPk6cDcYMVv7/n+lbgAEAtdcjOjP715MAAAAASUVORK5CYII=');
	    };
	    SvgFactory.prototype.createGroupIcon = function () {
	        return SvgFactory.getFromCacheOrCreate('GroupIcon', 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyJpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMy1jMDExIDY2LjE0NTY2MSwgMjAxMi8wMi8wNi0xNDo1NjoyNyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNiAoV2luZG93cykiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6NUVCNUI1OUNENkYwMTFFNThGNjJDNUE3ODIwMEZERDciIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6NUVCNUI1OURENkYwMTFFNThGNjJDNUE3ODIwMEZERDciPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDo1RUI1QjU5QUQ2RjAxMUU1OEY2MkM1QTc4MjAwRkRENyIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDo1RUI1QjU5QkQ2RjAxMUU1OEY2MkM1QTc4MjAwRkRENyIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/PlkCTGoAAACDSURBVHjaYmRgYPjPgBswQun/+BT8X3x5DoZErG4KCj/3/DcMNZMNuRiYGPADRiRX4HYBJV5AB0QrhAGW//8hehgZES6FiaGLYzUAq7sxNf0nxQCsinHFAguegCPKBYxoYfAfWQxNnPgwINJVYMDEQCEYfLHASGoKRQlxPN7BqQggwAAN+SopPnDCwgAAAABJRU5ErkJggg==');
	    };
	    SvgFactory.prototype.createPivotIcon = function () {
	        return SvgFactory.getFromCacheOrCreate('PivotIcon', 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAitJREFUeNqcU01rE1EUPfPVJjFqdYw2pJQkNS2hYhQUiwj+AaugKFYUBWutG3HjokgNrroRKYKbglBBFF0o1IW404qClGIDxpYKTQgULZJmmpiYkPnwvmtNspPmweOcmXnnvPPufSOdjsf7AfjR3PiOU6OjV50mh9CqtmVJDlkNjWU3tPXEiA6hlS3Lkm3HQbFYxO5hnTF0pQ3Bwa3MAxc98F9wMd95TsOOswpzoRFa1TJNyaKHtTUD07cNdv9wx6jtNDNW53N369xyOiC0qmmanMAwcjh+/yimrr/D28kjf8WLizjY3c38YzKJw729zKcTCU4gtLUE+Xwejy+94gWfl5agKQr8uo4Eccu2USr48SWVQq5QWE/gcAJZuIgF5XIF5yf7GfcGg9Cos4O3UoiFw2jFLrx+/wtRet+3nkJoOAEbkJtty5g484I+yUivrODekxb4tmuInZhCuFPHyHAXZubnUTXNWgKhlc1qlY+gaZsw9PwkY4fPhxsDXvxcrWL25TE8G+8DFAOxSAQHotG6AWlrRXS52vD08ifGr5kM1+BBPIBkOo3flQpaNA2zCwug+8MGdkMCPoLbvQ0DDw8xRgIBBNvbsUoF6yK+h+pQJpN91JH9PT2NCWS1Ui4rNhtswZubPxi/LS9TTWxemKTK/9t1jtramEBo1Vw226pRvEfj3oaL6v3vVRYaoZXcodA12ePpbOZXtEuljEToprmZprpBvehn4Y8AAwDB0mLL0M405wAAAABJRU5ErkJggg==');
	    };
	    SvgFactory.prototype.createAggregationIcon = function () {
	        return SvgFactory.getFromCacheOrCreate('AggregationIcon', 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAMZJREFUeNpi/P//PwMlgImBQjDwBrCgmMYENq8RiLVxqL8KxPX//v1DiIACEYYZGRlBmBOIe4B4PRDrQMUYoGyQGIoebAbADJkAxFuAWA9JXJdYA0CYC4inAPFOINZHlkPWgxKIcFMhQA0aFveB+DbOUERxDhQAbTEC4qNAPBfqEmRx3F6AAhOgojNAvBikGckumDiKHhY0B3ECcTVQQhRIg/B1NNeeB1IgQ7/BXYvmdE6oAnYcPv4NxF+BerAbMDTzAkCAAQChYIl8b86M1gAAAABJRU5ErkJggg==');
	    };
	    SvgFactory.prototype.createDropNotAllowedIcon = function () {
	        return SvgFactory.getFromCacheOrCreate('DropNotAllowedIcon', 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyJpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMy1jMDExIDY2LjE0NTY2MSwgMjAxMi8wMi8wNi0xNDo1NjoyNyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNiAoV2luZG93cykiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6MjUyQ0MxNDY0NjBDMTFFNkEzMUVGQUE3NkQzQzU4MjYiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6MjUyQ0MxNDc0NjBDMTFFNkEzMUVGQUE3NkQzQzU4MjYiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDoyNTJDQzE0NDQ2MEMxMUU2QTMxRUZBQTc2RDNDNTgyNiIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDoyNTJDQzE0NTQ2MEMxMUU2QTMxRUZBQTc2RDNDNTgyNiIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/PstpFisAAAGLSURBVHjalJNPKERRFMbnvRmKpAnjhURKWXjJLNQsqDE7KxI1NhYU2cjKxtbGZpSNqSFT/qxkYafmLWyU2LElCwYLo0SS8J36rk7XbJz61f33nXPuuec6ad8PWdYHJsEAaOPaDTgGeXCqD0cs8TqYCf21bjIHsmC2nIMCGOT4C3yCV44rQRXPS4BOkNIOchTL4RI4A0fggvtdYAj0g2qeFc10hKlNUXwF1sAOeALfdHCuxMZEsyoOFrjwTK8bTN3YMGvjcf7BzF3RukxHIl2DfSVuALvgQIn3wCJ44zwpDpqY/i2458YouARpzmV9BEyAExWk2RTRARUgxiuMqytsg3nWRCzMgL/PWATtoJfVr+PeHd/70OoJ6bxajotyhYCTmBJv8XVssdRljD0hFoiDDCcyfgcrjFyyxFGwBBI8K5YJ+573iEEriHOjBdSr55KoSbDM4ppekFrlHPWZCupJpcoP4IWCRt7bRA5MK7sqxRQ/irxIDegAPez7qDqbNeJyv1Huvvmf7/wjwABtLlYtICx9HQAAAABJRU5ErkJggg==');
	    };
	    SvgFactory.prototype.createGroupIcon12 = function () {
	        return SvgFactory.getFromCacheOrCreate('GroupIcon12', 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAwAAAAMCAYAAABWdVznAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyJpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMy1jMDExIDY2LjE0NTY2MSwgMjAxMi8wMi8wNi0xNDo1NjoyNyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNiAoV2luZG93cykiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6MTNFQzE0NTdEOTk1MTFFNUI4MjJGMjBFRDk4MkMxNjAiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6MTNFQzE0NThEOTk1MTFFNUI4MjJGMjBFRDk4MkMxNjAiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDoxM0VDMTQ1NUQ5OTUxMUU1QjgyMkYyMEVEOTgyQzE2MCIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDoxM0VDMTQ1NkQ5OTUxMUU1QjgyMkYyMEVEOTgyQzE2MCIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/PiInRbAAAAEjSURBVHjaYuTi5XqkpKvI9/fXHwZWDlaGZ/eeM7x59raDAQj4pOQrBBUVGP78+MfAzMbE8PLKhU8Mhnb6/6//P/f/8N/d/x8AWUn1cf+BaleCsFPt5P/T/v//3/zj//8JQFrB1vM/I5IN3EAbfgBt+Au0QRBqw3sMG0DiQMwPxFuB2BzKZmLAAViA+BOU/QOI7wPxRyhfCIhT0NT/ZETi7AZiZiD+DOXL6EdlGdkWFzF8evaDgUuIg2F9eiTYBrhuIJ4NxHegfDsgnobuJGQbNgBxMRDfhfLFgDgB3UnInPVALMxAACDbcBGItwDxAyhfCRismejBiuyHiUBsDMQmUL6cSXIJf0hTDsNboEN42RkYJth58TPisV0eaMNFdBsAAgwANVJzd8zQrUcAAAAASUVORK5CYII=');
	    };
	    SvgFactory.prototype.createCutIcon = function () {
	        return SvgFactory.getFromCacheOrCreate('CutIcon', 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAlRJREFUeNqkU09okmEcfj6ThNRhjUEJDhxDZ1t4sI3lDrKDhESHpC6x6yBoh52GfcdBJDvtElEUdKhOSq1JjF0SabSton9OmIeRxVKIrUgdU5xvv8e+hXXYpRcefv+e5/mh7/tpSin8z9Gi0Sg0TTsv+edarfa+Wq2iUqmgXC6DudVqhd1uh81ma+UWi8Uv3G5ZPJ9MJmGq1+twOBynBOek6T9oG+fkkU8djymVSiGTyWBiYuL6QSb7YvLIp679+D0ej57NZpX8JD0QCPj7+vrgcrnAyJp9zskj3zD928Tr9er5fF5FIhFdiH4aMLJmn/N98R+Dq5qGSUFQwKFs1AuFggqFQrrT6bzIyJp9zoMGn7qWQU6ST4JNQeK3kd/n8+nFYlGFw+HFdDqtWLOfMHjk5wwDjckRwGYGeJVnBMdXgaNrbveJKysr/etu91pHtVo8BnyXWUnwsgHM7wAVX7MJ0cEmjWvW4eGzjpGRXnNnZ8cFeRi9pRI+dnXtjMbj/cLp57rG1tbPH0tLwd3l5QHp3RBU8E7Txr4MDb1V8bh60tOzfhN4vTc9rRYkCm4tGDX7nJNHPnWt/+CFpt1rF9emptScxKfA2DNZwThn9NtNWjoxMH1Tqru+va02NzbK47FY4PHMzJtdYPYD8OChGDCyZp9z8sinrnWXt4E7q4ODRbrelw0x2Xjyn1fImn3OySOfutYt+IDRSeCycAZeAYm7wKLkshR87A1+cILDAss4EDkNXJI8Ows8yin1nENn+5MXNA3hnpHzHBKYjWhqe4lffwkwAMRcPMqRQZ4vAAAAAElFTkSuQmCC');
	    };
	    SvgFactory.prototype.createCopyIcon = function () {
	        return SvgFactory.getFromCacheOrCreate('CopyIcon', 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAgBJREFUeNqMk79rFEEcxd/M7V2QAzVFEOMFGwNiIGCjEdIEhYODmEawsFf8G4QQSCPYyqUWCdhY2qSQECSpInvFJYT8Ki6dZO8Sb2P29pfvu+4sm+UKv/AYZna/b95ndla9WFyEUmoewG0Mr+9hGB5EYYhypZIseO0fCHa3sP/LhxVFkazd+by0tOIFAQac+3w5imPYto1Pa2tv+VxR+8bRuv8EevIRxn5uQoszpWI2RjSIBgMMLi/hui76/T6+Li+v8Pkz9k0Wo409pFHAJooUCiWqYlk46nTQ2ttD+/gY75pNPKjVmmfd7gf2vKbu5U0sMWBpzWatNcAkv7n789lZ1GdmMqQ3cbxApIUikg58H5S0JgkSE/L/L1JmoNJmMZEDzCNdK5cxwtFxHHxcXcXTqalm27Zf7rRaRKBBhkAhxcgjiYlUo16HfKlqtYpv29u95Az81EClCFLyaQ0SCib/dtNJ6qsGfDmJnRqoXIKiyVUDz8sSSGy5VnI3ikh5k1KplBnog/V19BxnRCZmV15dGCSdO1wziphcS3rrT7d71zk5Ob8+Pf3eMN4aH3/8qtGYM0hp7iyJbO0bBOrMPTz8kl6OpGoTEzEncwapaCLrRNfu6Wli0Etl6mbfdb0MiYrlXsjZyAUTE0qwOxsbo9aQ3/dGEWlYRRcX5xxG/wowAC8cIjzfyA4lAAAAAElFTkSuQmCC');
	    };
	    SvgFactory.prototype.createPasteIcon = function () {
	        return SvgFactory.getFromCacheOrCreate('PasteIcon', 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAadJREFUeNpinGLPAAaMjAxwcJ9Tk+0Bt7YPkCkKFXqt8PXqFsXv13/B1Pz/D6FZENoYZgKxMYgh9OI6i567q5hFUp4kiH9i3qTnT3auqWPgZ/gDVXsWiNPBFk+2hxtwxi0syfjy5csM0vFzGTg42Bj4+XnAEh8/fmH48eMXw9OFyQy6uroMu1bNAxlgAnbB338IJ6hlzWU4uXgJw6FDO4Ga+Rl4eXkZWFlZGb58/crw6eNHBjG7Iga1yAiG7SvmwfWw/P2LMADkraiYaIb79+4xYAOKSkpgNch6UFzwFxgy//79Y5BTUMBqwF+g3H8mJgZkPSgu+Ac04M+/fwz4AAswulBc8Ocfqg1/kGWxAEagAch6WP78RfUCIQOYmJkZ/qC44A+qAb8JeIEZZMkfXC4gwgsQNUgG/CbRC2BXIhvw8AsDgzQnkgEEvACxBMJ++h0YJmufMTA8ABry8xckGkFOxIdBakBqQXpAekGZiXPTSwbeUAEgB5hsObm58acDoJp3nxkYNn1gEANyP4MNAGKxh18ZbsXxsjMQA97/Z7gF0gPEfwACDAB/y9xB1I3/FQAAAABJRU5ErkJggg==');
	    };
	    SvgFactory.prototype.createMenuIcon = function () {
	        return SvgFactory.getFromCacheOrCreate('MenuIcon', 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyJpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMy1jMDExIDY2LjE0NTY2MSwgMjAxMi8wMi8wNi0xNDo1NjoyNyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNiAoV2luZG93cykiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6QjM3MUVBMzlERkJEMTFFNUEwMjFFNDJDMDlCMUY3OTciIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6QjM3MUVBM0FERkJEMTFFNUEwMjFFNDJDMDlCMUY3OTciPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDpCMzcxRUEzN0RGQkQxMUU1QTAyMUU0MkMwOUIxRjc5NyIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDpCMzcxRUEzOERGQkQxMUU1QTAyMUU0MkMwOUIxRjc5NyIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/Pux7nZcAAAGtSURBVHjalFM9a8JQFL0veYkfYJUQEYuIIF07uToVpGuHOgid3dJN+i+K4C6CXQqFjplcCoKbXZ0EqRUFP/CTxCS9NzTdNOmBx32P3Nx3zj33sXq9/tRqtbRYLCaLomhBANi2La5WK7NSqTRYNpt1LMsCLACO47iLMXY2CoIAm80GZFkGoVQqfWy3WzBNE6gQVveNhmHAbreDYrHYZaPRKKTr+i0ykTDBPnUzgfYEvFkYDAZWoVDQWb/fB9QD6XQajscjBCkQDodhOBzCcrkEVq1WXfoEL9EPlEdSZrMZ8Pl8frVYLO7QgRB+sPx+/GUk4qUGNvOdYSO+JpPJJdHyc8ADnUluIpH45vv9XiFbiFIQC71IjuBe5ZlM5gYlPHLOL7C4AcEgofXbXC7X4PF4vKuqahf+AWJxOBwgEokA6/V67kFRFFcGLU/SqShJkusATSNbr9fQ6XSuU6mUQP3BBIaJZyM6BuPx2Mnn85+sVqu9ttvt+2QyGXgOqInT6RTK5fIbwwl0iFI0Gv2btCA9QPdcOVzTtOdms/mAnnKkaAexES0UcG/hc375EWAA94tOP0vEOEcAAAAASUVORK5CYII=');
	    };
	    SvgFactory.prototype.createCheckboxCheckedIcon = function () {
	        return SvgFactory.getFromCacheOrCreate('CheckboxCheckedIcon', 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAA4AAAAOCAYAAAAfSC3RAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAA2ZpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMy1jMDExIDY2LjE0NTY2MSwgMjAxMi8wMi8wNi0xNDo1NjoyNyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8iIHhtbG5zOnN0UmVmPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VSZWYjIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD0ieG1wLmRpZDpFQ0VGQkU3ODM4MTFFNjExQjlCQzhERUVDNkNGMzFDMyIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDpBRkJCRDU1MTEyM0ExMUU2ODE4MUUyOTNBNTRGQkIxNyIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDpBRkJCRDU1MDEyM0ExMUU2ODE4MUUyOTNBNTRGQkIxNyIgeG1wOkNyZWF0b3JUb29sPSJBZG9iZSBQaG90b3Nob3AgQ1M2IChXaW5kb3dzKSI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOjIzMkM4M0M1M0MxMUU2MTFCOUJDOERFRUM2Q0YzMUMzIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOkVDRUZCRTc4MzgxMUU2MTFCOUJDOERFRUM2Q0YzMUMzIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+riMaEQAAAL5JREFUeNqUks0JhDAQhSd7tgtLMDUIyTXF2IdNWIE3c0ruYg9LtgcPzvpEF8SfHR8MGR75hpcwRERmrjQXCyutDKUQAkuFu2AUpsyiJ1JK0UtycRgGMsbsPBFYVRVZaw/+7Zu895znOY/j+PPWT7oGp2lirTU3TbPz/4IAAGLALeic47Ztlx7RELHrusPAAwgoy7LlrOuay7I8TXIadYOLouC+7+XgBiP2lTbw0crFGAF9ANq1kS75G8xXgAEAiqu9OeWZ/voAAAAASUVORK5CYII=');
	    };
	    SvgFactory.prototype.createCheckboxCheckedReadOnlyIcon = function () {
	        return SvgFactory.getFromCacheOrCreate('CheckboxCheckedReadOnlyIcon', 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAA4AAAAOCAYAAAAfSC3RAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyJpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMy1jMDExIDY2LjE0NTY2MSwgMjAxMi8wMi8wNi0xNDo1NjoyNyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNiAoV2luZG93cykiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6NTZENDVDNkY0NDVFMTFFNkI1MjZCRkJDQ0FEMUEyNDMiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6NTZENDVDNzA0NDVFMTFFNkI1MjZCRkJDQ0FEMUEyNDMiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDo1NkQ0NUM2RDQ0NUUxMUU2QjUyNkJGQkNDQUQxQTI0MyIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDo1NkQ0NUM2RTQ0NUUxMUU2QjUyNkJGQkNDQUQxQTI0MyIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/PiE1TFsAAAGLSURBVHjadJI9a8JQFIbfSFBBakDaDg5O0nay4OSPsEFoCq4JODhUShd3F9emFreKqJOlS6Xg4OB/cIkZijjXwRa/uthzLokESS683I+cJ+fec15pv9/DHfP5/JSmR1KedOEcW6QP0nMqlfp2YyUXJOiWpleSAv/xQzIIfudNyAO9+UHr9Rrtdhuz2SzOMU4sQrQ4o7nF2f3SDIdD1Ot19Ho9ODEtYs454z0p7gdNp1OYpontdot0Ou0ec+wDgyrvlsslxuPxAdpsNmg0GnxFVCoVaJrm/WeewSte9ft9lMtljEYj8YWvNhgMkMvloOs6ZFn2gpeHnaIoohDNZhO73Q7dbhfRaBTVahWJROL4FX+y06frQqGAyWSCTqcDy7KwWq1Qq9WQzWb9nv8VcpqLcDgsrprJZASkqiqKxWJAS/HJ4IvTXCSTSRiGISpYKpUQiUSCjPAknOMxgLRYLGDbtsgci8WOIbbZHbvHaznNMcJJwPV+SbprOSnA5Ddccq4eyeY3kUyvyf8FGAAA/p3KIKgjXwAAAABJRU5ErkJggg==');
	    };
	    SvgFactory.prototype.createCheckboxUncheckedIcon = function () {
	        return SvgFactory.getFromCacheOrCreate('CheckboxUncheckedIcon', 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAA4AAAAOCAYAAAAfSC3RAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAA2ZpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMy1jMDExIDY2LjE0NTY2MSwgMjAxMi8wMi8wNi0xNDo1NjoyNyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8iIHhtbG5zOnN0UmVmPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VSZWYjIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD0ieG1wLmRpZDpFQ0VGQkU3ODM4MTFFNjExQjlCQzhERUVDNkNGMzFDMyIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDo2MkU1Rjk1NDExNDExMUU2ODhEQkMyRTJGOUNGODYyQyIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDo2MkU1Rjk1MzExNDExMUU2ODhEQkMyRTJGOUNGODYyQyIgeG1wOkNyZWF0b3JUb29sPSJBZG9iZSBQaG90b3Nob3AgQ1M2IChXaW5kb3dzKSI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOjI1MkM4M0M1M0MxMUU2MTFCOUJDOERFRUM2Q0YzMUMzIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOkVDRUZCRTc4MzgxMUU2MTFCOUJDOERFRUM2Q0YzMUMzIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+t+CXswAAAFBJREFUeNrsksENwDAIA023a9YGNqlItkixlAFIn1VOMv5wvACAOxOZWUwsB6Gqswp36QivJNhBRHDhI0f8j9jNrCy4O2twNMobT/7QeQUYAFaKU1yE2OfhAAAAAElFTkSuQmCC');
	    };
	    SvgFactory.prototype.createCheckboxUncheckedReadOnlyIcon = function () {
	        return SvgFactory.getFromCacheOrCreate('CheckboxUncheckedReadOnlyIcon', 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAA4AAAAOCAYAAAAfSC3RAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyJpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMy1jMDExIDY2LjE0NTY2MSwgMjAxMi8wMi8wNi0xNDo1NjoyNyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNiAoV2luZG93cykiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6NjE4MjE1MTc0NDVFMTFFNjgyNzA5QzQ5MjBBRTM0QTkiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6NjE4MjE1MTg0NDVFMTFFNjgyNzA5QzQ5MjBBRTM0QTkiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDo2MTgyMTUxNTQ0NUUxMUU2ODI3MDlDNDkyMEFFMzRBOSIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDo2MTgyMTUxNjQ0NUUxMUU2ODI3MDlDNDkyMEFFMzRBOSIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/PoIZc5kAAADFSURBVHjaYvz//z8DDDx69EgESBUBsQ8Qq0GFbwDxJiCeJCcn9wamlhGmEagpGEjNBWJ+BuzgExAnATWvhWuEaloN4jPgByBbQkGaGR8+fCgK5NwBYj4G4gDIZlUmIJFLgiYGqNoCkEY/BtKBD0ijBhka1ZkYyAO/mKDxRCq4xwSNXFLBVlB0iAEZt0mODmBkvgKlCGjkMhCRAECp5xU4cKDJKAyIP+PR9BmWalDSKloi9wUFOSj0gPgWyE9APBE5kQMEGAD0/UBfnjaiGAAAAABJRU5ErkJggg==');
	    };
	    SvgFactory.prototype.createCheckboxIndeterminateIcon = function () {
	        return SvgFactory.getFromCacheOrCreate('CheckboxIndeterminateIcon', 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAA4AAAAOCAYAAAAfSC3RAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAA2ZpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMy1jMDExIDY2LjE0NTY2MSwgMjAxMi8wMi8wNi0xNDo1NjoyNyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8iIHhtbG5zOnN0UmVmPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VSZWYjIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD0ieG1wLmRpZDpFQ0VGQkU3ODM4MTFFNjExQjlCQzhERUVDNkNGMzFDMyIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDpGMjU4MzhGQjEyM0ExMUU2QjAxM0Q2QjZFQ0IzNzM4NiIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDpGMjU4MzhGQTEyM0ExMUU2QjAxM0Q2QjZFQ0IzNzM4NiIgeG1wOkNyZWF0b3JUb29sPSJBZG9iZSBQaG90b3Nob3AgQ1M2IChXaW5kb3dzKSI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOjIzMkM4M0M1M0MxMUU2MTFCOUJDOERFRUM2Q0YzMUMzIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOkVDRUZCRTc4MzgxMUU2MTFCOUJDOERFRUM2Q0YzMUMzIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+2Xml2QAAAGBJREFUeNpiYGBg8ATiZ0D8n0j8DKqH4dnhw4f/EwtAakF6GEGmAAEDKYCRkZGBiYFMQH+NLNjcjw2ghwMLIQWDx48Do/H5kSNHiNZw9OhREPUCRHiBNJOQyJ+A9AAEGACqkFldNkPUwwAAAABJRU5ErkJggg==');
	    };
	    SvgFactory.prototype.createCheckboxIndeterminateReadOnlyIcon = function () {
	        return SvgFactory.getFromCacheOrCreate('CheckboxIndeterminateReadOnlyIcon', 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAA4AAAAOCAYAAAAfSC3RAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyJpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMy1jMDExIDY2LjE0NTY2MSwgMjAxMi8wMi8wNi0xNDo1NjoyNyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNiAoV2luZG93cykiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6Nzg3RjczNTA0NDVFMTFFNkE4Q0NDN0E3NUI3Qjk5QjIiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6Nzg3RjczNTE0NDVFMTFFNkE4Q0NDN0E3NUI3Qjk5QjIiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDo3ODdGNzM0RTQ0NUUxMUU2QThDQ0M3QTc1QjdCOTlCMiIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDo3ODdGNzM0RjQ0NUUxMUU2QThDQ0M3QTc1QjdCOTlCMiIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/PhD2+R8AAADRSURBVHjaYvz//z8DDDx69EgESBUBsQ8Qq0GFbwDxJiCeJCcn9wamlhGmEagpGEjNBWJ+BuzgExAnATWvhWuEaloN4jPgByBbQkGaGR8+fCgK5NwBYj4G4gDIZlUmIJFLgiYGqNoCkEY/BtKBDwuQ0IDx5OXl8aoGegvGVGdiIA/8YoHGkz6aiYTAPSZo5JIKtoKiQwzIuE1ydAAj8xUoRUAjl4GIBABKPa/AgQNNRmFA/BmPps+wVIOSVtESuS8oyEGhB8S3QH4C4onIiRwgwABzikY1hHfO+QAAAABJRU5ErkJggg==');
	    };
	    SvgFactory.prototype.createGroupExpandedIcon = function () {
	        return SvgFactory.getFromCacheOrCreate('GroupExpandedIcon', 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAsAAAALCAYAAACprHcmAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyJpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMy1jMDExIDY2LjE0NTY2MSwgMjAxMi8wMi8wNi0xNDo1NjoyNyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNiAoV2luZG93cykiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6NzBBODQ4M0ExMjM4MTFFNkFDNEJDMjUzQUJBQ0I2QjkiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6NzBBODQ4M0IxMjM4MTFFNkFDNEJDMjUzQUJBQ0I2QjkiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDo3MEE4NDgzODEyMzgxMUU2QUM0QkMyNTNBQkFDQjZCOSIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDo3MEE4NDgzOTEyMzgxMUU2QUM0QkMyNTNBQkFDQjZCOSIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/PhKAo60AAADVSURBVHjajFC9DkRgEJzzFhqiligURKcjR+UFJK7wGN7jOq+glXgCvSgUCnyVn47GHsVdcURsss3s7OzOPEzTdB3HeTPGeMMw0DQNOI4Dz/PI8xyWZSGO4y4MwxeSJGnruqarGseRNE1r4fv+YSgIwgErioJwpgrggHmeR7Bt+xZ5GAbCNE2/0zvpv78v6bpOUFX1lvK6roQz92dkWZYJiqLcSmOeZ9qDb6uqusx5WRaSJIlBFEUnTdNuC536vifXdaksSwqCgLIsoyiKdnNs23l+BBgAK/54I/P5bhMAAAAASUVORK5CYII=');
	    };
	    SvgFactory.prototype.createGroupContractedIcon = function () {
	        return SvgFactory.getFromCacheOrCreate('GroupContractedIcon', 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAsAAAALCAYAAACprHcmAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyJpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMy1jMDExIDY2LjE0NTY2MSwgMjAxMi8wMi8wNi0xNDo1NjoyNyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNiAoV2luZG93cykiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6N0U2QUVBRDYxMjM4MTFFNjk3NjVBRUM0MUJDRjFCODgiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6N0U2QUVBRDcxMjM4MTFFNjk3NjVBRUM0MUJDRjFCODgiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDo3RTZBRUFENDEyMzgxMUU2OTc2NUFFQzQxQkNGMUI4OCIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDo3RTZBRUFENTEyMzgxMUU2OTc2NUFFQzQxQkNGMUI4OCIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/PhjzsKsAAADSSURBVHjajJAvioVgFMXPuAuLYhYMBsVmU54mNyA4wWW4j2luwSq4ArsYDAZ9X/JP0+KZ58CkgTffD264l3MPnPPh+34cRdGXEEL1PA/TNEFRFKiqirZtEQQByrJ85nn+iaqq5nEc+Y5t2+g4zow0TSlD13XEf66/JElChGEoJV7Xldj3/WfRNI0A/sx9v3Fdl7BtW8r5ui6CkpimSViWJSU+joN38fMwDG+F53nSMAwBXdejuq6fr9K5LAvjOGbf98yyjE3TsCiKO5x4/Ty+BRgA3R6JXc/jqsQAAAAASUVORK5CYII=');
	    };
	    SvgFactory.imageCache = {};
	    return SvgFactory;
	})();
	exports.SvgFactory = SvgFactory;
	// i couldn't figure out how to not make these blurry
	/*function createPlusMinus(plus: boolean) {
	    var eSvg = document.createElementNS(SVG_NS, "svg");
	    var size = "14";
	    eSvg.setAttribute("width", size);
	    eSvg.setAttribute("height", size);

	    var eRect = document.createElementNS(SVG_NS, "rect");
	    eRect.setAttribute('x', '1');
	    eRect.setAttribute('y', '1');
	    eRect.setAttribute('width', '12');
	    eRect.setAttribute('height', '12');
	    eRect.setAttribute('rx', '2');
	    eRect.setAttribute('ry', '2');
	    eRect.setAttribute('fill', 'none');
	    eRect.setAttribute('stroke', 'black');
	    eRect.setAttribute('stroke-width', '1');
	    eRect.setAttribute('stroke-linecap', 'butt');
	    eSvg.appendChild(eRect);

	    var eLineAcross = document.createElementNS(SVG_NS, "line");
	    eLineAcross.setAttribute('x1','2');
	    eLineAcross.setAttribute('x2','12');
	    eLineAcross.setAttribute('y1','7');
	    eLineAcross.setAttribute('y2','7');
	    eLineAcross.setAttribute('stroke','black');
	    eLineAcross.setAttribute('stroke-width', '1');
	    eLineAcross.setAttribute('stroke-linecap', 'butt');
	    eSvg.appendChild(eLineAcross);

	    if (plus) {
	        var eLineDown = document.createElementNS(SVG_NS, "line");
	        eLineDown.setAttribute('x1','7');
	        eLineDown.setAttribute('x2','7');
	        eLineDown.setAttribute('y1','2');
	        eLineDown.setAttribute('y2','12');
	        eLineDown.setAttribute('stroke','black');
	        eLineDown.setAttribute('stroke-width', '1');
	        eLineDown.setAttribute('stroke-linecap', 'butt');
	        eSvg.appendChild(eLineDown);
	    }

	    return eSvg;
	}*/
	function createPolygonSvg(points, width) {
	    var eSvg = createIconSvg(width);
	    var eDescIcon = document.createElementNS(SVG_NS, "polygon");
	    eDescIcon.setAttribute("points", points);
	    eSvg.appendChild(eDescIcon);
	    return eSvg;
	}
	// util function for the above
	function createIconSvg(width) {
	    var eSvg = document.createElementNS(SVG_NS, "svg");
	    if (width > 0) {
	        eSvg.setAttribute("width", width);
	        eSvg.setAttribute("height", width);
	    }
	    else {
	        eSvg.setAttribute("width", "10");
	        eSvg.setAttribute("height", "10");
	    }
	    return eSvg;
	}
	function createCircle(fill) {
	    var eSvg = createIconSvg();
	    var eCircle = document.createElementNS(SVG_NS, "circle");
	    eCircle.setAttribute("cx", "5");
	    eCircle.setAttribute("cy", "5");
	    eCircle.setAttribute("r", "5");
	    eCircle.setAttribute("stroke", "black");
	    eCircle.setAttribute("stroke-width", "2");
	    if (fill) {
	        eCircle.setAttribute("fill", "black");
	    }
	    else {
	        eCircle.setAttribute("fill", "none");
	    }
	    eSvg.appendChild(eCircle);
	    return eSvg;
	}


/***/ },
/* 60 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
	 * @version v7.0.2
	 * @link http://www.ag-grid.com/
	 * @license MIT
	 */
	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var utils_1 = __webpack_require__(7);
	var context_1 = __webpack_require__(6);
	var cellRendererFactory_1 = __webpack_require__(55);
	/** Class to use a cellRenderer. */
	var CellRendererService = (function () {
	    function CellRendererService() {
	    }
	    /** Uses a cellRenderer, and returns the cellRenderer object if it is a class implementing ICellRenderer.
	     * @cellRendererKey: The cellRenderer to use. Can be: a) a class that we call 'new' on b) a function we call
	     *                   or c) a string that we use to look up the cellRenderer.
	     * @params: The params to pass to the cell renderer if it's a function or a class.
	     * @eTarget: The DOM element we will put the results of the html element into *
	     * @return: If options a, it returns the created class instance */
	    CellRendererService.prototype.useCellRenderer = function (cellRendererKey, eTarget, params) {
	        var cellRenderer = this.lookUpCellRenderer(cellRendererKey);
	        if (utils_1.Utils.missing(cellRenderer)) {
	            // this is a bug in users config, they specified a cellRenderer that doesn't exist,
	            // the factory already printed to console, so here we just skip
	            return;
	        }
	        var resultFromRenderer;
	        var iCellRendererInstance = null;
	        this.checkForDeprecatedItems(cellRenderer);
	        // we check if the class has the 'getGui' method to know if it's a component
	        var rendererIsAComponent = this.doesImplementICellRenderer(cellRenderer);
	        // if it's a component, we create and initialise it
	        if (rendererIsAComponent) {
	            var CellRendererClass = cellRenderer;
	            iCellRendererInstance = new CellRendererClass();
	            this.context.wireBean(iCellRendererInstance);
	            if (iCellRendererInstance.init) {
	                iCellRendererInstance.init(params);
	            }
	            resultFromRenderer = iCellRendererInstance.getGui();
	        }
	        else {
	            // otherwise it's a function, so we just use it
	            var cellRendererFunc = cellRenderer;
	            resultFromRenderer = cellRendererFunc(params);
	        }
	        if (resultFromRenderer === null || resultFromRenderer === '') {
	            return;
	        }
	        if (utils_1.Utils.isNodeOrElement(resultFromRenderer)) {
	            // a dom node or element was returned, so add child
	            eTarget.appendChild(resultFromRenderer);
	        }
	        else {
	            // otherwise assume it was html, so just insert
	            eTarget.innerHTML = resultFromRenderer;
	        }
	        return iCellRendererInstance;
	    };
	    CellRendererService.prototype.checkForDeprecatedItems = function (cellRenderer) {
	        if (cellRenderer && cellRenderer.renderer) {
	            console.warn('ag-grid: colDef.cellRenderer should not be an object, it should be a string, function or class. this ' +
	                'changed in v4.1.x, please check the documentation on Cell Rendering, or if you are doing grouping, look at the grouping examples.');
	        }
	    };
	    CellRendererService.prototype.doesImplementICellRenderer = function (cellRenderer) {
	        // see if the class has a prototype that defines a getGui method. this is very rough,
	        // but javascript doesn't have types, so is the only way!
	        return cellRenderer.prototype && 'getGui' in cellRenderer.prototype;
	    };
	    CellRendererService.prototype.lookUpCellRenderer = function (cellRendererKey) {
	        if (typeof cellRendererKey === 'string') {
	            return this.cellRendererFactory.getCellRenderer(cellRendererKey);
	        }
	        else {
	            return cellRendererKey;
	        }
	    };
	    __decorate([
	        context_1.Autowired('cellRendererFactory'), 
	        __metadata('design:type', cellRendererFactory_1.CellRendererFactory)
	    ], CellRendererService.prototype, "cellRendererFactory", void 0);
	    __decorate([
	        context_1.Autowired('context'), 
	        __metadata('design:type', context_1.Context)
	    ], CellRendererService.prototype, "context", void 0);
	    CellRendererService = __decorate([
	        context_1.Bean('cellRendererService'), 
	        __metadata('design:paramtypes', [])
	    ], CellRendererService);
	    return CellRendererService;
	})();
	exports.CellRendererService = CellRendererService;


/***/ },
/* 61 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
	 * @version v7.0.2
	 * @link http://www.ag-grid.com/
	 * @license MIT
	 */
	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var context_1 = __webpack_require__(6);
	var gridOptionsWrapper_1 = __webpack_require__(3);
	var ValueFormatterService = (function () {
	    function ValueFormatterService() {
	    }
	    ValueFormatterService.prototype.formatValue = function (column, rowNode, $scope, rowIndex, value) {
	        var formatter;
	        var colDef = column.getColDef();
	        // if floating, give preference to the floating formatter
	        if (rowNode.floating) {
	            formatter = colDef.floatingCellFormatter ? colDef.floatingCellFormatter : colDef.cellFormatter;
	        }
	        else {
	            formatter = colDef.cellFormatter;
	        }
	        var result = null;
	        if (formatter) {
	            var params = {
	                value: value,
	                node: rowNode,
	                column: column,
	                $scope: $scope,
	                rowIndex: rowIndex,
	                api: this.gridOptionsWrapper.getApi(),
	                context: this.gridOptionsWrapper.getContext()
	            };
	            result = formatter(params);
	        }
	        return result;
	    };
	    __decorate([
	        context_1.Autowired('gridOptionsWrapper'), 
	        __metadata('design:type', gridOptionsWrapper_1.GridOptionsWrapper)
	    ], ValueFormatterService.prototype, "gridOptionsWrapper", void 0);
	    ValueFormatterService = __decorate([
	        context_1.Bean('valueFormatterService'), 
	        __metadata('design:paramtypes', [])
	    ], ValueFormatterService);
	    return ValueFormatterService;
	})();
	exports.ValueFormatterService = ValueFormatterService;


/***/ },
/* 62 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
	 * @version v7.0.2
	 * @link http://www.ag-grid.com/
	 * @license MIT
	 */
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var component_1 = __webpack_require__(47);
	var rowNode_1 = __webpack_require__(27);
	var utils_1 = __webpack_require__(7);
	var context_1 = __webpack_require__(6);
	var gridOptionsWrapper_1 = __webpack_require__(3);
	var svgFactory_1 = __webpack_require__(59);
	var svgFactory = svgFactory_1.SvgFactory.getInstance();
	var CheckboxSelectionComponent = (function (_super) {
	    __extends(CheckboxSelectionComponent, _super);
	    function CheckboxSelectionComponent() {
	        _super.call(this, "<span class=\"ag-selection-checkbox\"/>");
	    }
	    CheckboxSelectionComponent.prototype.createAndAddIcons = function () {
	        this.eCheckedIcon = utils_1.Utils.createIconNoSpan('checkboxChecked', this.gridOptionsWrapper, null, svgFactory.createCheckboxCheckedIcon);
	        this.eUncheckedIcon = utils_1.Utils.createIconNoSpan('checkboxUnchecked', this.gridOptionsWrapper, null, svgFactory.createCheckboxUncheckedIcon);
	        this.eIndeterminateIcon = utils_1.Utils.createIconNoSpan('checkboxIndeterminate', this.gridOptionsWrapper, null, svgFactory.createCheckboxIndeterminateIcon);
	        var eGui = this.getGui();
	        eGui.appendChild(this.eCheckedIcon);
	        eGui.appendChild(this.eUncheckedIcon);
	        eGui.appendChild(this.eIndeterminateIcon);
	    };
	    CheckboxSelectionComponent.prototype.onSelectionChanged = function () {
	        var state = this.rowNode.isSelected();
	        utils_1.Utils.setVisible(this.eCheckedIcon, state === true);
	        utils_1.Utils.setVisible(this.eUncheckedIcon, state === false);
	        utils_1.Utils.setVisible(this.eIndeterminateIcon, typeof state !== 'boolean');
	    };
	    CheckboxSelectionComponent.prototype.onCheckedClicked = function () {
	        var groupSelectsFiltered = this.gridOptionsWrapper.isGroupSelectsFiltered();
	        var updatedCount = this.rowNode.setSelectedParams({ newValue: false, groupSelectsFiltered: groupSelectsFiltered });
	        return updatedCount;
	    };
	    CheckboxSelectionComponent.prototype.onUncheckedClicked = function (event) {
	        var groupSelectsFiltered = this.gridOptionsWrapper.isGroupSelectsFiltered();
	        var updatedCount = this.rowNode.setSelectedParams({ newValue: true, rangeSelect: event.shiftKey, groupSelectsFiltered: groupSelectsFiltered });
	        return updatedCount;
	    };
	    CheckboxSelectionComponent.prototype.onIndeterminateClicked = function (event) {
	        var result = this.onUncheckedClicked(event);
	        if (result === 0) {
	            this.onCheckedClicked();
	        }
	    };
	    CheckboxSelectionComponent.prototype.init = function (params) {
	        this.createAndAddIcons();
	        this.rowNode = params.rowNode;
	        this.onSelectionChanged();
	        // we don't want the row clicked event to fire when selecting the checkbox, otherwise the row
	        // would possibly get selected twice
	        this.addGuiEventListener('click', function (event) { return event.stopPropagation(); });
	        // likewise we don't want double click on this icon to open a group
	        this.addGuiEventListener('dblclick', function (event) { return event.stopPropagation(); });
	        this.addDestroyableEventListener(this.eCheckedIcon, 'click', this.onCheckedClicked.bind(this));
	        this.addDestroyableEventListener(this.eUncheckedIcon, 'click', this.onUncheckedClicked.bind(this));
	        this.addDestroyableEventListener(this.eIndeterminateIcon, 'click', this.onIndeterminateClicked.bind(this));
	        this.addDestroyableEventListener(this.rowNode, rowNode_1.RowNode.EVENT_ROW_SELECTED, this.onSelectionChanged.bind(this));
	    };
	    __decorate([
	        context_1.Autowired('gridOptionsWrapper'), 
	        __metadata('design:type', gridOptionsWrapper_1.GridOptionsWrapper)
	    ], CheckboxSelectionComponent.prototype, "gridOptionsWrapper", void 0);
	    return CheckboxSelectionComponent;
	})(component_1.Component);
	exports.CheckboxSelectionComponent = CheckboxSelectionComponent;


/***/ },
/* 63 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
	 * @version v7.0.2
	 * @link http://www.ag-grid.com/
	 * @license MIT
	 */
	var utils_1 = __webpack_require__(7);
	var column_1 = __webpack_require__(15);
	var SetLeftFeature = (function () {
	    function SetLeftFeature(columnOrGroup, eCell) {
	        this.destroyFunctions = [];
	        this.columnOrGroup = columnOrGroup;
	        this.eCell = eCell;
	        this.init();
	    }
	    SetLeftFeature.prototype.init = function () {
	        var _this = this;
	        var listener = this.onLeftChanged.bind(this);
	        this.columnOrGroup.addEventListener(column_1.Column.EVENT_LEFT_CHANGED, listener);
	        this.destroyFunctions.push(function () {
	            _this.columnOrGroup.removeEventListener(column_1.Column.EVENT_LEFT_CHANGED, listener);
	        });
	        this.onLeftChanged();
	    };
	    SetLeftFeature.prototype.onLeftChanged = function () {
	        var newLeft = this.columnOrGroup.getLeft();
	        if (utils_1.Utils.exists(newLeft)) {
	            this.eCell.style.left = this.columnOrGroup.getLeft() + 'px';
	        }
	        else {
	            this.eCell.style.left = '';
	        }
	    };
	    SetLeftFeature.prototype.destroy = function () {
	        this.destroyFunctions.forEach(function (func) {
	            func();
	        });
	    };
	    return SetLeftFeature;
	})();
	exports.SetLeftFeature = SetLeftFeature;


/***/ },
/* 64 */
/***/ function(module, exports) {

	/**
	 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
	 * @version v7.0.2
	 * @link http://www.ag-grid.com/
	 * @license MIT
	 */
	var MethodNotImplementedException = (function () {
	    function MethodNotImplementedException() {
	    }
	    return MethodNotImplementedException;
	})();
	exports.MethodNotImplementedException = MethodNotImplementedException;


/***/ },
/* 65 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
	 * @version v7.0.2
	 * @link http://www.ag-grid.com/
	 * @license MIT
	 */
	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var context_1 = __webpack_require__(6);
	var constants_1 = __webpack_require__(8);
	var columnController_1 = __webpack_require__(13);
	var floatingRowModel_1 = __webpack_require__(26);
	var utils_1 = __webpack_require__(7);
	var gridRow_1 = __webpack_require__(34);
	var gridCell_1 = __webpack_require__(33);
	var CellNavigationService = (function () {
	    function CellNavigationService() {
	    }
	    CellNavigationService.prototype.getNextCellToFocus = function (key, lastCellToFocus) {
	        switch (key) {
	            case constants_1.Constants.KEY_UP: return this.getCellAbove(lastCellToFocus);
	            case constants_1.Constants.KEY_DOWN: return this.getCellBelow(lastCellToFocus);
	            case constants_1.Constants.KEY_RIGHT: return this.getCellToRight(lastCellToFocus);
	            case constants_1.Constants.KEY_LEFT: return this.getCellToLeft(lastCellToFocus);
	            default: console.log('ag-Grid: unknown key for navigation ' + key);
	        }
	    };
	    CellNavigationService.prototype.getCellToLeft = function (lastCell) {
	        var colToLeft = this.columnController.getDisplayedColBefore(lastCell.column);
	        if (!colToLeft) {
	            return null;
	        }
	        else {
	            return new gridCell_1.GridCell(lastCell.rowIndex, lastCell.floating, colToLeft);
	        }
	    };
	    CellNavigationService.prototype.getCellToRight = function (lastCell) {
	        var colToRight = this.columnController.getDisplayedColAfter(lastCell.column);
	        // if already on right, do nothing
	        if (!colToRight) {
	            return null;
	        }
	        else {
	            return new gridCell_1.GridCell(lastCell.rowIndex, lastCell.floating, colToRight);
	        }
	    };
	    CellNavigationService.prototype.getRowBelow = function (lastRow) {
	        // if already on top row, do nothing
	        if (this.isLastRowInContainer(lastRow)) {
	            if (lastRow.isFloatingBottom()) {
	                return null;
	            }
	            else if (lastRow.isNotFloating()) {
	                if (this.floatingRowModel.isRowsToRender(constants_1.Constants.FLOATING_BOTTOM)) {
	                    return new gridRow_1.GridRow(0, constants_1.Constants.FLOATING_BOTTOM);
	                }
	                else {
	                    return null;
	                }
	            }
	            else {
	                if (this.rowModel.isRowsToRender()) {
	                    return new gridRow_1.GridRow(0, null);
	                }
	                else if (this.floatingRowModel.isRowsToRender(constants_1.Constants.FLOATING_BOTTOM)) {
	                    return new gridRow_1.GridRow(0, constants_1.Constants.FLOATING_BOTTOM);
	                }
	                else {
	                    return null;
	                }
	            }
	        }
	        else {
	            return new gridRow_1.GridRow(lastRow.rowIndex + 1, lastRow.floating);
	        }
	    };
	    CellNavigationService.prototype.getCellBelow = function (lastCell) {
	        var rowBelow = this.getRowBelow(lastCell.getGridRow());
	        if (rowBelow) {
	            return new gridCell_1.GridCell(rowBelow.rowIndex, rowBelow.floating, lastCell.column);
	        }
	        else {
	            return null;
	        }
	    };
	    CellNavigationService.prototype.isLastRowInContainer = function (gridRow) {
	        if (gridRow.isFloatingTop()) {
	            var lastTopIndex = this.floatingRowModel.getFloatingTopRowData().length - 1;
	            return lastTopIndex === gridRow.rowIndex;
	        }
	        else if (gridRow.isFloatingBottom()) {
	            var lastBottomIndex = this.floatingRowModel.getFloatingBottomRowData().length - 1;
	            return lastBottomIndex === gridRow.rowIndex;
	        }
	        else {
	            var lastBodyIndex = this.rowModel.getRowCount() - 1;
	            return lastBodyIndex === gridRow.rowIndex;
	        }
	    };
	    CellNavigationService.prototype.getRowAbove = function (lastRow) {
	        // if already on top row, do nothing
	        if (lastRow.rowIndex === 0) {
	            if (lastRow.isFloatingTop()) {
	                return null;
	            }
	            else if (lastRow.isNotFloating()) {
	                if (this.floatingRowModel.isRowsToRender(constants_1.Constants.FLOATING_TOP)) {
	                    return this.getLastFloatingTopRow();
	                }
	                else {
	                    return null;
	                }
	            }
	            else {
	                // last floating bottom
	                if (this.rowModel.isRowsToRender()) {
	                    return this.getLastBodyCell();
	                }
	                else if (this.floatingRowModel.isRowsToRender(constants_1.Constants.FLOATING_TOP)) {
	                    return this.getLastFloatingTopRow();
	                }
	                else {
	                    return null;
	                }
	            }
	        }
	        else {
	            return new gridRow_1.GridRow(lastRow.rowIndex - 1, lastRow.floating);
	        }
	    };
	    CellNavigationService.prototype.getCellAbove = function (lastCell) {
	        var rowAbove = this.getRowAbove(lastCell.getGridRow());
	        if (rowAbove) {
	            return new gridCell_1.GridCell(rowAbove.rowIndex, rowAbove.floating, lastCell.column);
	        }
	        else {
	            return null;
	        }
	    };
	    CellNavigationService.prototype.getLastBodyCell = function () {
	        var lastBodyRow = this.rowModel.getRowCount() - 1;
	        return new gridRow_1.GridRow(lastBodyRow, null);
	    };
	    CellNavigationService.prototype.getLastFloatingTopRow = function () {
	        var lastFloatingRow = this.floatingRowModel.getFloatingTopRowData().length - 1;
	        return new gridRow_1.GridRow(lastFloatingRow, constants_1.Constants.FLOATING_TOP);
	    };
	    CellNavigationService.prototype.getNextTabbedCell = function (gridCell, backwards) {
	        if (backwards) {
	            return this.getNextTabbedCellBackwards(gridCell);
	        }
	        else {
	            return this.getNextTabbedCellForwards(gridCell);
	        }
	    };
	    CellNavigationService.prototype.getNextTabbedCellForwards = function (gridCell) {
	        var displayedColumns = this.columnController.getAllDisplayedColumns();
	        var newRowIndex = gridCell.rowIndex;
	        var newFloating = gridCell.floating;
	        // move along to the next cell
	        var newColumn = this.columnController.getDisplayedColAfter(gridCell.column);
	        // check if end of the row, and if so, go forward a row
	        if (!newColumn) {
	            newColumn = displayedColumns[0];
	            var rowBelow = this.getRowBelow(gridCell.getGridRow());
	            if (utils_1.Utils.missing(rowBelow)) {
	                return;
	            }
	            newRowIndex = rowBelow.rowIndex;
	            newFloating = rowBelow.floating;
	        }
	        return new gridCell_1.GridCell(newRowIndex, newFloating, newColumn);
	    };
	    CellNavigationService.prototype.getNextTabbedCellBackwards = function (gridCell) {
	        var displayedColumns = this.columnController.getAllDisplayedColumns();
	        var newRowIndex = gridCell.rowIndex;
	        var newFloating = gridCell.floating;
	        // move along to the next cell
	        var newColumn = this.columnController.getDisplayedColBefore(gridCell.column);
	        // check if end of the row, and if so, go forward a row
	        if (!newColumn) {
	            newColumn = displayedColumns[displayedColumns.length - 1];
	            var rowAbove = this.getRowAbove(gridCell.getGridRow());
	            if (utils_1.Utils.missing(rowAbove)) {
	                return;
	            }
	            newRowIndex = rowAbove.rowIndex;
	            newFloating = rowAbove.floating;
	        }
	        return new gridCell_1.GridCell(newRowIndex, newFloating, newColumn);
	    };
	    __decorate([
	        context_1.Autowired('columnController'), 
	        __metadata('design:type', columnController_1.ColumnController)
	    ], CellNavigationService.prototype, "columnController", void 0);
	    __decorate([
	        context_1.Autowired('rowModel'), 
	        __metadata('design:type', Object)
	    ], CellNavigationService.prototype, "rowModel", void 0);
	    __decorate([
	        context_1.Autowired('floatingRowModel'), 
	        __metadata('design:type', floatingRowModel_1.FloatingRowModel)
	    ], CellNavigationService.prototype, "floatingRowModel", void 0);
	    CellNavigationService = __decorate([
	        context_1.Bean('cellNavigationService'), 
	        __metadata('design:paramtypes', [])
	    ], CellNavigationService);
	    return CellNavigationService;
	})();
	exports.CellNavigationService = CellNavigationService;


/***/ },
/* 66 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
	 * @version v7.0.2
	 * @link http://www.ag-grid.com/
	 * @license MIT
	 */
	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var gridOptionsWrapper_1 = __webpack_require__(3);
	var columnController_1 = __webpack_require__(13);
	var gridPanel_1 = __webpack_require__(24);
	var column_1 = __webpack_require__(15);
	var context_1 = __webpack_require__(6);
	var headerContainer_1 = __webpack_require__(67);
	var eventService_1 = __webpack_require__(4);
	var events_1 = __webpack_require__(10);
	var HeaderRenderer = (function () {
	    function HeaderRenderer() {
	    }
	    HeaderRenderer.prototype.init = function () {
	        var _this = this;
	        this.eHeaderViewport = this.gridPanel.getHeaderViewport();
	        this.eRoot = this.gridPanel.getRoot();
	        this.eHeaderOverlay = this.gridPanel.getHeaderOverlay();
	        this.centerContainer = new headerContainer_1.HeaderContainer(this.gridPanel.getHeaderContainer(), this.gridPanel.getHeaderViewport(), this.eRoot, null);
	        this.childContainers = [this.centerContainer];
	        if (!this.gridOptionsWrapper.isForPrint()) {
	            this.pinnedLeftContainer = new headerContainer_1.HeaderContainer(this.gridPanel.getPinnedLeftHeader(), null, this.eRoot, column_1.Column.PINNED_LEFT);
	            this.pinnedRightContainer = new headerContainer_1.HeaderContainer(this.gridPanel.getPinnedRightHeader(), null, this.eRoot, column_1.Column.PINNED_RIGHT);
	            this.childContainers.push(this.pinnedLeftContainer);
	            this.childContainers.push(this.pinnedRightContainer);
	        }
	        this.childContainers.forEach(function (container) { return _this.context.wireBean(container); });
	        // when grid columns change, it means the number of rows in the header has changed and it's all new columns
	        this.eventService.addEventListener(events_1.Events.EVENT_GRID_COLUMNS_CHANGED, this.onGridColumnsChanged.bind(this));
	        // shotgun way to get labels to change, eg from sum(amount) to avg(amount)
	        this.eventService.addEventListener(events_1.Events.EVENT_COLUMN_VALUE_CHANGED, this.refreshHeader.bind(this));
	        // for resized, the individual cells take care of this, so don't need to refresh everything
	        this.eventService.addEventListener(events_1.Events.EVENT_COLUMN_RESIZED, this.setPinnedColContainerWidth.bind(this));
	        this.eventService.addEventListener(events_1.Events.EVENT_DISPLAYED_COLUMNS_CHANGED, this.setPinnedColContainerWidth.bind(this));
	        if (this.columnController.isReady()) {
	            this.refreshHeader();
	        }
	    };
	    HeaderRenderer.prototype.forEachHeaderElement = function (callback) {
	        this.childContainers.forEach(function (childContainer) { return childContainer.forEachHeaderElement(callback); });
	    };
	    HeaderRenderer.prototype.destroy = function () {
	        this.childContainers.forEach(function (container) { return container.destroy(); });
	    };
	    HeaderRenderer.prototype.onGridColumnsChanged = function () {
	        this.setHeight();
	    };
	    // this is called from the API and refreshes everything, should be broken out
	    // into refresh everything vs just something changed
	    HeaderRenderer.prototype.refreshHeader = function () {
	        this.setHeight();
	        this.childContainers.forEach(function (container) { return container.refresh(); });
	        this.setPinnedColContainerWidth();
	    };
	    HeaderRenderer.prototype.setHeight = function () {
	        // if forPrint, overlay is missing
	        if (this.eHeaderOverlay) {
	            var rowHeight = this.gridOptionsWrapper.getHeaderHeight();
	            // we can probably get rid of this when we no longer need the overlay
	            var dept = this.columnController.getHeaderRowCount();
	            this.eHeaderOverlay.style.height = rowHeight + 'px';
	            this.eHeaderOverlay.style.top = ((dept - 1) * rowHeight) + 'px';
	        }
	    };
	    HeaderRenderer.prototype.setPinnedColContainerWidth = function () {
	        // pinned col doesn't exist when doing forPrint
	        if (this.gridOptionsWrapper.isForPrint()) {
	            return;
	        }
	        var pinnedLeftWidth = this.columnController.getPinnedLeftContainerWidth();
	        this.eHeaderViewport.style.marginLeft = pinnedLeftWidth + 'px';
	        this.pinnedLeftContainer.setWidth(pinnedLeftWidth);
	        var pinnedRightWidth = this.columnController.getPinnedRightContainerWidth();
	        this.eHeaderViewport.style.marginRight = pinnedRightWidth + 'px';
	        this.pinnedRightContainer.setWidth(pinnedRightWidth);
	    };
	    __decorate([
	        context_1.Autowired('gridOptionsWrapper'), 
	        __metadata('design:type', gridOptionsWrapper_1.GridOptionsWrapper)
	    ], HeaderRenderer.prototype, "gridOptionsWrapper", void 0);
	    __decorate([
	        context_1.Autowired('columnController'), 
	        __metadata('design:type', columnController_1.ColumnController)
	    ], HeaderRenderer.prototype, "columnController", void 0);
	    __decorate([
	        context_1.Autowired('gridPanel'), 
	        __metadata('design:type', gridPanel_1.GridPanel)
	    ], HeaderRenderer.prototype, "gridPanel", void 0);
	    __decorate([
	        context_1.Autowired('context'), 
	        __metadata('design:type', context_1.Context)
	    ], HeaderRenderer.prototype, "context", void 0);
	    __decorate([
	        context_1.Autowired('eventService'), 
	        __metadata('design:type', eventService_1.EventService)
	    ], HeaderRenderer.prototype, "eventService", void 0);
	    __decorate([
	        context_1.PostConstruct, 
	        __metadata('design:type', Function), 
	        __metadata('design:paramtypes', []), 
	        __metadata('design:returntype', void 0)
	    ], HeaderRenderer.prototype, "init", null);
	    __decorate([
	        context_1.PreDestroy, 
	        __metadata('design:type', Function), 
	        __metadata('design:paramtypes', []), 
	        __metadata('design:returntype', void 0)
	    ], HeaderRenderer.prototype, "destroy", null);
	    HeaderRenderer = __decorate([
	        context_1.Bean('headerRenderer'), 
	        __metadata('design:paramtypes', [])
	    ], HeaderRenderer);
	    return HeaderRenderer;
	})();
	exports.HeaderRenderer = HeaderRenderer;


/***/ },
/* 67 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
	 * @version v7.0.2
	 * @link http://www.ag-grid.com/
	 * @license MIT
	 */
	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var utils_1 = __webpack_require__(7);
	var gridOptionsWrapper_1 = __webpack_require__(3);
	var context_1 = __webpack_require__(6);
	var dragAndDropService_1 = __webpack_require__(68);
	var columnController_1 = __webpack_require__(13);
	var gridPanel_1 = __webpack_require__(24);
	var eventService_1 = __webpack_require__(4);
	var events_1 = __webpack_require__(10);
	var headerRowComp_1 = __webpack_require__(69);
	var bodyDropTarget_1 = __webpack_require__(76);
	var HeaderContainer = (function () {
	    function HeaderContainer(eContainer, eViewport, eRoot, pinned) {
	        this.headerRowComps = [];
	        this.eContainer = eContainer;
	        this.eRoot = eRoot;
	        this.pinned = pinned;
	        this.eViewport = eViewport;
	    }
	    HeaderContainer.prototype.setWidth = function (width) {
	        this.eContainer.style.width = width + 'px';
	    };
	    HeaderContainer.prototype.forEachHeaderElement = function (callback) {
	        this.headerRowComps.forEach(function (headerRowComp) { return headerRowComp.forEachHeaderElement(callback); });
	    };
	    HeaderContainer.prototype.init = function () {
	        this.setupDragAndDrop();
	        // if value changes, then if not pivoting, we at least need to change the label eg from sum() to avg(),
	        // if pivoting, then the columns have changed
	        this.eventService.addEventListener(events_1.Events.EVENT_COLUMN_VALUE_CHANGED, this.onGridColumnsChanged.bind(this));
	        this.eventService.addEventListener(events_1.Events.EVENT_GRID_COLUMNS_CHANGED, this.onGridColumnsChanged.bind(this));
	    };
	    HeaderContainer.prototype.destroy = function () {
	        this.removeHeaderRowComps();
	    };
	    // grid cols have changed - this also means the number of rows in the header can have
	    // changed. so we remove all the old rows and insert new ones for a complete refresh
	    HeaderContainer.prototype.onGridColumnsChanged = function () {
	        this.removeHeaderRowComps();
	        this.createHeaderRowComps();
	    };
	    // we expose this for gridOptions.api.refreshHeader() to call
	    HeaderContainer.prototype.refresh = function () {
	        this.onGridColumnsChanged();
	    };
	    HeaderContainer.prototype.setupDragAndDrop = function () {
	        var dropContainer = this.eViewport ? this.eViewport : this.eContainer;
	        var bodyDropTarget = new bodyDropTarget_1.BodyDropTarget(this.pinned, dropContainer);
	        this.context.wireBean(bodyDropTarget);
	    };
	    HeaderContainer.prototype.removeHeaderRowComps = function () {
	        this.headerRowComps.forEach(function (headerRowComp) {
	            headerRowComp.destroy();
	        });
	        this.headerRowComps.length = 0;
	        utils_1.Utils.removeAllChildren(this.eContainer);
	    };
	    HeaderContainer.prototype.createHeaderRowComps = function () {
	        // if we are displaying header groups, then we have many rows here.
	        // go through each row of the header, one by one.
	        var rowCount = this.columnController.getHeaderRowCount();
	        for (var dept = 0; dept < rowCount; dept++) {
	            var groupRow = dept !== (rowCount - 1);
	            var headerRowComp = new headerRowComp_1.HeaderRowComp(dept, groupRow, this.pinned, this.eRoot, this.dropTarget);
	            this.context.wireBean(headerRowComp);
	            this.headerRowComps.push(headerRowComp);
	            this.eContainer.appendChild(headerRowComp.getGui());
	        }
	    };
	    __decorate([
	        context_1.Autowired('gridOptionsWrapper'), 
	        __metadata('design:type', gridOptionsWrapper_1.GridOptionsWrapper)
	    ], HeaderContainer.prototype, "gridOptionsWrapper", void 0);
	    __decorate([
	        context_1.Autowired('context'), 
	        __metadata('design:type', context_1.Context)
	    ], HeaderContainer.prototype, "context", void 0);
	    __decorate([
	        context_1.Autowired('$scope'), 
	        __metadata('design:type', Object)
	    ], HeaderContainer.prototype, "$scope", void 0);
	    __decorate([
	        context_1.Autowired('dragAndDropService'), 
	        __metadata('design:type', dragAndDropService_1.DragAndDropService)
	    ], HeaderContainer.prototype, "dragAndDropService", void 0);
	    __decorate([
	        context_1.Autowired('columnController'), 
	        __metadata('design:type', columnController_1.ColumnController)
	    ], HeaderContainer.prototype, "columnController", void 0);
	    __decorate([
	        context_1.Autowired('gridPanel'), 
	        __metadata('design:type', gridPanel_1.GridPanel)
	    ], HeaderContainer.prototype, "gridPanel", void 0);
	    __decorate([
	        context_1.Autowired('eventService'), 
	        __metadata('design:type', eventService_1.EventService)
	    ], HeaderContainer.prototype, "eventService", void 0);
	    __decorate([
	        context_1.PostConstruct, 
	        __metadata('design:type', Function), 
	        __metadata('design:paramtypes', []), 
	        __metadata('design:returntype', void 0)
	    ], HeaderContainer.prototype, "init", null);
	    return HeaderContainer;
	})();
	exports.HeaderContainer = HeaderContainer;


/***/ },
/* 68 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
	 * @version v7.0.2
	 * @link http://www.ag-grid.com/
	 * @license MIT
	 */
	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var __param = (this && this.__param) || function (paramIndex, decorator) {
	    return function (target, key) { decorator(target, key, paramIndex); }
	};
	var logger_1 = __webpack_require__(5);
	var context_1 = __webpack_require__(6);
	var utils_1 = __webpack_require__(7);
	var gridOptionsWrapper_1 = __webpack_require__(3);
	var svgFactory_1 = __webpack_require__(59);
	var dragService_1 = __webpack_require__(31);
	var columnController_1 = __webpack_require__(13);
	var svgFactory = svgFactory_1.SvgFactory.getInstance();
	(function (DragSourceType) {
	    DragSourceType[DragSourceType["ToolPanel"] = 0] = "ToolPanel";
	    DragSourceType[DragSourceType["HeaderCell"] = 1] = "HeaderCell";
	})(exports.DragSourceType || (exports.DragSourceType = {}));
	var DragSourceType = exports.DragSourceType;
	(function (VDirection) {
	    VDirection[VDirection["Up"] = 0] = "Up";
	    VDirection[VDirection["Down"] = 1] = "Down";
	})(exports.VDirection || (exports.VDirection = {}));
	var VDirection = exports.VDirection;
	(function (HDirection) {
	    HDirection[HDirection["Left"] = 0] = "Left";
	    HDirection[HDirection["Right"] = 1] = "Right";
	})(exports.HDirection || (exports.HDirection = {}));
	var HDirection = exports.HDirection;
	var DragAndDropService = (function () {
	    function DragAndDropService() {
	        this.dragSourceAndParamsList = [];
	        this.dropTargets = [];
	    }
	    DragAndDropService.prototype.init = function () {
	        this.ePinnedIcon = utils_1.Utils.createIcon('columnMovePin', this.gridOptionsWrapper, null, svgFactory.createPinIcon);
	        this.ePlusIcon = utils_1.Utils.createIcon('columnMoveAdd', this.gridOptionsWrapper, null, svgFactory.createPlusIcon);
	        this.eHiddenIcon = utils_1.Utils.createIcon('columnMoveHide', this.gridOptionsWrapper, null, svgFactory.createColumnHiddenIcon);
	        this.eMoveIcon = utils_1.Utils.createIcon('columnMoveMove', this.gridOptionsWrapper, null, svgFactory.createMoveIcon);
	        this.eLeftIcon = utils_1.Utils.createIcon('columnMoveLeft', this.gridOptionsWrapper, null, svgFactory.createLeftIcon);
	        this.eRightIcon = utils_1.Utils.createIcon('columnMoveRight', this.gridOptionsWrapper, null, svgFactory.createRightIcon);
	        this.eGroupIcon = utils_1.Utils.createIcon('columnMoveGroup', this.gridOptionsWrapper, null, svgFactory.createGroupIcon);
	        this.eAggregateIcon = utils_1.Utils.createIcon('columnMoveValue', this.gridOptionsWrapper, null, svgFactory.createAggregationIcon);
	        this.ePivotIcon = utils_1.Utils.createIcon('columnMovePivot', this.gridOptionsWrapper, null, svgFactory.createPivotIcon);
	        this.eDropNotAllowedIcon = utils_1.Utils.createIcon('dropNotAllowed', this.gridOptionsWrapper, null, svgFactory.createDropNotAllowedIcon);
	    };
	    DragAndDropService.prototype.setBeans = function (loggerFactory) {
	        this.logger = loggerFactory.create('OldToolPanelDragAndDropService');
	        this.eBody = document.querySelector('body');
	        if (!this.eBody) {
	            console.warn('ag-Grid: could not find document body, it is needed for dragging columns');
	        }
	    };
	    DragAndDropService.prototype.addDragSource = function (dragSource, allowTouch) {
	        if (allowTouch === void 0) { allowTouch = false; }
	        var params = {
	            eElement: dragSource.eElement,
	            onDragStart: this.onDragStart.bind(this, dragSource),
	            onDragStop: this.onDragStop.bind(this),
	            onDragging: this.onDragging.bind(this)
	        };
	        this.dragSourceAndParamsList.push({ params: params, dragSource: dragSource });
	        this.dragService.addDragSource(params, allowTouch);
	    };
	    DragAndDropService.prototype.removeDragSource = function (dragSource) {
	        var sourceAndParams = utils_1.Utils.find(this.dragSourceAndParamsList, function (item) { return item.dragSource === dragSource; });
	        if (sourceAndParams) {
	            this.dragService.removeDragSource(sourceAndParams.params);
	            utils_1.Utils.removeFromArray(this.dragSourceAndParamsList, sourceAndParams);
	        }
	    };
	    DragAndDropService.prototype.destroy = function () {
	        var _this = this;
	        this.dragSourceAndParamsList.forEach(function (sourceAndParams) {
	            _this.dragService.removeDragSource(sourceAndParams.params);
	        });
	        this.dragSourceAndParamsList.length = 0;
	    };
	    DragAndDropService.prototype.nudge = function () {
	        if (this.dragging) {
	            this.onDragging(this.eventLastTime, true);
	        }
	    };
	    DragAndDropService.prototype.onDragStart = function (dragSource, mouseEvent) {
	        this.dragging = true;
	        this.dragSource = dragSource;
	        this.eventLastTime = mouseEvent;
	        this.dragSource.dragItem.forEach(function (column) { return column.setMoving(true); });
	        this.dragItem = this.dragSource.dragItem;
	        this.lastDropTarget = this.dragSource.dragSourceDropTarget;
	        this.createGhost();
	    };
	    DragAndDropService.prototype.onDragStop = function (mouseEvent) {
	        this.eventLastTime = null;
	        this.dragging = false;
	        this.dragItem.forEach(function (column) { return column.setMoving(false); });
	        if (this.lastDropTarget && this.lastDropTarget.onDragStop) {
	            var draggingEvent = this.createDropTargetEvent(this.lastDropTarget, mouseEvent, null, null, false);
	            this.lastDropTarget.onDragStop(draggingEvent);
	        }
	        this.lastDropTarget = null;
	        this.dragItem = null;
	        this.removeGhost();
	    };
	    DragAndDropService.prototype.onDragging = function (mouseEvent, fromNudge) {
	        var hDirection = this.workOutHDirection(mouseEvent);
	        var vDirection = this.workOutVDirection(mouseEvent);
	        this.eventLastTime = mouseEvent;
	        this.positionGhost(mouseEvent);
	        // check if mouseEvent intersects with any of the drop targets
	        var dropTarget = utils_1.Utils.find(this.dropTargets, this.isMouseOnDropTarget.bind(this, mouseEvent));
	        if (dropTarget !== this.lastDropTarget) {
	            this.leaveLastTargetIfExists(mouseEvent, hDirection, vDirection, fromNudge);
	            this.enterDragTargetIfExists(dropTarget, mouseEvent, hDirection, vDirection, fromNudge);
	            this.lastDropTarget = dropTarget;
	        }
	        else if (dropTarget) {
	            var draggingEvent = this.createDropTargetEvent(dropTarget, mouseEvent, hDirection, vDirection, fromNudge);
	            dropTarget.onDragging(draggingEvent);
	        }
	    };
	    DragAndDropService.prototype.enterDragTargetIfExists = function (dropTarget, mouseEvent, hDirection, vDirection, fromNudge) {
	        if (!dropTarget) {
	            return;
	        }
	        var dragEnterEvent = this.createDropTargetEvent(dropTarget, mouseEvent, hDirection, vDirection, fromNudge);
	        dropTarget.onDragEnter(dragEnterEvent);
	        this.setGhostIcon(dropTarget.getIconName ? dropTarget.getIconName() : null);
	    };
	    DragAndDropService.prototype.leaveLastTargetIfExists = function (mouseEvent, hDirection, vDirection, fromNudge) {
	        if (!this.lastDropTarget) {
	            return;
	        }
	        var dragLeaveEvent = this.createDropTargetEvent(this.lastDropTarget, mouseEvent, hDirection, vDirection, fromNudge);
	        this.lastDropTarget.onDragLeave(dragLeaveEvent);
	        this.setGhostIcon(null);
	    };
	    DragAndDropService.prototype.getAllContainersFromDropTarget = function (dropTarget) {
	        var containers = [dropTarget.getContainer()];
	        var secondaryContainers = dropTarget.getSecondaryContainers ? dropTarget.getSecondaryContainers() : null;
	        if (secondaryContainers) {
	            containers = containers.concat(secondaryContainers);
	        }
	        return containers;
	    };
	    // checks if the mouse is on the drop target. it checks eContainer and eSecondaryContainers
	    DragAndDropService.prototype.isMouseOnDropTarget = function (mouseEvent, dropTarget) {
	        var allContainers = this.getAllContainersFromDropTarget(dropTarget);
	        var gotMatch = false;
	        allContainers.forEach(function (eContainer) {
	            if (!eContainer) {
	                return;
	            } // secondary can be missing
	            var rect = eContainer.getBoundingClientRect();
	            // if element is not visible, then width and height are zero
	            if (rect.width === 0 || rect.height === 0) {
	                return;
	            }
	            var horizontalFit = mouseEvent.clientX >= rect.left && mouseEvent.clientX <= rect.right;
	            var verticalFit = mouseEvent.clientY >= rect.top && mouseEvent.clientY <= rect.bottom;
	            //console.log(`rect.width = ${rect.width} || rect.height = ${rect.height} ## verticalFit = ${verticalFit}, horizontalFit = ${horizontalFit}, `);
	            if (horizontalFit && verticalFit) {
	                gotMatch = true;
	            }
	        });
	        return gotMatch;
	    };
	    DragAndDropService.prototype.addDropTarget = function (dropTarget) {
	        this.dropTargets.push(dropTarget);
	    };
	    DragAndDropService.prototype.workOutHDirection = function (event) {
	        if (this.eventLastTime.clientX > event.clientX) {
	            return HDirection.Left;
	        }
	        else if (this.eventLastTime.clientX < event.clientX) {
	            return HDirection.Right;
	        }
	        else {
	            return null;
	        }
	    };
	    DragAndDropService.prototype.workOutVDirection = function (event) {
	        if (this.eventLastTime.clientY > event.clientY) {
	            return VDirection.Up;
	        }
	        else if (this.eventLastTime.clientY < event.clientY) {
	            return VDirection.Down;
	        }
	        else {
	            return null;
	        }
	    };
	    DragAndDropService.prototype.createDropTargetEvent = function (dropTarget, event, hDirection, vDirection, fromNudge) {
	        // localise x and y to the target component
	        var rect = dropTarget.getContainer().getBoundingClientRect();
	        var x = event.clientX - rect.left;
	        var y = event.clientY - rect.top;
	        var dropTargetEvent = {
	            event: event,
	            x: x,
	            y: y,
	            vDirection: vDirection,
	            hDirection: hDirection,
	            dragSource: this.dragSource,
	            fromNudge: fromNudge
	        };
	        return dropTargetEvent;
	    };
	    DragAndDropService.prototype.positionGhost = function (event) {
	        var ghostRect = this.eGhost.getBoundingClientRect();
	        var ghostHeight = ghostRect.height;
	        // for some reason, without the '-2', it still overlapped by 1 or 2 pixels, which
	        // then brought in scrollbars to the browser. no idea why, but putting in -2 here
	        // works around it which is good enough for me.
	        var browserWidth = utils_1.Utils.getBodyWidth() - 2;
	        var browserHeight = utils_1.Utils.getBodyHeight() - 2;
	        // put ghost vertically in middle of cursor
	        var top = event.pageY - (ghostHeight / 2);
	        // horizontally, place cursor just right of icon
	        var left = event.pageX - 30;
	        var windowScrollY = window.pageYOffset || document.documentElement.scrollTop;
	        var windowScrollX = window.pageXOffset || document.documentElement.scrollLeft;
	        // check ghost is not positioned outside of the browser
	        if (browserWidth > 0) {
	            if ((left + this.eGhost.clientWidth) > (browserWidth + windowScrollX)) {
	                left = browserWidth + windowScrollX - this.eGhost.clientWidth;
	            }
	        }
	        if (left < 0) {
	            left = 0;
	        }
	        if (browserHeight > 0) {
	            if ((top + this.eGhost.clientHeight) > (browserHeight + windowScrollY)) {
	                top = browserHeight + windowScrollY - this.eGhost.clientHeight;
	            }
	        }
	        if (top < 0) {
	            top = 0;
	        }
	        this.eGhost.style.left = left + 'px';
	        this.eGhost.style.top = top + 'px';
	    };
	    DragAndDropService.prototype.removeGhost = function () {
	        if (this.eGhost) {
	            this.eBody.removeChild(this.eGhost);
	        }
	        this.eGhost = null;
	    };
	    DragAndDropService.prototype.createGhost = function () {
	        this.eGhost = utils_1.Utils.loadTemplate(DragAndDropService.GHOST_TEMPLATE);
	        this.eGhostIcon = this.eGhost.querySelector('.ag-dnd-ghost-icon');
	        this.setGhostIcon(null);
	        var eText = this.eGhost.querySelector('.ag-dnd-ghost-label');
	        eText.innerHTML = this.dragSource.dragItemName;
	        this.eGhost.style.height = this.gridOptionsWrapper.getHeaderHeight() + 'px';
	        this.eGhost.style.top = '20px';
	        this.eGhost.style.left = '20px';
	        this.eBody.appendChild(this.eGhost);
	    };
	    DragAndDropService.prototype.setGhostIcon = function (iconName, shake) {
	        if (shake === void 0) { shake = false; }
	        utils_1.Utils.removeAllChildren(this.eGhostIcon);
	        var eIcon;
	        switch (iconName) {
	            case DragAndDropService.ICON_ADD:
	                eIcon = this.ePlusIcon;
	                break;
	            case DragAndDropService.ICON_PINNED:
	                eIcon = this.ePinnedIcon;
	                break;
	            case DragAndDropService.ICON_MOVE:
	                eIcon = this.eMoveIcon;
	                break;
	            case DragAndDropService.ICON_LEFT:
	                eIcon = this.eLeftIcon;
	                break;
	            case DragAndDropService.ICON_RIGHT:
	                eIcon = this.eRightIcon;
	                break;
	            case DragAndDropService.ICON_GROUP:
	                eIcon = this.eGroupIcon;
	                break;
	            case DragAndDropService.ICON_AGGREGATE:
	                eIcon = this.eAggregateIcon;
	                break;
	            case DragAndDropService.ICON_PIVOT:
	                eIcon = this.ePivotIcon;
	                break;
	            case DragAndDropService.ICON_NOT_ALLOWED:
	                eIcon = this.eDropNotAllowedIcon;
	                break;
	            default:
	                eIcon = this.eHiddenIcon;
	                break;
	        }
	        this.eGhostIcon.appendChild(eIcon);
	        utils_1.Utils.addOrRemoveCssClass(this.eGhostIcon, 'ag-shake-left-to-right', shake);
	    };
	    DragAndDropService.ICON_PINNED = 'pinned';
	    DragAndDropService.ICON_ADD = 'add';
	    DragAndDropService.ICON_MOVE = 'move';
	    DragAndDropService.ICON_LEFT = 'left';
	    DragAndDropService.ICON_RIGHT = 'right';
	    DragAndDropService.ICON_GROUP = 'group';
	    DragAndDropService.ICON_AGGREGATE = 'aggregate';
	    DragAndDropService.ICON_PIVOT = 'pivot';
	    DragAndDropService.ICON_NOT_ALLOWED = 'notAllowed';
	    DragAndDropService.GHOST_TEMPLATE = '<div class="ag-dnd-ghost">' +
	        '  <span class="ag-dnd-ghost-icon ag-shake-left-to-right"></span>' +
	        '  <div class="ag-dnd-ghost-label">' +
	        '  </div>' +
	        '</div>';
	    __decorate([
	        context_1.Autowired('gridOptionsWrapper'), 
	        __metadata('design:type', gridOptionsWrapper_1.GridOptionsWrapper)
	    ], DragAndDropService.prototype, "gridOptionsWrapper", void 0);
	    __decorate([
	        context_1.Autowired('dragService'), 
	        __metadata('design:type', dragService_1.DragService)
	    ], DragAndDropService.prototype, "dragService", void 0);
	    __decorate([
	        context_1.Autowired('columnController'), 
	        __metadata('design:type', columnController_1.ColumnController)
	    ], DragAndDropService.prototype, "columnController", void 0);
	    __decorate([
	        context_1.PostConstruct, 
	        __metadata('design:type', Function), 
	        __metadata('design:paramtypes', []), 
	        __metadata('design:returntype', void 0)
	    ], DragAndDropService.prototype, "init", null);
	    __decorate([
	        __param(0, context_1.Qualifier('loggerFactory')), 
	        __metadata('design:type', Function), 
	        __metadata('design:paramtypes', [logger_1.LoggerFactory]), 
	        __metadata('design:returntype', void 0)
	    ], DragAndDropService.prototype, "setBeans", null);
	    __decorate([
	        context_1.PreDestroy, 
	        __metadata('design:type', Function), 
	        __metadata('design:paramtypes', []), 
	        __metadata('design:returntype', void 0)
	    ], DragAndDropService.prototype, "destroy", null);
	    DragAndDropService = __decorate([
	        context_1.Bean('dragAndDropService'), 
	        __metadata('design:paramtypes', [])
	    ], DragAndDropService);
	    return DragAndDropService;
	})();
	exports.DragAndDropService = DragAndDropService;


/***/ },
/* 69 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
	 * @version v7.0.2
	 * @link http://www.ag-grid.com/
	 * @license MIT
	 */
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var component_1 = __webpack_require__(47);
	var context_1 = __webpack_require__(6);
	var gridOptionsWrapper_1 = __webpack_require__(3);
	var columnGroup_1 = __webpack_require__(14);
	var columnController_1 = __webpack_require__(13);
	var renderedHeaderGroupCell_1 = __webpack_require__(70);
	var renderedHeaderCell_1 = __webpack_require__(74);
	var eventService_1 = __webpack_require__(4);
	var events_1 = __webpack_require__(10);
	var utils_1 = __webpack_require__(7);
	var HeaderRowComp = (function (_super) {
	    __extends(HeaderRowComp, _super);
	    function HeaderRowComp(dept, showingGroups, pinned, eRoot, dropTarget) {
	        _super.call(this, "<div class=\"ag-header-row\"/>");
	        this.headerElements = {};
	        this.dept = dept;
	        this.showingGroups = showingGroups;
	        this.pinned = pinned;
	        this.eRoot = eRoot;
	        this.dropTarget = dropTarget;
	    }
	    HeaderRowComp.prototype.forEachHeaderElement = function (callback) {
	        var _this = this;
	        Object.keys(this.headerElements).forEach(function (key) {
	            var headerElement = _this.headerElements[key];
	            callback(headerElement);
	        });
	    };
	    HeaderRowComp.prototype.destroy = function () {
	        var idsOfAllChildren = Object.keys(this.headerElements);
	        this.removeAndDestroyChildComponents(idsOfAllChildren);
	        _super.prototype.destroy.call(this);
	    };
	    HeaderRowComp.prototype.removeAndDestroyChildComponents = function (idsToDestroy) {
	        var _this = this;
	        idsToDestroy.forEach(function (id) {
	            var child = _this.headerElements[id];
	            _this.getGui().removeChild(child.getGui());
	            child.destroy();
	            delete _this.headerElements[id];
	        });
	    };
	    HeaderRowComp.prototype.onRowHeightChanged = function () {
	        var rowHeight = this.gridOptionsWrapper.getHeaderHeight();
	        this.getGui().style.top = (this.dept * rowHeight) + 'px';
	        this.getGui().style.height = rowHeight + 'px';
	    };
	    HeaderRowComp.prototype.init = function () {
	        this.onRowHeightChanged();
	        this.onVirtualColumnsChanged();
	        this.addDestroyableEventListener(this.gridOptionsWrapper, gridOptionsWrapper_1.GridOptionsWrapper.PROP_HEADER_HEIGHT, this.onRowHeightChanged.bind(this));
	        this.addDestroyableEventListener(this.eventService, events_1.Events.EVENT_VIRTUAL_COLUMNS_CHANGED, this.onVirtualColumnsChanged.bind(this));
	        this.addDestroyableEventListener(this.eventService, events_1.Events.EVENT_DISPLAYED_COLUMNS_CHANGED, this.onDisplayedColumnsChanged.bind(this));
	    };
	    HeaderRowComp.prototype.onDisplayedColumnsChanged = function () {
	        // because column groups are created and destroyed on the fly as groups are opened / closed and columns are moved,
	        // we have to throw away all of the components when columns are changed, as the references to the old groups
	        // are no longer value. this is not true for columns where columns do not get destroyed between open / close
	        // or moving actions.
	        if (this.showingGroups) {
	            var idsOfAllChildren = Object.keys(this.headerElements);
	            this.removeAndDestroyChildComponents(idsOfAllChildren);
	        }
	        this.onVirtualColumnsChanged();
	    };
	    HeaderRowComp.prototype.onVirtualColumnsChanged = function () {
	        var _this = this;
	        var currentChildIds = Object.keys(this.headerElements);
	        var nodesAtDept = this.columnController.getVirtualHeaderGroupRow(this.pinned, this.dept);
	        nodesAtDept.forEach(function (child) {
	            var idOfChild = child.getUniqueId();
	            // if we already have this cell rendered, do nothing
	            if (currentChildIds.indexOf(idOfChild) >= 0) {
	                utils_1.Utils.removeFromArray(currentChildIds, idOfChild);
	                return;
	            }
	            // skip groups that have no displayed children. this can happen when the group is broken,
	            // and this section happens to have nothing to display for the open / closed state
	            if (child instanceof columnGroup_1.ColumnGroup && child.getDisplayedChildren().length === 0) {
	                return;
	            }
	            var renderedHeaderElement = _this.createHeaderElement(child);
	            _this.headerElements[idOfChild] = renderedHeaderElement;
	            _this.getGui().appendChild(renderedHeaderElement.getGui());
	        });
	        // at this point, anything left in currentChildIds is an element that is no longer in the viewport
	        this.removeAndDestroyChildComponents(currentChildIds);
	    };
	    HeaderRowComp.prototype.createHeaderElement = function (columnGroupChild) {
	        var result;
	        if (columnGroupChild instanceof columnGroup_1.ColumnGroup) {
	            result = new renderedHeaderGroupCell_1.RenderedHeaderGroupCell(columnGroupChild, this.eRoot, this.dropTarget);
	        }
	        else {
	            result = new renderedHeaderCell_1.RenderedHeaderCell(columnGroupChild, this.eRoot, this.dropTarget);
	        }
	        this.context.wireBean(result);
	        return result;
	    };
	    __decorate([
	        context_1.Autowired('gridOptionsWrapper'), 
	        __metadata('design:type', gridOptionsWrapper_1.GridOptionsWrapper)
	    ], HeaderRowComp.prototype, "gridOptionsWrapper", void 0);
	    __decorate([
	        context_1.Autowired('columnController'), 
	        __metadata('design:type', columnController_1.ColumnController)
	    ], HeaderRowComp.prototype, "columnController", void 0);
	    __decorate([
	        context_1.Autowired('context'), 
	        __metadata('design:type', context_1.Context)
	    ], HeaderRowComp.prototype, "context", void 0);
	    __decorate([
	        context_1.Autowired('eventService'), 
	        __metadata('design:type', eventService_1.EventService)
	    ], HeaderRowComp.prototype, "eventService", void 0);
	    __decorate([
	        context_1.PostConstruct, 
	        __metadata('design:type', Function), 
	        __metadata('design:paramtypes', []), 
	        __metadata('design:returntype', void 0)
	    ], HeaderRowComp.prototype, "init", null);
	    return HeaderRowComp;
	})(component_1.Component);
	exports.HeaderRowComp = HeaderRowComp;


/***/ },
/* 70 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
	 * @version v7.0.2
	 * @link http://www.ag-grid.com/
	 * @license MIT
	 */
	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var utils_1 = __webpack_require__(7);
	var svgFactory_1 = __webpack_require__(59);
	var columnController_1 = __webpack_require__(13);
	var filterManager_1 = __webpack_require__(43);
	var gridOptionsWrapper_1 = __webpack_require__(3);
	var column_1 = __webpack_require__(15);
	var horizontalDragService_1 = __webpack_require__(71);
	var context_1 = __webpack_require__(6);
	var cssClassApplier_1 = __webpack_require__(72);
	var dragAndDropService_1 = __webpack_require__(68);
	var setLeftFeature_1 = __webpack_require__(63);
	var touchListener_1 = __webpack_require__(73);
	var svgFactory = svgFactory_1.SvgFactory.getInstance();
	var RenderedHeaderGroupCell = (function () {
	    function RenderedHeaderGroupCell(columnGroup, eRoot, dragSourceDropTarget) {
	        this.destroyFunctions = [];
	        this.columnGroup = columnGroup;
	        this.eRoot = eRoot;
	        this.dragSourceDropTarget = dragSourceDropTarget;
	    }
	    RenderedHeaderGroupCell.prototype.getGui = function () {
	        return this.eHeaderGroupCell;
	    };
	    RenderedHeaderGroupCell.prototype.onIndividualColumnResized = function (column) {
	        if (this.columnGroup.isChildInThisGroupDeepSearch(column)) {
	            this.setWidth();
	        }
	    };
	    RenderedHeaderGroupCell.prototype.init = function () {
	        this.eHeaderGroupCell = document.createElement('div');
	        cssClassApplier_1.CssClassApplier.addHeaderClassesFromColDef(this.columnGroup.getColGroupDef(), this.eHeaderGroupCell, this.gridOptionsWrapper, null, this.columnGroup);
	        // this.displayName = this.columnGroup.getHeaderName();
	        this.displayName = this.columnController.getDisplayNameForColumnGroup(this.columnGroup, 'header');
	        this.setupResize();
	        this.addClasses();
	        this.setupLabel();
	        this.setupMove();
	        this.setWidth();
	        var setLeftFeature = new setLeftFeature_1.SetLeftFeature(this.columnGroup, this.eHeaderGroupCell);
	        this.destroyFunctions.push(setLeftFeature.destroy.bind(setLeftFeature));
	    };
	    RenderedHeaderGroupCell.prototype.setupLabel = function () {
	        // no renderer, default text render
	        if (this.displayName && this.displayName !== '') {
	            var eGroupCellLabel = document.createElement("div");
	            eGroupCellLabel.className = 'ag-header-group-cell-label';
	            this.eHeaderGroupCell.appendChild(eGroupCellLabel);
	            if (utils_1.Utils.isBrowserSafari()) {
	                eGroupCellLabel.style.display = 'table-cell';
	            }
	            var eInnerText = document.createElement("span");
	            eInnerText.className = 'ag-header-group-text';
	            eInnerText.innerHTML = this.displayName;
	            eGroupCellLabel.appendChild(eInnerText);
	            if (this.columnGroup.isExpandable()) {
	                this.addGroupExpandIcon(eGroupCellLabel);
	            }
	        }
	    };
	    RenderedHeaderGroupCell.prototype.addClasses = function () {
	        utils_1.Utils.addCssClass(this.eHeaderGroupCell, 'ag-header-group-cell');
	        // having different classes below allows the style to not have a bottom border
	        // on the group header, if no group is specified
	        // columnGroup.getColGroupDef
	        if (this.columnGroup.isPadding()) {
	            utils_1.Utils.addCssClass(this.eHeaderGroupCell, 'ag-header-group-cell-no-group');
	        }
	        else {
	            utils_1.Utils.addCssClass(this.eHeaderGroupCell, 'ag-header-group-cell-with-group');
	        }
	    };
	    RenderedHeaderGroupCell.prototype.setupResize = function () {
	        var _this = this;
	        if (!this.gridOptionsWrapper.isEnableColResize()) {
	            return;
	        }
	        this.eHeaderCellResize = document.createElement("div");
	        this.eHeaderCellResize.className = "ag-header-cell-resize";
	        this.eHeaderGroupCell.appendChild(this.eHeaderCellResize);
	        this.dragService.addDragHandling({
	            eDraggableElement: this.eHeaderCellResize,
	            eBody: this.eRoot,
	            cursor: 'col-resize',
	            startAfterPixels: 0,
	            onDragStart: this.onDragStart.bind(this),
	            onDragging: this.onDragging.bind(this)
	        });
	        if (!this.gridOptionsWrapper.isSuppressAutoSize()) {
	            this.eHeaderCellResize.addEventListener('dblclick', function (event) {
	                // get list of all the column keys we are responsible for
	                var keys = [];
	                _this.columnGroup.getDisplayedLeafColumns().forEach(function (column) {
	                    // not all cols in the group may be participating with auto-resize
	                    if (!column.getColDef().suppressAutoSize) {
	                        keys.push(column.getColId());
	                    }
	                });
	                if (keys.length > 0) {
	                    _this.columnController.autoSizeColumns(keys);
	                }
	            });
	        }
	    };
	    RenderedHeaderGroupCell.prototype.isSuppressMoving = function () {
	        // if any child is fixed, then don't allow moving
	        var childSuppressesMoving = false;
	        this.columnGroup.getLeafColumns().forEach(function (column) {
	            if (column.getColDef().suppressMovable) {
	                childSuppressesMoving = true;
	            }
	        });
	        var result = childSuppressesMoving
	            || this.gridOptionsWrapper.isSuppressMovableColumns()
	            || this.gridOptionsWrapper.isForPrint();
	        // || this.columnController.isPivotMode();
	        return result;
	    };
	    RenderedHeaderGroupCell.prototype.setupMove = function () {
	        var _this = this;
	        var eLabel = this.eHeaderGroupCell.querySelector('.ag-header-group-cell-label');
	        if (!eLabel) {
	            return;
	        }
	        if (this.isSuppressMoving()) {
	            return;
	        }
	        if (eLabel) {
	            var dragSource = {
	                type: dragAndDropService_1.DragSourceType.HeaderCell,
	                eElement: eLabel,
	                dragItemName: this.displayName,
	                // we add in the original group leaf columns, so we move both visible and non-visible items
	                dragItem: this.getAllColumnsInThisGroup(),
	                dragSourceDropTarget: this.dragSourceDropTarget
	            };
	            this.dragAndDropService.addDragSource(dragSource, true);
	            this.destroyFunctions.push(function () { return _this.dragAndDropService.removeDragSource(dragSource); });
	        }
	    };
	    // when moving the columns, we want to move all the columns in this group in one go, and in the order they
	    // are currently in the screen.
	    RenderedHeaderGroupCell.prototype.getAllColumnsInThisGroup = function () {
	        var allColumnsOriginalOrder = this.columnGroup.getOriginalColumnGroup().getLeafColumns();
	        var allColumnsCurrentOrder = [];
	        this.columnController.getAllDisplayedColumns().forEach(function (column) {
	            if (allColumnsOriginalOrder.indexOf(column) >= 0) {
	                allColumnsCurrentOrder.push(column);
	                utils_1.Utils.removeFromArray(allColumnsOriginalOrder, column);
	            }
	        });
	        // we are left with non-visible columns, stick these in at the end
	        allColumnsOriginalOrder.forEach(function (column) { return allColumnsCurrentOrder.push(column); });
	        return allColumnsCurrentOrder;
	    };
	    RenderedHeaderGroupCell.prototype.setWidth = function () {
	        var _this = this;
	        var widthChangedListener = function () {
	            _this.eHeaderGroupCell.style.width = _this.columnGroup.getActualWidth() + 'px';
	        };
	        this.columnGroup.getLeafColumns().forEach(function (column) {
	            column.addEventListener(column_1.Column.EVENT_WIDTH_CHANGED, widthChangedListener);
	            _this.destroyFunctions.push(function () {
	                column.removeEventListener(column_1.Column.EVENT_WIDTH_CHANGED, widthChangedListener);
	            });
	        });
	        widthChangedListener();
	    };
	    RenderedHeaderGroupCell.prototype.destroy = function () {
	        this.destroyFunctions.forEach(function (func) {
	            func();
	        });
	    };
	    RenderedHeaderGroupCell.prototype.addGroupExpandIcon = function (eGroupCellLabel) {
	        var _this = this;
	        var eGroupIcon;
	        if (this.columnGroup.isExpanded()) {
	            eGroupIcon = utils_1.Utils.createIcon('columnGroupOpened', this.gridOptionsWrapper, null, svgFactory.createGroupContractedIcon);
	            utils_1.Utils.addCssClass(eGroupIcon, 'ag-header-expand-icon-expanded');
	        }
	        else {
	            eGroupIcon = utils_1.Utils.createIcon('columnGroupClosed', this.gridOptionsWrapper, null, svgFactory.createGroupExpandedIcon);
	            utils_1.Utils.addCssClass(eGroupIcon, 'ag-header-expand-icon-collapsed');
	        }
	        utils_1.Utils.addCssClass(eGroupIcon, 'ag-header-expand-icon');
	        eGroupCellLabel.appendChild(eGroupIcon);
	        var expandAction = function () {
	            var newExpandedValue = !_this.columnGroup.isExpanded();
	            _this.columnController.setColumnGroupOpened(_this.columnGroup, newExpandedValue);
	        };
	        eGroupIcon.addEventListener('click', expandAction);
	        this.destroyFunctions.push(function () {
	            eGroupIcon.removeEventListener('click', expandAction);
	        });
	        var touchListener = new touchListener_1.TouchListener(eGroupIcon);
	        touchListener.addEventListener(touchListener_1.TouchListener.EVENT_TAP, expandAction);
	        this.destroyFunctions.push(function () {
	            touchListener.removeEventListener(touchListener_1.TouchListener.EVENT_TAP, expandAction);
	            touchListener.destroy();
	        });
	    };
	    RenderedHeaderGroupCell.prototype.onDragStart = function () {
	        var _this = this;
	        this.groupWidthStart = this.columnGroup.getActualWidth();
	        this.childrenWidthStarts = [];
	        this.columnGroup.getDisplayedLeafColumns().forEach(function (column) {
	            _this.childrenWidthStarts.push(column.getActualWidth());
	        });
	    };
	    RenderedHeaderGroupCell.prototype.onDragging = function (dragChange, finished) {
	        var _this = this;
	        var newWidth = this.groupWidthStart + dragChange;
	        var minWidth = this.columnGroup.getMinWidth();
	        if (newWidth < minWidth) {
	            newWidth = minWidth;
	        }
	        // distribute the new width to the child headers
	        var changeRatio = newWidth / this.groupWidthStart;
	        // keep track of pixels used, and last column gets the remaining,
	        // to cater for rounding errors, and min width adjustments
	        var pixelsToDistribute = newWidth;
	        var displayedColumns = this.columnGroup.getDisplayedLeafColumns();
	        displayedColumns.forEach(function (column, index) {
	            var notLastCol = index !== (displayedColumns.length - 1);
	            var newChildSize;
	            if (notLastCol) {
	                // if not the last col, calculate the column width as normal
	                var startChildSize = _this.childrenWidthStarts[index];
	                newChildSize = startChildSize * changeRatio;
	                if (newChildSize < column.getMinWidth()) {
	                    newChildSize = column.getMinWidth();
	                }
	                pixelsToDistribute -= newChildSize;
	            }
	            else {
	                // if last col, give it the remaining pixels
	                newChildSize = pixelsToDistribute;
	            }
	            _this.columnController.setColumnWidth(column, newChildSize, finished);
	        });
	    };
	    __decorate([
	        context_1.Autowired('filterManager'), 
	        __metadata('design:type', filterManager_1.FilterManager)
	    ], RenderedHeaderGroupCell.prototype, "filterManager", void 0);
	    __decorate([
	        context_1.Autowired('gridOptionsWrapper'), 
	        __metadata('design:type', gridOptionsWrapper_1.GridOptionsWrapper)
	    ], RenderedHeaderGroupCell.prototype, "gridOptionsWrapper", void 0);
	    __decorate([
	        context_1.Autowired('horizontalDragService'), 
	        __metadata('design:type', horizontalDragService_1.HorizontalDragService)
	    ], RenderedHeaderGroupCell.prototype, "dragService", void 0);
	    __decorate([
	        context_1.Autowired('columnController'), 
	        __metadata('design:type', columnController_1.ColumnController)
	    ], RenderedHeaderGroupCell.prototype, "columnController", void 0);
	    __decorate([
	        context_1.Autowired('dragAndDropService'), 
	        __metadata('design:type', dragAndDropService_1.DragAndDropService)
	    ], RenderedHeaderGroupCell.prototype, "dragAndDropService", void 0);
	    __decorate([
	        context_1.PostConstruct, 
	        __metadata('design:type', Function), 
	        __metadata('design:paramtypes', []), 
	        __metadata('design:returntype', void 0)
	    ], RenderedHeaderGroupCell.prototype, "init", null);
	    return RenderedHeaderGroupCell;
	})();
	exports.RenderedHeaderGroupCell = RenderedHeaderGroupCell;


/***/ },
/* 71 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
	 * @version v7.0.2
	 * @link http://www.ag-grid.com/
	 * @license MIT
	 */
	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var context_1 = __webpack_require__(6);
	var HorizontalDragService = (function () {
	    function HorizontalDragService() {
	    }
	    HorizontalDragService.prototype.addDragHandling = function (params) {
	        params.eDraggableElement.addEventListener('mousedown', function (startEvent) {
	            new DragInstance(params, startEvent);
	        });
	    };
	    HorizontalDragService = __decorate([
	        context_1.Bean('horizontalDragService'), 
	        __metadata('design:paramtypes', [])
	    ], HorizontalDragService);
	    return HorizontalDragService;
	})();
	exports.HorizontalDragService = HorizontalDragService;
	var DragInstance = (function () {
	    function DragInstance(params, startEvent) {
	        this.mouseMove = this.onMouseMove.bind(this);
	        this.mouseUp = this.onMouseUp.bind(this);
	        this.mouseLeave = this.onMouseLeave.bind(this);
	        this.lastDelta = 0;
	        this.params = params;
	        this.eDragParent = document.querySelector('body');
	        this.dragStartX = startEvent.clientX;
	        this.startEvent = startEvent;
	        this.eDragParent.addEventListener('mousemove', this.mouseMove);
	        this.eDragParent.addEventListener('mouseup', this.mouseUp);
	        this.eDragParent.addEventListener('mouseleave', this.mouseLeave);
	        this.draggingStarted = false;
	        var startAfterPixelsExist = typeof params.startAfterPixels === 'number' && params.startAfterPixels > 0;
	        if (!startAfterPixelsExist) {
	            this.startDragging();
	        }
	    }
	    DragInstance.prototype.startDragging = function () {
	        this.draggingStarted = true;
	        this.oldBodyCursor = this.params.eBody.style.cursor;
	        this.oldParentCursor = this.eDragParent.style.cursor;
	        this.oldMsUserSelect = this.eDragParent.style.msUserSelect;
	        this.oldWebkitUserSelect = this.eDragParent.style.webkitUserSelect;
	        // change the body cursor, so when drag moves out of the drag bar, the cursor is still 'resize' (or 'move'
	        this.params.eBody.style.cursor = this.params.cursor;
	        // same for outside the grid, we want to keep the resize (or move) cursor
	        this.eDragParent.style.cursor = this.params.cursor;
	        // we don't want text selection outside the grid (otherwise it looks weird as text highlights when we move)
	        this.eDragParent.style.msUserSelect = 'none';
	        this.eDragParent.style.webkitUserSelect = 'none';
	        this.params.onDragStart(this.startEvent);
	    };
	    DragInstance.prototype.onMouseMove = function (moveEvent) {
	        var newX = moveEvent.clientX;
	        this.lastDelta = newX - this.dragStartX;
	        if (!this.draggingStarted) {
	            var dragExceededStartAfterPixels = Math.abs(this.lastDelta) >= this.params.startAfterPixels;
	            if (dragExceededStartAfterPixels) {
	                this.startDragging();
	            }
	        }
	        if (this.draggingStarted) {
	            this.params.onDragging(this.lastDelta, false);
	        }
	    };
	    DragInstance.prototype.onMouseUp = function () {
	        this.stopDragging();
	    };
	    DragInstance.prototype.onMouseLeave = function () {
	        this.stopDragging();
	    };
	    DragInstance.prototype.stopDragging = function () {
	        // reset cursor back to original cursor, if they were changed in the first place
	        if (this.draggingStarted) {
	            this.params.eBody.style.cursor = this.oldBodyCursor;
	            this.eDragParent.style.cursor = this.oldParentCursor;
	            this.eDragParent.style.msUserSelect = this.oldMsUserSelect;
	            this.eDragParent.style.webkitUserSelect = this.oldWebkitUserSelect;
	            this.params.onDragging(this.lastDelta, true);
	        }
	        // always remove the listeners, as these are always added
	        this.eDragParent.removeEventListener('mousemove', this.mouseMove);
	        this.eDragParent.removeEventListener('mouseup', this.mouseUp);
	        this.eDragParent.removeEventListener('mouseleave', this.mouseLeave);
	    };
	    return DragInstance;
	})();


/***/ },
/* 72 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
	 * @version v7.0.2
	 * @link http://www.ag-grid.com/
	 * @license MIT
	 */
	var utils_1 = __webpack_require__(7);
	var CssClassApplier = (function () {
	    function CssClassApplier() {
	    }
	    CssClassApplier.addHeaderClassesFromColDef = function (abstractColDef, eHeaderCell, gridOptionsWrapper, column, columnGroup) {
	        if (utils_1.Utils.missing(abstractColDef)) {
	            return;
	        }
	        this.addColumnClassesFromCollDef(abstractColDef.headerClass, abstractColDef, eHeaderCell, gridOptionsWrapper, column, columnGroup);
	    };
	    CssClassApplier.addToolPanelClassesFromColDef = function (abstractColDef, eHeaderCell, gridOptionsWrapper, column, columnGroup) {
	        if (utils_1.Utils.missing(abstractColDef)) {
	            return;
	        }
	        this.addColumnClassesFromCollDef(abstractColDef.toolPanelClass, abstractColDef, eHeaderCell, gridOptionsWrapper, column, columnGroup);
	    };
	    CssClassApplier.addColumnClassesFromCollDef = function (classesOrFunc, abstractColDef, eHeaderCell, gridOptionsWrapper, column, columnGroup) {
	        if (utils_1.Utils.missing(classesOrFunc)) {
	            return;
	        }
	        var classToUse;
	        if (typeof classesOrFunc === 'function') {
	            var params = {
	                // bad naming, as colDef here can be a group or a column,
	                // however most people won't appreciate the difference,
	                // so keeping it as colDef to avoid confusion.
	                colDef: abstractColDef,
	                column: column,
	                columnGroup: columnGroup,
	                context: gridOptionsWrapper.getContext(),
	                api: gridOptionsWrapper.getApi()
	            };
	            var headerClassFunc = classesOrFunc;
	            classToUse = headerClassFunc(params);
	        }
	        else {
	            classToUse = classesOrFunc;
	        }
	        if (typeof classToUse === 'string') {
	            utils_1.Utils.addCssClass(eHeaderCell, classToUse);
	        }
	        else if (Array.isArray(classToUse)) {
	            classToUse.forEach(function (cssClassItem) {
	                utils_1.Utils.addCssClass(eHeaderCell, cssClassItem);
	            });
	        }
	    };
	    return CssClassApplier;
	})();
	exports.CssClassApplier = CssClassApplier;


/***/ },
/* 73 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
	 * @version v7.0.2
	 * @link http://www.ag-grid.com/
	 * @license MIT
	 */
	var eventService_1 = __webpack_require__(4);
	var utils_1 = __webpack_require__(7);
	var TouchListener = (function () {
	    function TouchListener(eElement) {
	        var _this = this;
	        this.destroyFuncs = [];
	        this.touching = false;
	        this.eventService = new eventService_1.EventService();
	        this.eElement = eElement;
	        var startListener = this.onTouchStart.bind(this);
	        var moveListener = this.onTouchMove.bind(this);
	        var endListener = this.onTouchEnd.bind(this);
	        this.eElement.addEventListener('touchstart', startListener);
	        this.eElement.addEventListener('touchmove', moveListener);
	        this.eElement.addEventListener('touchend', endListener);
	        this.destroyFuncs.push(function () {
	            _this.eElement.addEventListener('touchstart', startListener);
	            _this.eElement.addEventListener('touchmove', moveListener);
	            _this.eElement.addEventListener('touchend', endListener);
	        });
	    }
	    TouchListener.prototype.getActiveTouch = function (touchList) {
	        for (var i = 0; i < touchList.length; i++) {
	            var matches = touchList[i].identifier === this.touchStart.identifier;
	            if (matches) {
	                return touchList[i];
	            }
	        }
	        return null;
	    };
	    TouchListener.prototype.addEventListener = function (eventType, listener) {
	        this.eventService.addEventListener(eventType, listener);
	    };
	    TouchListener.prototype.removeEventListener = function (eventType, listener) {
	        this.eventService.removeEventListener(eventType, listener);
	    };
	    TouchListener.prototype.onTouchStart = function (touchEvent) {
	        var _this = this;
	        // only looking at one touch point at any time
	        if (this.touching) {
	            return;
	        }
	        this.touchStart = touchEvent.touches[0];
	        this.touching = true;
	        this.moved = false;
	        var touchStartCopy = this.touchStart;
	        setTimeout(function () {
	            var touchesMatch = _this.touchStart === touchStartCopy;
	            if (_this.touching && touchesMatch && !_this.moved) {
	                _this.moved = true;
	                _this.eventService.dispatchEvent(TouchListener.EVENT_LONG_TAP, _this.touchStart);
	            }
	        }, 500);
	    };
	    TouchListener.prototype.onTouchMove = function (touchEvent) {
	        if (!this.touching) {
	            return;
	        }
	        var touch = this.getActiveTouch(touchEvent.touches);
	        if (!touch) {
	            return;
	        }
	        var eventIsFarAway = !utils_1.Utils.areEventsNear(touch, this.touchStart, 4);
	        if (eventIsFarAway) {
	            this.moved = true;
	        }
	    };
	    TouchListener.prototype.onTouchEnd = function (touchEvent) {
	        if (!this.touching) {
	            return;
	        }
	        if (!this.moved) {
	            this.eventService.dispatchEvent(TouchListener.EVENT_TAP, this.touchStart);
	        }
	        this.touching = false;
	    };
	    TouchListener.prototype.destroy = function () {
	        this.destroyFuncs.forEach(function (func) { return func(); });
	    };
	    // private mostRecentTouch: Touch;
	    TouchListener.EVENT_TAP = 'tap';
	    TouchListener.EVENT_LONG_TAP = 'longTap';
	    return TouchListener;
	})();
	exports.TouchListener = TouchListener;


/***/ },
/* 74 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
	 * @version v7.0.2
	 * @link http://www.ag-grid.com/
	 * @license MIT
	 */
	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var utils_1 = __webpack_require__(7);
	var column_1 = __webpack_require__(15);
	var filterManager_1 = __webpack_require__(43);
	var columnController_1 = __webpack_require__(13);
	var headerTemplateLoader_1 = __webpack_require__(75);
	var gridOptionsWrapper_1 = __webpack_require__(3);
	var horizontalDragService_1 = __webpack_require__(71);
	var gridCore_1 = __webpack_require__(40);
	var context_1 = __webpack_require__(6);
	var cssClassApplier_1 = __webpack_require__(72);
	var dragAndDropService_1 = __webpack_require__(68);
	var sortController_1 = __webpack_require__(42);
	var setLeftFeature_1 = __webpack_require__(63);
	var touchListener_1 = __webpack_require__(73);
	var RenderedHeaderCell = (function () {
	    function RenderedHeaderCell(column, eRoot, dragSourceDropTarget) {
	        // for better structured code, anything we need to do when this column gets destroyed,
	        // we put a function in here. otherwise we would have a big destroy function with lots
	        // of 'if / else' mapping to things that got created.
	        this.destroyFunctions = [];
	        this.column = column;
	        this.eRoot = eRoot;
	        this.dragSourceDropTarget = dragSourceDropTarget;
	    }
	    RenderedHeaderCell.prototype.getColumn = function () {
	        return this.column;
	    };
	    RenderedHeaderCell.prototype.init = function () {
	        this.eHeaderCell = this.headerTemplateLoader.createHeaderElement(this.column);
	        utils_1.Utils.addCssClass(this.eHeaderCell, 'ag-header-cell');
	        this.createScope();
	        this.addAttributes();
	        cssClassApplier_1.CssClassApplier.addHeaderClassesFromColDef(this.column.getColDef(), this.eHeaderCell, this.gridOptionsWrapper, this.column, null);
	        // label div
	        var eHeaderCellLabel = this.eHeaderCell.querySelector('#agHeaderCellLabel');
	        this.displayName = this.columnController.getDisplayNameForColumn(this.column, 'header', true);
	        this.setupMovingCss();
	        this.setupTooltip();
	        this.setupResize();
	        this.setupTap();
	        this.setupMove(eHeaderCellLabel);
	        this.setupMenu();
	        this.setupSort(eHeaderCellLabel);
	        this.setupFilterIcon();
	        this.setupText();
	        this.setupWidth();
	        var setLeftFeature = new setLeftFeature_1.SetLeftFeature(this.column, this.eHeaderCell);
	        this.destroyFunctions.push(setLeftFeature.destroy.bind(setLeftFeature));
	    };
	    RenderedHeaderCell.prototype.setupTooltip = function () {
	        var colDef = this.column.getColDef();
	        // add tooltip if exists
	        if (colDef.headerTooltip) {
	            this.eHeaderCell.title = colDef.headerTooltip;
	        }
	    };
	    RenderedHeaderCell.prototype.setupText = function () {
	        var colDef = this.column.getColDef();
	        // render the cell, use a renderer if one is provided
	        var headerCellRenderer;
	        if (colDef.headerCellRenderer) {
	            headerCellRenderer = colDef.headerCellRenderer;
	        }
	        else if (this.gridOptionsWrapper.getHeaderCellRenderer()) {
	            headerCellRenderer = this.gridOptionsWrapper.getHeaderCellRenderer();
	        }
	        var eText = this.eHeaderCell.querySelector('#agText');
	        if (eText) {
	            if (headerCellRenderer) {
	                this.useRenderer(this.displayName, headerCellRenderer, eText);
	            }
	            else {
	                // no renderer, default text render
	                eText.className = 'ag-header-cell-text';
	                eText.innerHTML = this.displayName;
	            }
	        }
	    };
	    RenderedHeaderCell.prototype.setupFilterIcon = function () {
	        var _this = this;
	        var eFilterIcon = this.eHeaderCell.querySelector('#agFilter');
	        if (!eFilterIcon) {
	            return;
	        }
	        var filterChangedListener = function () {
	            var filterPresent = _this.column.isFilterActive();
	            utils_1.Utils.addOrRemoveCssClass(_this.eHeaderCell, 'ag-header-cell-filtered', filterPresent);
	            utils_1.Utils.addOrRemoveCssClass(eFilterIcon, 'ag-hidden', !filterPresent);
	        };
	        this.column.addEventListener(column_1.Column.EVENT_FILTER_CHANGED, filterChangedListener);
	        this.destroyFunctions.push(function () {
	            _this.column.removeEventListener(column_1.Column.EVENT_FILTER_CHANGED, filterChangedListener);
	        });
	        filterChangedListener();
	    };
	    RenderedHeaderCell.prototype.setupWidth = function () {
	        var _this = this;
	        var widthChangedListener = function () {
	            _this.eHeaderCell.style.width = _this.column.getActualWidth() + 'px';
	        };
	        this.column.addEventListener(column_1.Column.EVENT_WIDTH_CHANGED, widthChangedListener);
	        this.destroyFunctions.push(function () {
	            _this.column.removeEventListener(column_1.Column.EVENT_WIDTH_CHANGED, widthChangedListener);
	        });
	        widthChangedListener();
	    };
	    RenderedHeaderCell.prototype.getGui = function () {
	        return this.eHeaderCell;
	    };
	    RenderedHeaderCell.prototype.destroy = function () {
	        this.destroyFunctions.forEach(function (func) {
	            func();
	        });
	    };
	    RenderedHeaderCell.prototype.createScope = function () {
	        var _this = this;
	        if (this.gridOptionsWrapper.isAngularCompileHeaders()) {
	            this.childScope = this.$scope.$new();
	            this.childScope.colDef = this.column.getColDef();
	            this.childScope.colDefWrapper = this.column;
	            this.childScope.context = this.gridOptionsWrapper.getContext();
	            this.destroyFunctions.push(function () {
	                _this.childScope.$destroy();
	            });
	        }
	    };
	    RenderedHeaderCell.prototype.addAttributes = function () {
	        this.eHeaderCell.setAttribute("colId", this.column.getColId());
	    };
	    RenderedHeaderCell.prototype.setupMenu = function () {
	        var _this = this;
	        var eMenu = this.eHeaderCell.querySelector('#agMenu');
	        // if no menu provided in template, do nothing
	        if (!eMenu) {
	            return;
	        }
	        var skipMenu = !this.menuFactory.isMenuEnabled(this.column) || this.column.getColDef().suppressMenu;
	        if (skipMenu) {
	            utils_1.Utils.removeFromParent(eMenu);
	            return;
	        }
	        eMenu.addEventListener('click', function () { return _this.showMenu(eMenu); });
	        if (!this.gridOptionsWrapper.isSuppressMenuHide()) {
	            eMenu.style.opacity = '0';
	            this.eHeaderCell.addEventListener('mouseover', function () {
	                eMenu.style.opacity = '1';
	            });
	            this.eHeaderCell.addEventListener('mouseout', function () {
	                eMenu.style.opacity = '0';
	            });
	        }
	        var style = eMenu.style;
	        style['transition'] = 'opacity 0.2s, border 0.2s';
	        style['-webkit-transition'] = 'opacity 0.2s, border 0.2s';
	    };
	    RenderedHeaderCell.prototype.showMenu = function (eventSource) {
	        this.menuFactory.showMenuAfterButtonClick(this.column, eventSource);
	    };
	    RenderedHeaderCell.prototype.setupMovingCss = function () {
	        var _this = this;
	        // this function adds or removes the moving css, based on if the col is moving
	        var addMovingCssFunc = function () {
	            if (_this.column.isMoving()) {
	                utils_1.Utils.addCssClass(_this.eHeaderCell, 'ag-header-cell-moving');
	            }
	            else {
	                utils_1.Utils.removeCssClass(_this.eHeaderCell, 'ag-header-cell-moving');
	            }
	        };
	        // call it now once, so the col is set up correctly
	        addMovingCssFunc();
	        // then call it every time we are informed of a moving state change in the col
	        this.column.addEventListener(column_1.Column.EVENT_MOVING_CHANGED, addMovingCssFunc);
	        // finally we remove the listener when this cell is no longer rendered
	        this.destroyFunctions.push(function () {
	            _this.column.removeEventListener(column_1.Column.EVENT_MOVING_CHANGED, addMovingCssFunc);
	        });
	    };
	    RenderedHeaderCell.prototype.setupMove = function (eHeaderCellLabel) {
	        var _this = this;
	        var suppressMove = this.gridOptionsWrapper.isSuppressMovableColumns()
	            || this.column.getColDef().suppressMovable
	            || this.gridOptionsWrapper.isForPrint();
	        // || this.columnController.isPivotMode();
	        if (suppressMove) {
	            return;
	        }
	        if (eHeaderCellLabel) {
	            var dragSource = {
	                type: dragAndDropService_1.DragSourceType.HeaderCell,
	                eElement: eHeaderCellLabel,
	                dragItem: [this.column],
	                dragItemName: this.displayName,
	                dragSourceDropTarget: this.dragSourceDropTarget
	            };
	            this.dragAndDropService.addDragSource(dragSource, true);
	            this.destroyFunctions.push(function () { return _this.dragAndDropService.removeDragSource(dragSource); });
	        }
	    };
	    RenderedHeaderCell.prototype.setupTap = function () {
	        var _this = this;
	        if (this.gridOptionsWrapper.isSuppressTouch()) {
	            return;
	        }
	        var touchListener = new touchListener_1.TouchListener(this.getGui());
	        var tapListener = function (touch) {
	            _this.sortController.progressSort(_this.column, false);
	        };
	        var longTapListener = function (touch) {
	            _this.gridOptionsWrapper.getApi().showColumnMenuAfterMouseClick(_this.column, touch);
	        };
	        touchListener.addEventListener(touchListener_1.TouchListener.EVENT_TAP, tapListener);
	        touchListener.addEventListener(touchListener_1.TouchListener.EVENT_LONG_TAP, longTapListener);
	        this.destroyFunctions.push(function () {
	            touchListener.removeEventListener(touchListener_1.TouchListener.EVENT_TAP, tapListener);
	            touchListener.removeEventListener(touchListener_1.TouchListener.EVENT_LONG_TAP, longTapListener);
	            touchListener.destroy();
	        });
	    };
	    RenderedHeaderCell.prototype.setupResize = function () {
	        var _this = this;
	        var colDef = this.column.getColDef();
	        var eResize = this.eHeaderCell.querySelector('#agResizeBar');
	        // if no eResize in template, do nothing
	        if (!eResize) {
	            return;
	        }
	        var weWantResize = this.gridOptionsWrapper.isEnableColResize() && !colDef.suppressResize;
	        if (!weWantResize) {
	            utils_1.Utils.removeFromParent(eResize);
	            return;
	        }
	        this.horizontalDragService.addDragHandling({
	            eDraggableElement: eResize,
	            eBody: this.eRoot,
	            cursor: 'col-resize',
	            startAfterPixels: 0,
	            onDragStart: this.onDragStart.bind(this),
	            onDragging: this.onDragging.bind(this)
	        });
	        var weWantAutoSize = !this.gridOptionsWrapper.isSuppressAutoSize() && !colDef.suppressAutoSize;
	        if (weWantAutoSize) {
	            eResize.addEventListener('dblclick', function () {
	                _this.columnController.autoSizeColumn(_this.column);
	            });
	        }
	    };
	    RenderedHeaderCell.prototype.useRenderer = function (headerNameValue, headerCellRenderer, eText) {
	        // renderer provided, use it
	        var cellRendererParams = {
	            colDef: this.column.getColDef(),
	            $scope: this.childScope,
	            context: this.gridOptionsWrapper.getContext(),
	            value: headerNameValue,
	            api: this.gridOptionsWrapper.getApi(),
	            eHeaderCell: this.eHeaderCell
	        };
	        var cellRendererResult = headerCellRenderer(cellRendererParams);
	        var childToAppend;
	        if (utils_1.Utils.isNodeOrElement(cellRendererResult)) {
	            // a dom node or element was returned, so add child
	            childToAppend = cellRendererResult;
	        }
	        else {
	            // otherwise assume it was html, so just insert
	            var eTextSpan = document.createElement("span");
	            eTextSpan.innerHTML = cellRendererResult;
	            childToAppend = eTextSpan;
	        }
	        // angular compile header if option is turned on
	        if (this.gridOptionsWrapper.isAngularCompileHeaders()) {
	            var childToAppendCompiled = this.$compile(childToAppend)(this.childScope)[0];
	            eText.appendChild(childToAppendCompiled);
	        }
	        else {
	            eText.appendChild(childToAppend);
	        }
	    };
	    RenderedHeaderCell.prototype.setupSort = function (eHeaderCellLabel) {
	        var _this = this;
	        var enableSorting = this.gridOptionsWrapper.isEnableSorting() && !this.column.getColDef().suppressSorting;
	        if (!enableSorting) {
	            utils_1.Utils.removeFromParent(this.eHeaderCell.querySelector('#agSortAsc'));
	            utils_1.Utils.removeFromParent(this.eHeaderCell.querySelector('#agSortDesc'));
	            utils_1.Utils.removeFromParent(this.eHeaderCell.querySelector('#agNoSort'));
	            return;
	        }
	        // add sortable class for styling
	        utils_1.Utils.addCssClass(this.eHeaderCell, 'ag-header-cell-sortable');
	        // add the event on the header, so when clicked, we do sorting
	        if (eHeaderCellLabel) {
	            eHeaderCellLabel.addEventListener("click", function (event) {
	                _this.sortController.progressSort(_this.column, event.shiftKey);
	            });
	        }
	        // add listener for sort changing, and update the icons accordingly
	        var eSortAsc = this.eHeaderCell.querySelector('#agSortAsc');
	        var eSortDesc = this.eHeaderCell.querySelector('#agSortDesc');
	        var eSortNone = this.eHeaderCell.querySelector('#agNoSort');
	        var sortChangedListener = function () {
	            utils_1.Utils.addOrRemoveCssClass(_this.eHeaderCell, 'ag-header-cell-sorted-asc', _this.column.isSortAscending());
	            utils_1.Utils.addOrRemoveCssClass(_this.eHeaderCell, 'ag-header-cell-sorted-desc', _this.column.isSortDescending());
	            utils_1.Utils.addOrRemoveCssClass(_this.eHeaderCell, 'ag-header-cell-sorted-none', _this.column.isSortNone());
	            if (eSortAsc) {
	                utils_1.Utils.addOrRemoveCssClass(eSortAsc, 'ag-hidden', !_this.column.isSortAscending());
	            }
	            if (eSortDesc) {
	                utils_1.Utils.addOrRemoveCssClass(eSortDesc, 'ag-hidden', !_this.column.isSortDescending());
	            }
	            if (eSortNone) {
	                var alwaysHideNoSort = !_this.column.getColDef().unSortIcon && !_this.gridOptionsWrapper.isUnSortIcon();
	                utils_1.Utils.addOrRemoveCssClass(eSortNone, 'ag-hidden', alwaysHideNoSort || !_this.column.isSortNone());
	            }
	        };
	        this.column.addEventListener(column_1.Column.EVENT_SORT_CHANGED, sortChangedListener);
	        this.destroyFunctions.push(function () {
	            _this.column.removeEventListener(column_1.Column.EVENT_SORT_CHANGED, sortChangedListener);
	        });
	        sortChangedListener();
	    };
	    RenderedHeaderCell.prototype.onDragStart = function () {
	        this.startWidth = this.column.getActualWidth();
	    };
	    RenderedHeaderCell.prototype.onDragging = function (dragChange, finished) {
	        var newWidth = this.startWidth + dragChange;
	        this.columnController.setColumnWidth(this.column, newWidth, finished);
	    };
	    RenderedHeaderCell.prototype.onIndividualColumnResized = function (column) {
	        if (this.column !== column) {
	            return;
	        }
	        var newWidthPx = column.getActualWidth() + "px";
	        this.eHeaderCell.style.width = newWidthPx;
	    };
	    __decorate([
	        context_1.Autowired('context'), 
	        __metadata('design:type', context_1.Context)
	    ], RenderedHeaderCell.prototype, "context", void 0);
	    __decorate([
	        context_1.Autowired('filterManager'), 
	        __metadata('design:type', filterManager_1.FilterManager)
	    ], RenderedHeaderCell.prototype, "filterManager", void 0);
	    __decorate([
	        context_1.Autowired('columnController'), 
	        __metadata('design:type', columnController_1.ColumnController)
	    ], RenderedHeaderCell.prototype, "columnController", void 0);
	    __decorate([
	        context_1.Autowired('$compile'), 
	        __metadata('design:type', Object)
	    ], RenderedHeaderCell.prototype, "$compile", void 0);
	    __decorate([
	        context_1.Autowired('gridCore'), 
	        __metadata('design:type', gridCore_1.GridCore)
	    ], RenderedHeaderCell.prototype, "gridCore", void 0);
	    __decorate([
	        context_1.Autowired('headerTemplateLoader'), 
	        __metadata('design:type', headerTemplateLoader_1.HeaderTemplateLoader)
	    ], RenderedHeaderCell.prototype, "headerTemplateLoader", void 0);
	    __decorate([
	        context_1.Autowired('horizontalDragService'), 
	        __metadata('design:type', horizontalDragService_1.HorizontalDragService)
	    ], RenderedHeaderCell.prototype, "horizontalDragService", void 0);
	    __decorate([
	        context_1.Autowired('menuFactory'), 
	        __metadata('design:type', Object)
	    ], RenderedHeaderCell.prototype, "menuFactory", void 0);
	    __decorate([
	        context_1.Autowired('gridOptionsWrapper'), 
	        __metadata('design:type', gridOptionsWrapper_1.GridOptionsWrapper)
	    ], RenderedHeaderCell.prototype, "gridOptionsWrapper", void 0);
	    __decorate([
	        context_1.Autowired('dragAndDropService'), 
	        __metadata('design:type', dragAndDropService_1.DragAndDropService)
	    ], RenderedHeaderCell.prototype, "dragAndDropService", void 0);
	    __decorate([
	        context_1.Autowired('sortController'), 
	        __metadata('design:type', sortController_1.SortController)
	    ], RenderedHeaderCell.prototype, "sortController", void 0);
	    __decorate([
	        context_1.Autowired('$scope'), 
	        __metadata('design:type', Object)
	    ], RenderedHeaderCell.prototype, "$scope", void 0);
	    __decorate([
	        context_1.PostConstruct, 
	        __metadata('design:type', Function), 
	        __metadata('design:paramtypes', []), 
	        __metadata('design:returntype', void 0)
	    ], RenderedHeaderCell.prototype, "init", null);
	    return RenderedHeaderCell;
	})();
	exports.RenderedHeaderCell = RenderedHeaderCell;


/***/ },
/* 75 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
	 * @version v7.0.2
	 * @link http://www.ag-grid.com/
	 * @license MIT
	 */
	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var utils_1 = __webpack_require__(7);
	var svgFactory_1 = __webpack_require__(59);
	var gridOptionsWrapper_1 = __webpack_require__(3);
	var context_1 = __webpack_require__(6);
	var svgFactory = svgFactory_1.SvgFactory.getInstance();
	var HeaderTemplateLoader = (function () {
	    function HeaderTemplateLoader() {
	    }
	    HeaderTemplateLoader.prototype.createHeaderElement = function (column) {
	        var params = {
	            column: column,
	            colDef: column.getColDef,
	            context: this.gridOptionsWrapper.getContext(),
	            api: this.gridOptionsWrapper.getApi()
	        };
	        // option 1 - see if user provided a template in colDef
	        var userProvidedTemplate = column.getColDef().headerCellTemplate;
	        if (typeof userProvidedTemplate === 'function') {
	            var colDefFunc = userProvidedTemplate;
	            userProvidedTemplate = colDefFunc(params);
	        }
	        // option 2 - check the gridOptions for cellTemplate
	        if (!userProvidedTemplate && this.gridOptionsWrapper.getHeaderCellTemplate()) {
	            userProvidedTemplate = this.gridOptionsWrapper.getHeaderCellTemplate();
	        }
	        // option 3 - check the gridOptions for templateFunction
	        if (!userProvidedTemplate && this.gridOptionsWrapper.getHeaderCellTemplateFunc()) {
	            var gridOptionsFunc = this.gridOptionsWrapper.getHeaderCellTemplateFunc();
	            userProvidedTemplate = gridOptionsFunc(params);
	        }
	        // finally, if still no template, use the default
	        if (!userProvidedTemplate) {
	            userProvidedTemplate = this.createDefaultHeaderElement(column);
	        }
	        // template can be a string or a dom element, if string we need to convert to a dom element
	        var result;
	        if (typeof userProvidedTemplate === 'string') {
	            result = utils_1.Utils.loadTemplate(userProvidedTemplate);
	        }
	        else if (utils_1.Utils.isNodeOrElement(userProvidedTemplate)) {
	            result = userProvidedTemplate;
	        }
	        else {
	            console.error('ag-Grid: header template must be a string or an HTML element');
	        }
	        return result;
	    };
	    HeaderTemplateLoader.prototype.createDefaultHeaderElement = function (column) {
	        var eTemplate = utils_1.Utils.loadTemplate(HeaderTemplateLoader.HEADER_CELL_TEMPLATE);
	        this.addInIcon(eTemplate, 'sortAscending', '#agSortAsc', column, svgFactory.createArrowUpSvg);
	        this.addInIcon(eTemplate, 'sortDescending', '#agSortDesc', column, svgFactory.createArrowDownSvg);
	        this.addInIcon(eTemplate, 'sortUnSort', '#agNoSort', column, svgFactory.createArrowUpDownSvg);
	        this.addInIcon(eTemplate, 'menu', '#agMenu', column, svgFactory.createMenuSvg);
	        this.addInIcon(eTemplate, 'filter', '#agFilter', column, svgFactory.createFilterSvg);
	        return eTemplate;
	    };
	    HeaderTemplateLoader.prototype.addInIcon = function (eTemplate, iconName, cssSelector, column, defaultIconFactory) {
	        var eIcon = utils_1.Utils.createIconNoSpan(iconName, this.gridOptionsWrapper, column, defaultIconFactory);
	        eTemplate.querySelector(cssSelector).appendChild(eIcon);
	    };
	    HeaderTemplateLoader.HEADER_CELL_TEMPLATE = '<div class="ag-header-cell">' +
	        '  <div id="agResizeBar" class="ag-header-cell-resize"></div>' +
	        '  <span id="agMenu" class="ag-header-icon ag-header-cell-menu-button"></span>' +
	        '  <div id="agHeaderCellLabel" class="ag-header-cell-label">' +
	        '    <span id="agSortAsc" class="ag-header-icon ag-sort-ascending-icon"></span>' +
	        '    <span id="agSortDesc" class="ag-header-icon ag-sort-descending-icon"></span>' +
	        '    <span id="agNoSort" class="ag-header-icon ag-sort-none-icon"></span>' +
	        '    <span id="agFilter" class="ag-header-icon ag-filter-icon"></span>' +
	        '    <span id="agText" class="ag-header-cell-text"></span>' +
	        '  </div>' +
	        '</div>';
	    __decorate([
	        context_1.Autowired('gridOptionsWrapper'), 
	        __metadata('design:type', gridOptionsWrapper_1.GridOptionsWrapper)
	    ], HeaderTemplateLoader.prototype, "gridOptionsWrapper", void 0);
	    HeaderTemplateLoader = __decorate([
	        context_1.Bean('headerTemplateLoader'), 
	        __metadata('design:paramtypes', [])
	    ], HeaderTemplateLoader);
	    return HeaderTemplateLoader;
	})();
	exports.HeaderTemplateLoader = HeaderTemplateLoader;


/***/ },
/* 76 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
	 * @version v7.0.2
	 * @link http://www.ag-grid.com/
	 * @license MIT
	 */
	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var dragAndDropService_1 = __webpack_require__(68);
	var context_1 = __webpack_require__(6);
	var moveColumnController_1 = __webpack_require__(77);
	var column_1 = __webpack_require__(15);
	var gridPanel_1 = __webpack_require__(24);
	var bodyDropPivotTarget_1 = __webpack_require__(78);
	var columnController_1 = __webpack_require__(13);
	var BodyDropTarget = (function () {
	    function BodyDropTarget(pinned, eContainer) {
	        this.pinned = pinned;
	        this.eContainer = eContainer;
	    }
	    BodyDropTarget.prototype.getSecondaryContainers = function () {
	        return this.eSecondaryContainers;
	    };
	    BodyDropTarget.prototype.getContainer = function () {
	        return this.eContainer;
	    };
	    BodyDropTarget.prototype.init = function () {
	        this.moveColumnController = new moveColumnController_1.MoveColumnController(this.pinned);
	        this.context.wireBean(this.moveColumnController);
	        this.bodyDropPivotTarget = new bodyDropPivotTarget_1.BodyDropPivotTarget(this.pinned);
	        this.context.wireBean(this.bodyDropPivotTarget);
	        switch (this.pinned) {
	            case column_1.Column.PINNED_LEFT:
	                this.eSecondaryContainers = this.gridPanel.getDropTargetLeftContainers();
	                break;
	            case column_1.Column.PINNED_RIGHT:
	                this.eSecondaryContainers = this.gridPanel.getDropTargetPinnedRightContainers();
	                break;
	            default:
	                this.eSecondaryContainers = this.gridPanel.getDropTargetBodyContainers();
	                break;
	        }
	        this.dragAndDropService.addDropTarget(this);
	    };
	    BodyDropTarget.prototype.getIconName = function () {
	        return this.currentDropListener.getIconName();
	    };
	    // we want to use the bodyPivotTarget if the user is dragging columns in from the toolPanel
	    // and we are in pivot mode, as it has to logic to set pivot/value/group on the columns when
	    // dropped into the grid's body.
	    BodyDropTarget.prototype.isUseBodyDropPivotTarget = function (draggingEvent) {
	        // if not in pivot mode, then we never use the pivot drop target
	        if (!this.columnController.isPivotMode()) {
	            return false;
	        }
	        // otherwise we use the drop target if the column came from the toolPanel (ie not reordering)
	        return draggingEvent.dragSource.type === dragAndDropService_1.DragSourceType.ToolPanel;
	    };
	    BodyDropTarget.prototype.onDragEnter = function (draggingEvent) {
	        // we pick the drop listener depending on whether we are in pivot mode are not. if we are
	        // in pivot mode, then dropping cols changes the row group, pivot, value stats. otherwise
	        // we change visibility state and position.
	        // if (this.columnController.isPivotMode()) {
	        var useBodyDropPivotTarget = this.isUseBodyDropPivotTarget(draggingEvent);
	        if (useBodyDropPivotTarget) {
	            this.currentDropListener = this.bodyDropPivotTarget;
	        }
	        else {
	            this.currentDropListener = this.moveColumnController;
	        }
	        this.currentDropListener.onDragEnter(draggingEvent);
	    };
	    BodyDropTarget.prototype.onDragLeave = function (params) {
	        this.currentDropListener.onDragLeave(params);
	    };
	    BodyDropTarget.prototype.onDragging = function (params) {
	        this.currentDropListener.onDragging(params);
	    };
	    BodyDropTarget.prototype.onDragStop = function (params) {
	        this.currentDropListener.onDragStop(params);
	    };
	    __decorate([
	        context_1.Autowired('context'), 
	        __metadata('design:type', context_1.Context)
	    ], BodyDropTarget.prototype, "context", void 0);
	    __decorate([
	        context_1.Autowired('gridPanel'), 
	        __metadata('design:type', gridPanel_1.GridPanel)
	    ], BodyDropTarget.prototype, "gridPanel", void 0);
	    __decorate([
	        context_1.Autowired('dragAndDropService'), 
	        __metadata('design:type', dragAndDropService_1.DragAndDropService)
	    ], BodyDropTarget.prototype, "dragAndDropService", void 0);
	    __decorate([
	        context_1.Autowired('columnController'), 
	        __metadata('design:type', columnController_1.ColumnController)
	    ], BodyDropTarget.prototype, "columnController", void 0);
	    __decorate([
	        context_1.PostConstruct, 
	        __metadata('design:type', Function), 
	        __metadata('design:paramtypes', []), 
	        __metadata('design:returntype', void 0)
	    ], BodyDropTarget.prototype, "init", null);
	    return BodyDropTarget;
	})();
	exports.BodyDropTarget = BodyDropTarget;


/***/ },
/* 77 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
	 * @version v7.0.2
	 * @link http://www.ag-grid.com/
	 * @license MIT
	 */
	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var context_1 = __webpack_require__(6);
	var logger_1 = __webpack_require__(5);
	var columnController_1 = __webpack_require__(13);
	var column_1 = __webpack_require__(15);
	var utils_1 = __webpack_require__(7);
	var dragAndDropService_1 = __webpack_require__(68);
	var gridPanel_1 = __webpack_require__(24);
	var gridOptionsWrapper_1 = __webpack_require__(3);
	var MoveColumnController = (function () {
	    function MoveColumnController(pinned) {
	        this.needToMoveLeft = false;
	        this.needToMoveRight = false;
	        this.pinned = pinned;
	        this.centerContainer = !utils_1.Utils.exists(pinned);
	    }
	    MoveColumnController.prototype.init = function () {
	        this.logger = this.loggerFactory.create('MoveColumnController');
	    };
	    MoveColumnController.prototype.getIconName = function () {
	        return this.pinned ? dragAndDropService_1.DragAndDropService.ICON_PINNED : dragAndDropService_1.DragAndDropService.ICON_MOVE;
	        ;
	    };
	    MoveColumnController.prototype.onDragEnter = function (draggingEvent) {
	        // we do dummy drag, so make sure column appears in the right location when first placed
	        var columns = draggingEvent.dragSource.dragItem;
	        this.columnController.setColumnsVisible(columns, true);
	        this.columnController.setColumnsPinned(columns, this.pinned);
	        this.onDragging(draggingEvent, true);
	    };
	    MoveColumnController.prototype.onDragLeave = function (draggingEvent) {
	        var hideColumnOnExit = !this.gridOptionsWrapper.isSuppressDragLeaveHidesColumns() && !draggingEvent.fromNudge;
	        if (hideColumnOnExit) {
	            var columns = draggingEvent.dragSource.dragItem;
	            this.columnController.setColumnsVisible(columns, false);
	        }
	        this.ensureIntervalCleared();
	    };
	    MoveColumnController.prototype.onDragStop = function () {
	        this.ensureIntervalCleared();
	    };
	    MoveColumnController.prototype.adjustXForScroll = function (draggingEvent) {
	        if (this.centerContainer) {
	            return draggingEvent.x + this.gridPanel.getHorizontalScrollPosition();
	        }
	        else {
	            return draggingEvent.x;
	        }
	    };
	    MoveColumnController.prototype.workOutNewIndex = function (displayedColumns, allColumns, dragColumn, hDirection, xAdjustedForScroll) {
	        if (hDirection === dragAndDropService_1.HDirection.Left) {
	            return this.getNewIndexForColMovingLeft(displayedColumns, allColumns, dragColumn, xAdjustedForScroll);
	        }
	        else {
	            return this.getNewIndexForColMovingRight(displayedColumns, allColumns, dragColumn, xAdjustedForScroll);
	        }
	    };
	    MoveColumnController.prototype.checkCenterForScrolling = function (xAdjustedForScroll) {
	        if (this.centerContainer) {
	            // scroll if the mouse has gone outside the grid (or just outside the scrollable part if pinning)
	            // putting in 50 buffer, so even if user gets to edge of grid, a scroll will happen
	            var firstVisiblePixel = this.gridPanel.getHorizontalScrollPosition();
	            var lastVisiblePixel = firstVisiblePixel + this.gridPanel.getCenterWidth();
	            this.needToMoveLeft = xAdjustedForScroll < (firstVisiblePixel + 50);
	            this.needToMoveRight = xAdjustedForScroll > (lastVisiblePixel - 50);
	            if (this.needToMoveLeft || this.needToMoveRight) {
	                this.ensureIntervalStarted();
	            }
	            else {
	                this.ensureIntervalCleared();
	            }
	        }
	    };
	    MoveColumnController.prototype.onDragging = function (draggingEvent, fromEnter) {
	        if (fromEnter === void 0) { fromEnter = false; }
	        this.lastDraggingEvent = draggingEvent;
	        // if moving up or down (ie not left or right) then do nothing
	        if (utils_1.Utils.missing(draggingEvent.hDirection)) {
	            return;
	        }
	        var xAdjustedForScroll = this.adjustXForScroll(draggingEvent);
	        // if the user is dragging into the panel, ie coming from the side panel into the main grid,
	        // we don't want to scroll the grid this time, it would appear like the table is jumping
	        // each time a column is dragged in.
	        if (!fromEnter) {
	            this.checkCenterForScrolling(xAdjustedForScroll);
	        }
	        var columnsToMove = draggingEvent.dragSource.dragItem;
	        this.attemptMoveColumns(columnsToMove, draggingEvent.hDirection, xAdjustedForScroll, fromEnter);
	    };
	    MoveColumnController.prototype.attemptMoveColumns = function (allMovingColumns, hDirection, xAdjustedForScroll, fromEnter) {
	        var displayedColumns = this.columnController.getDisplayedColumns(this.pinned);
	        var gridColumns = this.columnController.getAllGridColumns();
	        var draggingLeft = hDirection === dragAndDropService_1.HDirection.Left;
	        var draggingRight = hDirection === dragAndDropService_1.HDirection.Right;
	        var dragColumn;
	        var displayedMovingColumns = utils_1.Utils.filter(allMovingColumns, function (column) { return displayedColumns.indexOf(column) >= 0; });
	        // if dragging left, we want to use the left most column, ie move the left most column to
	        // under the mouse pointer
	        if (draggingLeft) {
	            dragColumn = displayedMovingColumns[0];
	        }
	        else {
	            dragColumn = displayedMovingColumns[displayedMovingColumns.length - 1];
	        }
	        var newIndex = this.workOutNewIndex(displayedColumns, gridColumns, dragColumn, hDirection, xAdjustedForScroll);
	        var oldIndex = gridColumns.indexOf(dragColumn);
	        // the two check below stop an error when the user grabs a group my a middle column, then
	        // it is possible the mouse pointer is to the right of a column while been dragged left.
	        // so we need to make sure that the mouse pointer is actually left of the left most column
	        // if moving left, and right of the right most column if moving right
	        // we check 'fromEnter' below so we move the column to the new spot if the mouse is coming from
	        // outside the grid, eg if the column is moving from side panel, mouse is moving left, then we should
	        // place the column to the RHS even if the mouse is moving left and the column is already on
	        // the LHS. otherwise we stick to the rule described above.
	        // only allow left drag if this column is moving left
	        if (!fromEnter && draggingLeft && newIndex >= oldIndex) {
	            return;
	        }
	        // only allow right drag if this column is moving right
	        if (!fromEnter && draggingRight && newIndex <= oldIndex) {
	            return;
	        }
	        // if moving right, the new index is the index of the right most column, so adjust to first column
	        if (draggingRight) {
	            newIndex = newIndex - allMovingColumns.length + 1;
	        }
	        this.columnController.moveColumns(allMovingColumns, newIndex);
	    };
	    MoveColumnController.prototype.getNewIndexForColMovingLeft = function (displayedColumns, allColumns, dragColumn, x) {
	        var usedX = 0;
	        var leftColumn = null;
	        for (var i = 0; i < displayedColumns.length; i++) {
	            var currentColumn = displayedColumns[i];
	            if (currentColumn === dragColumn) {
	                continue;
	            }
	            usedX += currentColumn.getActualWidth();
	            if (usedX > x) {
	                break;
	            }
	            leftColumn = currentColumn;
	        }
	        var newIndex;
	        if (leftColumn) {
	            newIndex = allColumns.indexOf(leftColumn) + 1;
	            var oldIndex = allColumns.indexOf(dragColumn);
	            if (oldIndex < newIndex) {
	                newIndex--;
	            }
	        }
	        else {
	            newIndex = 0;
	        }
	        return newIndex;
	    };
	    MoveColumnController.prototype.getNewIndexForColMovingRight = function (displayedColumns, allColumns, dragColumnOrGroup, x) {
	        var dragColumn = dragColumnOrGroup;
	        var usedX = dragColumn.getActualWidth();
	        var leftColumn = null;
	        for (var i = 0; i < displayedColumns.length; i++) {
	            if (usedX > x) {
	                break;
	            }
	            var currentColumn = displayedColumns[i];
	            if (currentColumn === dragColumn) {
	                continue;
	            }
	            usedX += currentColumn.getActualWidth();
	            leftColumn = currentColumn;
	        }
	        var newIndex;
	        if (leftColumn) {
	            newIndex = allColumns.indexOf(leftColumn) + 1;
	            var oldIndex = allColumns.indexOf(dragColumn);
	            if (oldIndex < newIndex) {
	                newIndex--;
	            }
	        }
	        else {
	            newIndex = 0;
	        }
	        return newIndex;
	    };
	    MoveColumnController.prototype.ensureIntervalStarted = function () {
	        if (!this.movingIntervalId) {
	            this.intervalCount = 0;
	            this.failedMoveAttempts = 0;
	            this.movingIntervalId = setInterval(this.moveInterval.bind(this), 100);
	            if (this.needToMoveLeft) {
	                this.dragAndDropService.setGhostIcon(dragAndDropService_1.DragAndDropService.ICON_LEFT, true);
	            }
	            else {
	                this.dragAndDropService.setGhostIcon(dragAndDropService_1.DragAndDropService.ICON_RIGHT, true);
	            }
	        }
	    };
	    MoveColumnController.prototype.ensureIntervalCleared = function () {
	        if (this.moveInterval) {
	            clearInterval(this.movingIntervalId);
	            this.movingIntervalId = null;
	            this.dragAndDropService.setGhostIcon(dragAndDropService_1.DragAndDropService.ICON_MOVE);
	        }
	    };
	    MoveColumnController.prototype.moveInterval = function () {
	        var pixelsToMove;
	        this.intervalCount++;
	        pixelsToMove = 10 + (this.intervalCount * 5);
	        if (pixelsToMove > 100) {
	            pixelsToMove = 100;
	        }
	        var pixelsMoved;
	        if (this.needToMoveLeft) {
	            pixelsMoved = this.gridPanel.scrollHorizontally(-pixelsToMove);
	        }
	        else if (this.needToMoveRight) {
	            pixelsMoved = this.gridPanel.scrollHorizontally(pixelsToMove);
	        }
	        if (pixelsMoved !== 0) {
	            this.onDragging(this.lastDraggingEvent);
	            this.failedMoveAttempts = 0;
	        }
	        else {
	            this.failedMoveAttempts++;
	            this.dragAndDropService.setGhostIcon(dragAndDropService_1.DragAndDropService.ICON_PINNED);
	            if (this.failedMoveAttempts > 7) {
	                var columns = this.lastDraggingEvent.dragSource.dragItem;
	                var pinType = this.needToMoveLeft ? column_1.Column.PINNED_LEFT : column_1.Column.PINNED_RIGHT;
	                this.columnController.setColumnsPinned(columns, pinType);
	                this.dragAndDropService.nudge();
	            }
	        }
	    };
	    __decorate([
	        context_1.Autowired('loggerFactory'), 
	        __metadata('design:type', logger_1.LoggerFactory)
	    ], MoveColumnController.prototype, "loggerFactory", void 0);
	    __decorate([
	        context_1.Autowired('columnController'), 
	        __metadata('design:type', columnController_1.ColumnController)
	    ], MoveColumnController.prototype, "columnController", void 0);
	    __decorate([
	        context_1.Autowired('gridPanel'), 
	        __metadata('design:type', gridPanel_1.GridPanel)
	    ], MoveColumnController.prototype, "gridPanel", void 0);
	    __decorate([
	        context_1.Autowired('dragAndDropService'), 
	        __metadata('design:type', dragAndDropService_1.DragAndDropService)
	    ], MoveColumnController.prototype, "dragAndDropService", void 0);
	    __decorate([
	        context_1.Autowired('gridOptionsWrapper'), 
	        __metadata('design:type', gridOptionsWrapper_1.GridOptionsWrapper)
	    ], MoveColumnController.prototype, "gridOptionsWrapper", void 0);
	    __decorate([
	        context_1.PostConstruct, 
	        __metadata('design:type', Function), 
	        __metadata('design:paramtypes', []), 
	        __metadata('design:returntype', void 0)
	    ], MoveColumnController.prototype, "init", null);
	    return MoveColumnController;
	})();
	exports.MoveColumnController = MoveColumnController;


/***/ },
/* 78 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
	 * @version v7.0.2
	 * @link http://www.ag-grid.com/
	 * @license MIT
	 */
	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var dragAndDropService_1 = __webpack_require__(68);
	var columnController_1 = __webpack_require__(13);
	var context_1 = __webpack_require__(6);
	var gridOptionsWrapper_1 = __webpack_require__(3);
	var BodyDropPivotTarget = (function () {
	    function BodyDropPivotTarget(pinned) {
	        this.columnsToAggregate = [];
	        this.columnsToGroup = [];
	        this.columnsToPivot = [];
	        this.pinned = pinned;
	    }
	    /** Callback for when drag enters */
	    BodyDropPivotTarget.prototype.onDragEnter = function (draggingEvent) {
	        var _this = this;
	        this.clearColumnsList();
	        // in pivot mode, we don't accept any drops if functions are read only
	        if (this.gridOptionsWrapper.isFunctionsReadOnly()) {
	            return;
	        }
	        var dragColumns = draggingEvent.dragSource.dragItem;
	        dragColumns.forEach(function (column) {
	            // we don't allow adding secondary columns
	            if (!column.isPrimary()) {
	                return;
	            }
	            if (column.isAnyFunctionActive()) {
	                return;
	            }
	            if (column.isAllowValue()) {
	                _this.columnsToAggregate.push(column);
	            }
	            else if (column.isAllowRowGroup()) {
	                _this.columnsToGroup.push(column);
	            }
	            else if (column.isAllowRowGroup()) {
	                _this.columnsToPivot.push(column);
	            }
	        });
	    };
	    BodyDropPivotTarget.prototype.getIconName = function () {
	        var totalColumns = this.columnsToAggregate.length + this.columnsToGroup.length + this.columnsToPivot.length;
	        if (totalColumns > 0) {
	            return this.pinned ? dragAndDropService_1.DragAndDropService.ICON_PINNED : dragAndDropService_1.DragAndDropService.ICON_MOVE;
	        }
	        else {
	            return null;
	        }
	    };
	    /** Callback for when drag leaves */
	    BodyDropPivotTarget.prototype.onDragLeave = function (draggingEvent) {
	        // if we are taking columns out of the center, then we remove them from the report
	        this.clearColumnsList();
	    };
	    BodyDropPivotTarget.prototype.clearColumnsList = function () {
	        this.columnsToAggregate.length = 0;
	        this.columnsToGroup.length = 0;
	        this.columnsToPivot.length = 0;
	    };
	    /** Callback for when dragging */
	    BodyDropPivotTarget.prototype.onDragging = function (draggingEvent) {
	    };
	    /** Callback for when drag stops */
	    BodyDropPivotTarget.prototype.onDragStop = function (draggingEvent) {
	        if (this.columnsToAggregate.length > 0) {
	            this.columnController.addValueColumns(this.columnsToAggregate);
	        }
	        if (this.columnsToGroup.length > 0) {
	            this.columnController.addRowGroupColumns(this.columnsToGroup);
	        }
	        if (this.columnsToPivot.length > 0) {
	            this.columnController.addPivotColumns(this.columnsToPivot);
	        }
	    };
	    __decorate([
	        context_1.Autowired('columnController'), 
	        __metadata('design:type', columnController_1.ColumnController)
	    ], BodyDropPivotTarget.prototype, "columnController", void 0);
	    __decorate([
	        context_1.Autowired('gridOptionsWrapper'), 
	        __metadata('design:type', gridOptionsWrapper_1.GridOptionsWrapper)
	    ], BodyDropPivotTarget.prototype, "gridOptionsWrapper", void 0);
	    return BodyDropPivotTarget;
	})();
	exports.BodyDropPivotTarget = BodyDropPivotTarget;


/***/ },
/* 79 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
	 * @version v7.0.2
	 * @link http://www.ag-grid.com/
	 * @license MIT
	 */
	var ColumnChangeEvent = (function () {
	    function ColumnChangeEvent(type) {
	        this.type = type;
	    }
	    ColumnChangeEvent.prototype.toString = function () {
	        var result = 'ColumnChangeEvent {type: ' + this.type;
	        if (this.column) {
	            result += ', column: ' + this.column.getColId();
	        }
	        if (this.columnGroup) {
	            result +=  true ? this.columnGroup.getColGroupDef().headerName : '(not defined]';
	        }
	        if (this.toIndex) {
	            result += ', toIndex: ' + this.toIndex;
	        }
	        if (this.visible) {
	            result += ', visible: ' + this.visible;
	        }
	        if (this.pinned) {
	            result += ', pinned: ' + this.pinned;
	        }
	        if (typeof this.finished == 'boolean') {
	            result += ', finished: ' + this.finished;
	        }
	        result += '}';
	        return result;
	    };
	    ColumnChangeEvent.prototype.withPinned = function (pinned) {
	        this.pinned = pinned;
	        return this;
	    };
	    ColumnChangeEvent.prototype.withVisible = function (visible) {
	        this.visible = visible;
	        return this;
	    };
	    ColumnChangeEvent.prototype.isVisible = function () {
	        return this.visible;
	    };
	    ColumnChangeEvent.prototype.getPinned = function () {
	        return this.pinned;
	    };
	    ColumnChangeEvent.prototype.withColumn = function (column) {
	        this.column = column;
	        return this;
	    };
	    ColumnChangeEvent.prototype.withColumns = function (columns) {
	        this.columns = columns;
	        return this;
	    };
	    ColumnChangeEvent.prototype.withFinished = function (finished) {
	        this.finished = finished;
	        return this;
	    };
	    ColumnChangeEvent.prototype.withColumnGroup = function (columnGroup) {
	        this.columnGroup = columnGroup;
	        return this;
	    };
	    ColumnChangeEvent.prototype.withToIndex = function (toIndex) {
	        this.toIndex = toIndex;
	        return this;
	    };
	    ColumnChangeEvent.prototype.getToIndex = function () {
	        return this.toIndex;
	    };
	    ColumnChangeEvent.prototype.getType = function () {
	        return this.type;
	    };
	    ColumnChangeEvent.prototype.getColumn = function () {
	        return this.column;
	    };
	    ColumnChangeEvent.prototype.getColumns = function () {
	        return this.columns;
	    };
	    ColumnChangeEvent.prototype.getColumnGroup = function () {
	        return this.columnGroup;
	    };
	    ColumnChangeEvent.prototype.isFinished = function () {
	        return this.finished;
	    };
	    return ColumnChangeEvent;
	})();
	exports.ColumnChangeEvent = ColumnChangeEvent;


/***/ },
/* 80 */
/***/ function(module, exports) {

	/**
	 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
	 * @version v7.0.2
	 * @link http://www.ag-grid.com/
	 * @license MIT
	 */
	// class returns unique instance id's for columns.
	// eg, the following calls (in this order) will result in:
	//
	// getInstanceIdForKey('country') => 0
	// getInstanceIdForKey('country') => 1
	// getInstanceIdForKey('country') => 2
	// getInstanceIdForKey('country') => 3
	// getInstanceIdForKey('age') => 0
	// getInstanceIdForKey('age') => 1
	// getInstanceIdForKey('country') => 4
	var GroupInstanceIdCreator = (function () {
	    function GroupInstanceIdCreator() {
	        // this map contains keys to numbers, so we remember what the last call was
	        this.existingIds = {};
	    }
	    GroupInstanceIdCreator.prototype.getInstanceIdForKey = function (key) {
	        var lastResult = this.existingIds[key];
	        var result;
	        if (typeof lastResult !== 'number') {
	            // first time this key
	            result = 0;
	        }
	        else {
	            result = lastResult + 1;
	        }
	        this.existingIds[key] = result;
	        return result;
	    };
	    return GroupInstanceIdCreator;
	})();
	exports.GroupInstanceIdCreator = GroupInstanceIdCreator;


/***/ },
/* 81 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
	 * @version v7.0.2
	 * @link http://www.ag-grid.com/
	 * @license MIT
	 */
	var utils_1 = __webpack_require__(7);
	function defaultGroupComparator(valueA, valueB, nodeA, nodeB) {
	    var nodeAIsGroup = utils_1.Utils.exists(nodeA) && nodeA.group;
	    var nodeBIsGroup = utils_1.Utils.exists(nodeB) && nodeB.group;
	    var bothAreGroups = nodeAIsGroup && nodeBIsGroup;
	    var bothAreNormal = !nodeAIsGroup && !nodeBIsGroup;
	    if (bothAreGroups) {
	        return utils_1.Utils.defaultComparator(nodeA.key, nodeB.key);
	    }
	    else if (bothAreNormal) {
	        return utils_1.Utils.defaultComparator(valueA, valueB);
	    }
	    else if (nodeAIsGroup) {
	        return 1;
	    }
	    else {
	        return -1;
	    }
	}
	exports.defaultGroupComparator = defaultGroupComparator;


/***/ },
/* 82 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
	 * @version v7.0.2
	 * @link http://www.ag-grid.com/
	 * @license MIT
	 */
	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var context_1 = __webpack_require__(6);
	var filterManager_1 = __webpack_require__(43);
	var utils_1 = __webpack_require__(7);
	var popupService_1 = __webpack_require__(44);
	var gridOptionsWrapper_1 = __webpack_require__(3);
	var eventService_1 = __webpack_require__(4);
	var StandardMenuFactory = (function () {
	    function StandardMenuFactory() {
	    }
	    StandardMenuFactory.prototype.showMenuAfterMouseEvent = function (column, mouseEvent) {
	        var _this = this;
	        this.showPopup(column, function (eMenu) {
	            _this.popupService.positionPopupUnderMouseEvent({
	                mouseEvent: mouseEvent,
	                ePopup: eMenu
	            });
	        });
	    };
	    StandardMenuFactory.prototype.showMenuAfterButtonClick = function (column, eventSource) {
	        var _this = this;
	        this.showPopup(column, function (eMenu) {
	            _this.popupService.positionPopupUnderComponent({ eventSource: eventSource, ePopup: eMenu, keepWithinBounds: true });
	        });
	    };
	    StandardMenuFactory.prototype.showPopup = function (column, positionCallback) {
	        var _this = this;
	        var filterWrapper = this.filterManager.getOrCreateFilterWrapper(column);
	        var eMenu = document.createElement('div');
	        utils_1.Utils.addCssClass(eMenu, 'ag-menu');
	        eMenu.appendChild(filterWrapper.gui);
	        var bodyScrollListener = function () {
	            hidePopup();
	        };
	        this.eventService.addEventListener('bodyScroll', bodyScrollListener);
	        var closedCallback = function () {
	            _this.eventService.removeEventListener('bodyScroll', bodyScrollListener);
	        };
	        // need to show filter before positioning, as only after filter
	        // is visible can we find out what the width of it is
	        var hidePopup = this.popupService.addAsModalPopup(eMenu, true, closedCallback);
	        positionCallback(eMenu);
	        if (filterWrapper.filter.afterGuiAttached) {
	            var params = {
	                hidePopup: hidePopup
	            };
	            filterWrapper.filter.afterGuiAttached(params);
	        }
	    };
	    StandardMenuFactory.prototype.isMenuEnabled = function (column) {
	        // for standard, we show menu if filter is enabled, and he menu is not suppressed
	        return this.gridOptionsWrapper.isEnableFilter() && column.isFilterAllowed();
	    };
	    __decorate([
	        context_1.Autowired('eventService'), 
	        __metadata('design:type', eventService_1.EventService)
	    ], StandardMenuFactory.prototype, "eventService", void 0);
	    __decorate([
	        context_1.Autowired('filterManager'), 
	        __metadata('design:type', filterManager_1.FilterManager)
	    ], StandardMenuFactory.prototype, "filterManager", void 0);
	    __decorate([
	        context_1.Autowired('popupService'), 
	        __metadata('design:type', popupService_1.PopupService)
	    ], StandardMenuFactory.prototype, "popupService", void 0);
	    __decorate([
	        context_1.Autowired('gridOptionsWrapper'), 
	        __metadata('design:type', gridOptionsWrapper_1.GridOptionsWrapper)
	    ], StandardMenuFactory.prototype, "gridOptionsWrapper", void 0);
	    StandardMenuFactory = __decorate([
	        context_1.Bean('menuFactory'), 
	        __metadata('design:paramtypes', [])
	    ], StandardMenuFactory);
	    return StandardMenuFactory;
	})();
	exports.StandardMenuFactory = StandardMenuFactory;


/***/ },
/* 83 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
	 * @version v7.0.2
	 * @link http://www.ag-grid.com/
	 * @license MIT
	 */
	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var context_1 = __webpack_require__(6);
	var context_2 = __webpack_require__(6);
	var gridOptionsWrapper_1 = __webpack_require__(3);
	var filterManager_1 = __webpack_require__(43);
	var FilterStage = (function () {
	    function FilterStage() {
	    }
	    FilterStage.prototype.execute = function (rowNode) {
	        var filterActive;
	        if (this.gridOptionsWrapper.isEnableServerSideFilter()) {
	            filterActive = false;
	        }
	        else {
	            filterActive = this.filterManager.isAnyFilterPresent();
	        }
	        this.recursivelyFilter(rowNode, filterActive);
	    };
	    FilterStage.prototype.recursivelyFilter = function (rowNode, filterActive) {
	        var _this = this;
	        // recursively get all children that are groups to also filter
	        rowNode.childrenAfterGroup.forEach(function (child) {
	            if (child.group) {
	                _this.recursivelyFilter(child, filterActive);
	            }
	        });
	        // result of filter for this node
	        var filterResult;
	        if (filterActive) {
	            filterResult = [];
	            rowNode.childrenAfterGroup.forEach(function (childNode) {
	                if (childNode.group) {
	                    // a group is included in the result if it has any children of it's own.
	                    // by this stage, the child groups are already filtered
	                    if (childNode.childrenAfterFilter.length > 0) {
	                        filterResult.push(childNode);
	                    }
	                }
	                else {
	                    // a leaf level node is included if it passes the filter
	                    if (_this.filterManager.doesRowPassFilter(childNode)) {
	                        filterResult.push(childNode);
	                    }
	                }
	            });
	        }
	        else {
	            // if not filtering, the result is the original list
	            filterResult = rowNode.childrenAfterGroup;
	        }
	        rowNode.childrenAfterFilter = filterResult;
	        this.setAllChildrenCount(rowNode);
	    };
	    FilterStage.prototype.setAllChildrenCount = function (rowNode) {
	        var allChildrenCount = 0;
	        rowNode.childrenAfterFilter.forEach(function (child) {
	            if (child.group) {
	                allChildrenCount += child.allChildrenCount;
	            }
	            else {
	                allChildrenCount++;
	            }
	        });
	        rowNode.allChildrenCount = allChildrenCount;
	    };
	    __decorate([
	        context_2.Autowired('gridOptionsWrapper'), 
	        __metadata('design:type', gridOptionsWrapper_1.GridOptionsWrapper)
	    ], FilterStage.prototype, "gridOptionsWrapper", void 0);
	    __decorate([
	        context_2.Autowired('filterManager'), 
	        __metadata('design:type', filterManager_1.FilterManager)
	    ], FilterStage.prototype, "filterManager", void 0);
	    FilterStage = __decorate([
	        context_1.Bean('filterStage'), 
	        __metadata('design:paramtypes', [])
	    ], FilterStage);
	    return FilterStage;
	})();
	exports.FilterStage = FilterStage;


/***/ },
/* 84 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
	 * @version v7.0.2
	 * @link http://www.ag-grid.com/
	 * @license MIT
	 */
	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var context_1 = __webpack_require__(6);
	var gridOptionsWrapper_1 = __webpack_require__(3);
	var sortController_1 = __webpack_require__(42);
	var valueService_1 = __webpack_require__(29);
	var utils_1 = __webpack_require__(7);
	var SortStage = (function () {
	    function SortStage() {
	    }
	    SortStage.prototype.execute = function (rowNode) {
	        var sortOptions;
	        // if the sorting is already done by the server, then we should not do it here
	        if (!this.gridOptionsWrapper.isEnableServerSideSorting()) {
	            sortOptions = this.sortController.getSortForRowController();
	        }
	        this.sortRowNode(rowNode, sortOptions);
	    };
	    SortStage.prototype.sortRowNode = function (rowNode, sortOptions) {
	        var _this = this;
	        // sort any groups recursively
	        rowNode.childrenAfterFilter.forEach(function (child) {
	            if (child.group) {
	                _this.sortRowNode(child, sortOptions);
	            }
	        });
	        rowNode.childrenAfterSort = rowNode.childrenAfterFilter.slice(0);
	        var sortActive = utils_1.Utils.exists(sortOptions) && sortOptions.length > 0;
	        if (sortActive) {
	            rowNode.childrenAfterSort.sort(this.compareRowNodes.bind(this, sortOptions));
	        }
	        this.updateChildIndexes(rowNode);
	    };
	    SortStage.prototype.compareRowNodes = function (sortOptions, nodeA, nodeB) {
	        // Iterate columns, return the first that doesn't match
	        for (var i = 0, len = sortOptions.length; i < len; i++) {
	            var sortOption = sortOptions[i];
	            // var compared = compare(nodeA, nodeB, sortOption.column, sortOption.inverter === -1);
	            var isInverted = sortOption.inverter === -1;
	            var valueA = this.valueService.getValue(sortOption.column, nodeA);
	            var valueB = this.valueService.getValue(sortOption.column, nodeB);
	            var comparatorResult;
	            if (sortOption.column.getColDef().comparator) {
	                //if comparator provided, use it
	                comparatorResult = sortOption.column.getColDef().comparator(valueA, valueB, nodeA, nodeB, isInverted);
	            }
	            else {
	                //otherwise do our own comparison
	                comparatorResult = utils_1.Utils.defaultComparator(valueA, valueB);
	            }
	            if (comparatorResult !== 0) {
	                return comparatorResult * sortOption.inverter;
	            }
	        }
	        // All matched, these are identical as far as the sort is concerned:
	        return 0;
	    };
	    SortStage.prototype.updateChildIndexes = function (rowNode) {
	        if (utils_1.Utils.missing(rowNode.childrenAfterSort)) {
	            return;
	        }
	        rowNode.childrenAfterSort.forEach(function (child, index) {
	            child.firstChild = index === 0;
	            child.lastChild = index === rowNode.childrenAfterSort.length - 1;
	            child.childIndex = index;
	        });
	    };
	    __decorate([
	        context_1.Autowired('gridOptionsWrapper'), 
	        __metadata('design:type', gridOptionsWrapper_1.GridOptionsWrapper)
	    ], SortStage.prototype, "gridOptionsWrapper", void 0);
	    __decorate([
	        context_1.Autowired('sortController'), 
	        __metadata('design:type', sortController_1.SortController)
	    ], SortStage.prototype, "sortController", void 0);
	    __decorate([
	        context_1.Autowired('valueService'), 
	        __metadata('design:type', valueService_1.ValueService)
	    ], SortStage.prototype, "valueService", void 0);
	    SortStage = __decorate([
	        context_1.Bean('sortStage'), 
	        __metadata('design:paramtypes', [])
	    ], SortStage);
	    return SortStage;
	})();
	exports.SortStage = SortStage;


/***/ },
/* 85 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
	 * @version v7.0.2
	 * @link http://www.ag-grid.com/
	 * @license MIT
	 */
	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var context_1 = __webpack_require__(6);
	var rowNode_1 = __webpack_require__(27);
	var utils_1 = __webpack_require__(7);
	var gridOptionsWrapper_1 = __webpack_require__(3);
	var selectionController_1 = __webpack_require__(28);
	var eventService_1 = __webpack_require__(4);
	var columnController_1 = __webpack_require__(13);
	var FlattenStage = (function () {
	    function FlattenStage() {
	    }
	    FlattenStage.prototype.execute = function (rootNode) {
	        // even if not doing grouping, we do the mapping, as the client might
	        // of passed in data that already has a grouping in it somewhere
	        var result = [];
	        // putting value into a wrapper so it's passed by reference
	        var nextRowTop = { value: 0 };
	        var pivotMode = this.columnController.isPivotMode();
	        // if we are reducing, and not grouping, then we want to show the root node, as that
	        // is where the pivot values are
	        var showRootNode = pivotMode && rootNode.leafGroup;
	        var topList = showRootNode ? [rootNode] : rootNode.childrenAfterSort;
	        // set all row tops to null, then set row tops on all visible rows. if we don't
	        // do this, then the algorithm below only sets row tops, old row tops from old rows
	        // will still lie around
	        this.resetRowTops(rootNode);
	        this.recursivelyAddToRowsToDisplay(topList, result, nextRowTop, pivotMode);
	        return result;
	    };
	    FlattenStage.prototype.resetRowTops = function (rowNode) {
	        rowNode.clearRowTop();
	        if (rowNode.group) {
	            if (rowNode.childrenAfterGroup) {
	                for (var i = 0; i < rowNode.childrenAfterGroup.length; i++) {
	                    this.resetRowTops(rowNode.childrenAfterGroup[i]);
	                }
	            }
	            if (rowNode.sibling) {
	                rowNode.sibling.clearRowTop();
	            }
	        }
	    };
	    FlattenStage.prototype.recursivelyAddToRowsToDisplay = function (rowsToFlatten, result, nextRowTop, reduce) {
	        if (utils_1.Utils.missingOrEmpty(rowsToFlatten)) {
	            return;
	        }
	        var groupSuppressRow = this.gridOptionsWrapper.isGroupSuppressRow();
	        for (var i = 0; i < rowsToFlatten.length; i++) {
	            var rowNode = rowsToFlatten[i];
	            var skipBecauseSuppressRow = groupSuppressRow && rowNode.group;
	            var skipBecauseReduce = reduce && !rowNode.group;
	            var skipGroupNode = skipBecauseReduce || skipBecauseSuppressRow;
	            if (!skipGroupNode) {
	                this.addRowNodeToRowsToDisplay(rowNode, result, nextRowTop);
	            }
	            if (rowNode.group) {
	                if (rowNode.expanded) {
	                    this.recursivelyAddToRowsToDisplay(rowNode.childrenAfterSort, result, nextRowTop, reduce);
	                    // put a footer in if user is looking for it
	                    if (this.gridOptionsWrapper.isGroupIncludeFooter()) {
	                        this.ensureFooterNodeExists(rowNode);
	                        this.addRowNodeToRowsToDisplay(rowNode.sibling, result, nextRowTop);
	                    }
	                }
	            }
	            if (rowNode.canFlower && rowNode.expanded) {
	                var flowerNode = this.createFlowerNode(rowNode);
	                this.addRowNodeToRowsToDisplay(flowerNode, result, nextRowTop);
	            }
	        }
	    };
	    // duplicated method, it's also in floatingRowModel
	    FlattenStage.prototype.addRowNodeToRowsToDisplay = function (rowNode, result, nextRowTop) {
	        result.push(rowNode);
	        if (utils_1.Utils.missing(rowNode.rowHeight)) {
	            var rowHeight = this.gridOptionsWrapper.getRowHeightForNode(rowNode);
	            rowNode.setRowHeight(rowHeight);
	        }
	        rowNode.setRowTop(nextRowTop.value);
	        rowNode.setRowIndex(result.length - 1);
	        nextRowTop.value += rowNode.rowHeight;
	    };
	    FlattenStage.prototype.ensureFooterNodeExists = function (groupNode) {
	        // only create footer node once, otherwise we have daemons and
	        // the animate screws up with the daemons hanging around
	        if (utils_1.Utils.exists(groupNode.sibling)) {
	            return;
	        }
	        var footerNode = new rowNode_1.RowNode();
	        this.context.wireBean(footerNode);
	        Object.keys(groupNode).forEach(function (key) {
	            footerNode[key] = groupNode[key];
	        });
	        footerNode.footer = true;
	        footerNode.rowTop = null;
	        footerNode.oldRowTop = null;
	        if (utils_1.Utils.exists(footerNode.id)) {
	            footerNode.id = 'rowGroupFooter_' + footerNode.id;
	        }
	        // get both header and footer to reference each other as siblings. this is never undone,
	        // only overwritten. so if a group is expanded, then contracted, it will have a ghost
	        // sibling - but that's fine, as we can ignore this if the header is contracted.
	        footerNode.sibling = groupNode;
	        groupNode.sibling = footerNode;
	    };
	    FlattenStage.prototype.createFlowerNode = function (parentNode) {
	        if (utils_1.Utils.exists(parentNode.childFlower)) {
	            return parentNode.childFlower;
	        }
	        else {
	            var flowerNode = new rowNode_1.RowNode();
	            this.context.wireBean(flowerNode);
	            flowerNode.flower = true;
	            flowerNode.parent = parentNode;
	            if (utils_1.Utils.exists(parentNode.id)) {
	                flowerNode.id = 'flowerNode_' + parentNode.id;
	            }
	            flowerNode.data = parentNode.data;
	            flowerNode.level = parentNode.level + 1;
	            parentNode.childFlower = flowerNode;
	            return flowerNode;
	        }
	    };
	    __decorate([
	        context_1.Autowired('gridOptionsWrapper'), 
	        __metadata('design:type', gridOptionsWrapper_1.GridOptionsWrapper)
	    ], FlattenStage.prototype, "gridOptionsWrapper", void 0);
	    __decorate([
	        context_1.Autowired('selectionController'), 
	        __metadata('design:type', selectionController_1.SelectionController)
	    ], FlattenStage.prototype, "selectionController", void 0);
	    __decorate([
	        context_1.Autowired('eventService'), 
	        __metadata('design:type', eventService_1.EventService)
	    ], FlattenStage.prototype, "eventService", void 0);
	    __decorate([
	        context_1.Autowired('context'), 
	        __metadata('design:type', context_1.Context)
	    ], FlattenStage.prototype, "context", void 0);
	    __decorate([
	        context_1.Autowired('columnController'), 
	        __metadata('design:type', columnController_1.ColumnController)
	    ], FlattenStage.prototype, "columnController", void 0);
	    FlattenStage = __decorate([
	        context_1.Bean('flattenStage'), 
	        __metadata('design:paramtypes', [])
	    ], FlattenStage);
	    return FlattenStage;
	})();
	exports.FlattenStage = FlattenStage;


/***/ },
/* 86 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
	 * @version v7.0.2
	 * @link http://www.ag-grid.com/
	 * @license MIT
	 */
	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var utils_1 = __webpack_require__(7);
	var gridOptionsWrapper_1 = __webpack_require__(3);
	var context_1 = __webpack_require__(6);
	var eventService_1 = __webpack_require__(4);
	var selectionController_1 = __webpack_require__(28);
	var events_1 = __webpack_require__(10);
	var sortController_1 = __webpack_require__(42);
	var filterManager_1 = __webpack_require__(43);
	var constants_1 = __webpack_require__(8);
	var virtualPageCache_1 = __webpack_require__(87);
	var VirtualPageRowModel = (function () {
	    function VirtualPageRowModel() {
	        this.destroyFunctions = [];
	    }
	    VirtualPageRowModel.prototype.init = function () {
	        if (!this.gridOptionsWrapper.isRowModelVirtual()) {
	            return;
	        }
	        this.addEventListeners();
	        this.setDatasource(this.gridOptionsWrapper.getDatasource());
	    };
	    VirtualPageRowModel.prototype.addEventListeners = function () {
	        var _this = this;
	        var onSortChangedListener = this.onSortChanged.bind(this);
	        var onFilterChangedListener = this.onFilterChanged.bind(this);
	        this.eventService.addEventListener(events_1.Events.EVENT_FILTER_CHANGED, onFilterChangedListener);
	        this.eventService.addEventListener(events_1.Events.EVENT_SORT_CHANGED, onSortChangedListener);
	        this.destroyFunctions.push(function () {
	            _this.eventService.removeEventListener(events_1.Events.EVENT_FILTER_CHANGED, onFilterChangedListener);
	            _this.eventService.removeEventListener(events_1.Events.EVENT_SORT_CHANGED, onSortChangedListener);
	        });
	    };
	    VirtualPageRowModel.prototype.onFilterChanged = function () {
	        if (this.gridOptionsWrapper.isEnableServerSideFilter()) {
	            this.reset();
	        }
	    };
	    VirtualPageRowModel.prototype.onSortChanged = function () {
	        if (this.gridOptionsWrapper.isEnableServerSideSorting()) {
	            this.reset();
	        }
	    };
	    VirtualPageRowModel.prototype.destroy = function () {
	        this.destroyFunctions.forEach(function (func) { return func(); });
	    };
	    VirtualPageRowModel.prototype.getType = function () {
	        return constants_1.Constants.ROW_MODEL_TYPE_VIRTUAL;
	    };
	    VirtualPageRowModel.prototype.setDatasource = function (datasource) {
	        this.datasource = datasource;
	        // only reset if we have a valid datasource to working with
	        if (datasource) {
	            this.checkForDeprecated();
	            this.reset();
	        }
	    };
	    VirtualPageRowModel.prototype.checkForDeprecated = function () {
	        var ds = this.datasource;
	        // the number of concurrent loads we are allowed to the server
	        if (utils_1.Utils.exists(ds.maxConcurrentRequests)) {
	            console.error('ag-Grid: since version 5.1.x, maxConcurrentRequests is replaced with grid property maxConcurrentDatasourceRequests');
	        }
	        if (utils_1.Utils.exists(ds.maxPagesInCache)) {
	            console.error('ag-Grid: since version 5.1.x, maxPagesInCache is replaced with grid property maxPagesInPaginationCache');
	        }
	        if (utils_1.Utils.exists(ds.overflowSize)) {
	            console.error('ag-Grid: since version 5.1.x, overflowSize is replaced with grid property paginationOverflowSize');
	        }
	        if (utils_1.Utils.exists(ds.pageSize)) {
	            console.error('ag-Grid: since version 5.1.x, pageSize is replaced with grid property paginationPageSize');
	        }
	    };
	    VirtualPageRowModel.prototype.isEmpty = function () {
	        return utils_1.Utils.missing(this.virtualPageCache);
	    };
	    VirtualPageRowModel.prototype.isRowsToRender = function () {
	        return utils_1.Utils.exists(this.virtualPageCache);
	    };
	    VirtualPageRowModel.prototype.reset = function () {
	        // important to return here, as the user could be setting filter or sort before
	        // data-source is set
	        if (utils_1.Utils.missing(this.datasource)) {
	            return;
	        }
	        // if user is providing id's, then this means we can keep the selection between datsource hits,
	        // as the rows will keep their unique id's even if, for example, server side sorting or filtering
	        // is done.
	        var userGeneratingRows = utils_1.Utils.exists(this.gridOptionsWrapper.getRowNodeIdFunc());
	        if (!userGeneratingRows) {
	            this.selectionController.reset();
	        }
	        this.resetCache();
	        this.eventService.dispatchEvent(events_1.Events.EVENT_MODEL_UPDATED);
	    };
	    VirtualPageRowModel.prototype.resetCache = function () {
	        var cacheSettings = {
	            // the user provided datasource
	            datasource: this.datasource,
	            // sort and filter model
	            filterModel: this.filterManager.getFilterModel(),
	            sortModel: this.sortController.getSortModel(),
	            // properties - this way we take a snapshot of them, so if user changes any, they will be
	            // used next time we create a new cache, which is generally after a filter or sort change,
	            // or a new datasource is set
	            maxConcurrentDatasourceRequests: this.gridOptionsWrapper.getMaxConcurrentDatasourceRequests(),
	            paginationOverflowSize: this.gridOptionsWrapper.getPaginationOverflowSize(),
	            paginationInitialRowCount: this.gridOptionsWrapper.getPaginationInitialRowCount(),
	            maxPagesInCache: this.gridOptionsWrapper.getMaxPagesInCache(),
	            pageSize: this.gridOptionsWrapper.getPaginationPageSize(),
	            rowHeight: this.gridOptionsWrapper.getRowHeightAsNumber(),
	            // the cache could create this, however it is also used by the pages, so handy to create it
	            // here as the settings are also passed to the pages
	            lastAccessedSequence: new utils_1.NumberSequence()
	        };
	        // set defaults
	        if (!(cacheSettings.maxConcurrentDatasourceRequests >= 1)) {
	            cacheSettings.maxConcurrentDatasourceRequests = 2;
	        }
	        // page size needs to be 1 or greater. having it at 1 would be silly, as you would be hitting the
	        // server for one page at a time. so the default if not specified is 100.
	        if (!(cacheSettings.pageSize >= 1)) {
	            cacheSettings.pageSize = 100;
	        }
	        // if user doesn't give initial rows to display, we assume zero
	        if (!(cacheSettings.paginationInitialRowCount >= 1)) {
	            cacheSettings.paginationInitialRowCount = 0;
	        }
	        // if user doesn't provide overflow, we use default overflow of 1, so user can scroll past
	        // the current page and request first row of next page
	        if (!(cacheSettings.paginationOverflowSize >= 1)) {
	            cacheSettings.paginationOverflowSize = 1;
	        }
	        // if not first time creating a cache, need to destroy the old one
	        if (this.virtualPageCache) {
	            this.virtualPageCache.destroy();
	        }
	        this.virtualPageCache = new virtualPageCache_1.VirtualPageCache(cacheSettings);
	        this.context.wireBean(this.virtualPageCache);
	    };
	    VirtualPageRowModel.prototype.getRow = function (rowIndex) {
	        return this.virtualPageCache ? this.virtualPageCache.getRow(rowIndex) : null;
	    };
	    VirtualPageRowModel.prototype.forEachNode = function (callback) {
	        if (this.virtualPageCache) {
	            this.virtualPageCache.forEachNode(callback);
	        }
	    };
	    VirtualPageRowModel.prototype.getRowCombinedHeight = function () {
	        return this.virtualPageCache ? this.virtualPageCache.getRowCombinedHeight() : 0;
	    };
	    VirtualPageRowModel.prototype.getRowIndexAtPixel = function (pixel) {
	        return this.virtualPageCache ? this.virtualPageCache.getRowIndexAtPixel(pixel) : -1;
	    };
	    VirtualPageRowModel.prototype.getRowCount = function () {
	        return this.virtualPageCache ? this.virtualPageCache.getRowCount() : 0;
	    };
	    VirtualPageRowModel.prototype.insertItemsAtIndex = function (index, items) {
	        if (this.virtualPageCache) {
	            this.virtualPageCache.insertItemsAtIndex(index, items);
	        }
	    };
	    VirtualPageRowModel.prototype.removeItems = function (rowNodes) {
	        console.log('ag-Grid: it is not possible to removeItems when using virtual pagination. Instead use the ' +
	            'API to refresh the cache');
	    };
	    VirtualPageRowModel.prototype.addItems = function (items) {
	        console.log('ag-Grid: it is not possible to add items when using virtual pagination as the grid does not ' +
	            'know that last index of your data - instead either use insertItemsAtIndex OR refresh the cache.');
	    };
	    VirtualPageRowModel.prototype.refreshVirtualPageCache = function () {
	        if (this.virtualPageCache) {
	            this.virtualPageCache.refreshVirtualPageCache();
	        }
	    };
	    VirtualPageRowModel.prototype.purgeVirtualPageCache = function () {
	        if (this.virtualPageCache) {
	            this.virtualPageCache.purgeVirtualPageCache();
	        }
	    };
	    VirtualPageRowModel.prototype.getVirtualRowCount = function () {
	        if (this.virtualPageCache) {
	            return this.virtualPageCache.getVirtualRowCount();
	        }
	        else {
	            return null;
	        }
	    };
	    VirtualPageRowModel.prototype.isMaxRowFound = function () {
	        if (this.virtualPageCache) {
	            return this.virtualPageCache.isMaxRowFound();
	        }
	    };
	    VirtualPageRowModel.prototype.setVirtualRowCount = function (rowCount, maxRowFound) {
	        if (this.virtualPageCache) {
	            this.virtualPageCache.setVirtualRowCount(rowCount, maxRowFound);
	        }
	    };
	    VirtualPageRowModel.prototype.getVirtualPageState = function () {
	        if (this.virtualPageCache) {
	            return this.virtualPageCache.getPageState();
	        }
	        else {
	            return null;
	        }
	    };
	    __decorate([
	        context_1.Autowired('gridOptionsWrapper'), 
	        __metadata('design:type', gridOptionsWrapper_1.GridOptionsWrapper)
	    ], VirtualPageRowModel.prototype, "gridOptionsWrapper", void 0);
	    __decorate([
	        context_1.Autowired('filterManager'), 
	        __metadata('design:type', filterManager_1.FilterManager)
	    ], VirtualPageRowModel.prototype, "filterManager", void 0);
	    __decorate([
	        context_1.Autowired('sortController'), 
	        __metadata('design:type', sortController_1.SortController)
	    ], VirtualPageRowModel.prototype, "sortController", void 0);
	    __decorate([
	        context_1.Autowired('selectionController'), 
	        __metadata('design:type', selectionController_1.SelectionController)
	    ], VirtualPageRowModel.prototype, "selectionController", void 0);
	    __decorate([
	        context_1.Autowired('eventService'), 
	        __metadata('design:type', eventService_1.EventService)
	    ], VirtualPageRowModel.prototype, "eventService", void 0);
	    __decorate([
	        context_1.Autowired('context'), 
	        __metadata('design:type', context_1.Context)
	    ], VirtualPageRowModel.prototype, "context", void 0);
	    __decorate([
	        context_1.PostConstruct, 
	        __metadata('design:type', Function), 
	        __metadata('design:paramtypes', []), 
	        __metadata('design:returntype', void 0)
	    ], VirtualPageRowModel.prototype, "init", null);
	    __decorate([
	        context_1.PreDestroy, 
	        __metadata('design:type', Function), 
	        __metadata('design:paramtypes', []), 
	        __metadata('design:returntype', void 0)
	    ], VirtualPageRowModel.prototype, "destroy", null);
	    VirtualPageRowModel = __decorate([
	        context_1.Bean('rowModel'), 
	        __metadata('design:paramtypes', [])
	    ], VirtualPageRowModel);
	    return VirtualPageRowModel;
	})();
	exports.VirtualPageRowModel = VirtualPageRowModel;


/***/ },
/* 87 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
	 * @version v7.0.2
	 * @link http://www.ag-grid.com/
	 * @license MIT
	 */
	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var __param = (this && this.__param) || function (paramIndex, decorator) {
	    return function (target, key) { decorator(target, key, paramIndex); }
	};
	var utils_1 = __webpack_require__(7);
	var context_1 = __webpack_require__(6);
	var eventService_1 = __webpack_require__(4);
	var events_1 = __webpack_require__(10);
	var logger_1 = __webpack_require__(5);
	var virtualPage_1 = __webpack_require__(88);
	var VirtualPageCache = (function () {
	    function VirtualPageCache(cacheSettings) {
	        this.pages = {};
	        this.activePageLoadsCount = 0;
	        this.pagesInCacheCount = 0;
	        this.maxRowFound = false;
	        this.active = true;
	        this.cacheParams = cacheSettings;
	        this.virtualRowCount = cacheSettings.paginationInitialRowCount;
	    }
	    VirtualPageCache.prototype.setBeans = function (loggerFactory) {
	        this.logger = loggerFactory.create('VirtualPageCache');
	    };
	    VirtualPageCache.prototype.init = function () {
	        // start load of data, as the virtualRowCount will remain at 0 otherwise,
	        // so we need this to kick things off, otherwise grid would never call getRow()
	        this.getRow(0);
	    };
	    VirtualPageCache.prototype.getRowCombinedHeight = function () {
	        return this.virtualRowCount * this.cacheParams.rowHeight;
	    };
	    VirtualPageCache.prototype.forEachNode = function (callback) {
	        var _this = this;
	        var index = 0;
	        utils_1.Utils.iterateObject(this.pages, function (key, cachePage) {
	            var start = cachePage.getStartRow();
	            var end = cachePage.getEndRow();
	            for (var rowIndex = start; rowIndex < end; rowIndex++) {
	                // we check against virtualRowCount as this page may be the last one, and if it is, then
	                // it's probable that the last rows are not part of the set
	                if (rowIndex < _this.virtualRowCount) {
	                    var rowNode = cachePage.getRow(rowIndex);
	                    callback(rowNode, index);
	                    index++;
	                }
	            }
	        });
	    };
	    VirtualPageCache.prototype.getRowIndexAtPixel = function (pixel) {
	        if (this.cacheParams.rowHeight !== 0) {
	            var rowIndexForPixel = Math.floor(pixel / this.cacheParams.rowHeight);
	            if (rowIndexForPixel >= this.virtualRowCount) {
	                return this.virtualRowCount - 1;
	            }
	            else {
	                return rowIndexForPixel;
	            }
	        }
	        else {
	            return 0;
	        }
	    };
	    VirtualPageCache.prototype.moveItemsDown = function (page, moveFromIndex, moveCount) {
	        var startRow = page.getStartRow();
	        var endRow = page.getEndRow();
	        var indexOfLastRowToMove = moveFromIndex + moveCount;
	        // all rows need to be moved down below the insertion index
	        for (var currentRowIndex = endRow - 1; currentRowIndex >= startRow; currentRowIndex--) {
	            // don't move rows at or before the insertion index
	            if (currentRowIndex < indexOfLastRowToMove) {
	                continue;
	            }
	            var indexOfNodeWeWant = currentRowIndex - moveCount;
	            var nodeForThisIndex = this.getRow(indexOfNodeWeWant, true);
	            if (nodeForThisIndex) {
	                page.setRowNode(currentRowIndex, nodeForThisIndex);
	            }
	            else {
	                page.setBlankRowNode(currentRowIndex);
	                page.setDirty();
	            }
	        }
	    };
	    VirtualPageCache.prototype.insertItems = function (page, indexToInsert, items) {
	        var pageStartRow = page.getStartRow();
	        var pageEndRow = page.getEndRow();
	        var newRowNodes = [];
	        // next stage is insert the rows into this page, if applicable
	        for (var index = 0; index < items.length; index++) {
	            var rowIndex = indexToInsert + index;
	            var currentRowInThisPage = rowIndex >= pageStartRow && rowIndex < pageEndRow;
	            if (currentRowInThisPage) {
	                var dataItem = items[index];
	                var newRowNode = page.setNewData(rowIndex, dataItem);
	                newRowNodes.push(newRowNode);
	            }
	        }
	        return newRowNodes;
	    };
	    VirtualPageCache.prototype.insertItemsAtIndex = function (indexToInsert, items) {
	        var _this = this;
	        // get all page id's as NUMBERS (not strings, as we need to sort as numbers) and in descending order
	        var pageIds = Object.keys(this.pages).map(function (str) { return parseInt(str); }).sort().reverse();
	        var newNodes = [];
	        pageIds.forEach(function (pageId) {
	            var page = _this.pages[pageId];
	            var pageEndRow = page.getEndRow();
	            // if the insertion is after this page, then this page is not impacted
	            if (pageEndRow <= indexToInsert) {
	                return;
	            }
	            _this.moveItemsDown(page, indexToInsert, items.length);
	            var newNodesThisPage = _this.insertItems(page, indexToInsert, items);
	            newNodesThisPage.forEach(function (rowNode) { return newNodes.push(rowNode); });
	        });
	        if (this.maxRowFound) {
	            this.virtualRowCount += items.length;
	        }
	        this.dispatchModelUpdated();
	        this.eventService.dispatchEvent(events_1.Events.EVENT_ITEMS_ADDED, newNodes);
	    };
	    VirtualPageCache.prototype.getRowCount = function () {
	        return this.virtualRowCount;
	    };
	    VirtualPageCache.prototype.onPageLoaded = function (event) {
	        // if we are not active, then we ignore all events, otherwise we could end up getting the
	        // grid to refresh even though we are no longer the active cache
	        if (!this.active) {
	            return;
	        }
	        this.logger.log("onPageLoaded: page = " + event.page.getPageNumber() + ", lastRow = " + event.lastRow);
	        this.activePageLoadsCount--;
	        this.checkPageToLoad();
	        if (event.success) {
	            this.checkVirtualRowCount(event.page, event.lastRow);
	        }
	    };
	    // as we are not a context managed bean, we cannot use @PreDestroy
	    VirtualPageCache.prototype.destroy = function () {
	        this.active = false;
	    };
	    // the rowRenderer will not pass dontCreatePage, meaning when rendering the grid,
	    // it will want new pages in teh cache as it asks for rows. only when we are inserting /
	    // removing rows via the api is dontCreatePage set, where we move rows between the pages.
	    VirtualPageCache.prototype.getRow = function (rowIndex, dontCreatePage) {
	        if (dontCreatePage === void 0) { dontCreatePage = false; }
	        var pageNumber = Math.floor(rowIndex / this.cacheParams.pageSize);
	        var page = this.pages[pageNumber];
	        if (!page) {
	            if (dontCreatePage) {
	                return null;
	            }
	            else {
	                page = this.createPage(pageNumber);
	            }
	        }
	        return page.getRow(rowIndex);
	    };
	    VirtualPageCache.prototype.createPage = function (pageNumber) {
	        var newPage = new virtualPage_1.VirtualPage(pageNumber, this.cacheParams);
	        this.context.wireBean(newPage);
	        newPage.addEventListener(virtualPage_1.VirtualPage.EVENT_LOAD_COMPLETE, this.onPageLoaded.bind(this));
	        this.pages[pageNumber] = newPage;
	        this.pagesInCacheCount++;
	        var needToPurge = utils_1.Utils.exists(this.cacheParams.maxPagesInCache)
	            && this.pagesInCacheCount > this.cacheParams.maxPagesInCache;
	        if (needToPurge) {
	            var lruPage = this.findLeastRecentlyUsedPage(newPage);
	            this.removePageFromCache(lruPage);
	        }
	        this.checkPageToLoad();
	        return newPage;
	    };
	    VirtualPageCache.prototype.removePageFromCache = function (pageToRemove) {
	        if (!pageToRemove) {
	            return;
	        }
	        delete this.pages[pageToRemove.getPageNumber()];
	        this.pagesInCacheCount--;
	        // we do not want to remove the 'loaded' event listener, as the
	        // concurrent loads count needs to be updated when the load is complete
	        // if the purged page is in loading state
	    };
	    VirtualPageCache.prototype.printCacheStatus = function () {
	        this.logger.log("checkPageToLoad: activePageLoadsCount = " + this.activePageLoadsCount + ", pages = " + JSON.stringify(this.getPageState()));
	    };
	    VirtualPageCache.prototype.checkPageToLoad = function () {
	        this.printCacheStatus();
	        if (this.activePageLoadsCount >= this.cacheParams.maxConcurrentDatasourceRequests) {
	            this.logger.log("checkPageToLoad: max loads exceeded");
	            return;
	        }
	        var pageToLoad = null;
	        utils_1.Utils.iterateObject(this.pages, function (key, cachePage) {
	            if (cachePage.getState() === virtualPage_1.VirtualPage.STATE_DIRTY) {
	                pageToLoad = cachePage;
	            }
	        });
	        if (pageToLoad) {
	            pageToLoad.load();
	            this.activePageLoadsCount++;
	            this.logger.log("checkPageToLoad: loading page " + pageToLoad.getPageNumber());
	            this.printCacheStatus();
	        }
	        else {
	            this.logger.log("checkPageToLoad: no pages to load");
	        }
	    };
	    VirtualPageCache.prototype.findLeastRecentlyUsedPage = function (pageToExclude) {
	        var lruPage = null;
	        utils_1.Utils.iterateObject(this.pages, function (key, page) {
	            // we exclude checking for the page just created, as this has yet to be accessed and hence
	            // the lastAccessed stamp will not be updated for the first time yet
	            if (page === pageToExclude) {
	                return;
	            }
	            if (utils_1.Utils.missing(lruPage) || page.getLastAccessed() < lruPage.getLastAccessed()) {
	                lruPage = page;
	            }
	        });
	        return lruPage;
	    };
	    VirtualPageCache.prototype.checkVirtualRowCount = function (page, lastRow) {
	        // if client provided a last row, we always use it, as it could change between server calls
	        // if user deleted data and then called refresh on the grid.
	        if (typeof lastRow === 'number' && lastRow >= 0) {
	            this.virtualRowCount = lastRow;
	            this.maxRowFound = true;
	            this.dispatchModelUpdated();
	        }
	        else if (!this.maxRowFound) {
	            // otherwise, see if we need to add some virtual rows
	            var lastRowIndex = (page.getPageNumber() + 1) * this.cacheParams.pageSize;
	            var lastRowIndexPlusOverflow = lastRowIndex + this.cacheParams.paginationOverflowSize;
	            if (this.virtualRowCount < lastRowIndexPlusOverflow) {
	                this.virtualRowCount = lastRowIndexPlusOverflow;
	                this.dispatchModelUpdated();
	            }
	        }
	    };
	    VirtualPageCache.prototype.dispatchModelUpdated = function () {
	        if (this.active) {
	            this.eventService.dispatchEvent(events_1.Events.EVENT_MODEL_UPDATED);
	        }
	    };
	    VirtualPageCache.prototype.getPageState = function () {
	        var result = [];
	        utils_1.Utils.iterateObject(this.pages, function (pageNumber, page) {
	            result.push({ pageNumber: pageNumber, startRow: page.getStartRow(), endRow: page.getEndRow(), pageStatus: page.getState() });
	        });
	        return result;
	    };
	    VirtualPageCache.prototype.refreshVirtualPageCache = function () {
	        utils_1.Utils.iterateObject(this.pages, function (pageId, page) {
	            page.setDirty();
	        });
	        this.checkPageToLoad();
	    };
	    VirtualPageCache.prototype.purgeVirtualPageCache = function () {
	        var _this = this;
	        var pagesList = utils_1.Utils.values(this.pages);
	        pagesList.forEach(function (virtualPage) { return _this.removePageFromCache(virtualPage); });
	        this.dispatchModelUpdated();
	    };
	    VirtualPageCache.prototype.getVirtualRowCount = function () {
	        return this.virtualRowCount;
	    };
	    VirtualPageCache.prototype.isMaxRowFound = function () {
	        return this.maxRowFound;
	    };
	    VirtualPageCache.prototype.setVirtualRowCount = function (rowCount, maxRowFound) {
	        this.virtualRowCount = rowCount;
	        // if undefined is passed, we do not set this value, if one of {true,false}
	        // is passed, we do set the value.
	        if (utils_1.Utils.exists(maxRowFound)) {
	            this.maxRowFound = maxRowFound;
	        }
	        // if we are still searching, then the row count must not end at the end
	        // of a particular page, otherwise the searching will not pop into the
	        // next page
	        if (!this.maxRowFound) {
	            if (this.virtualRowCount % this.cacheParams.pageSize === 0) {
	                this.virtualRowCount++;
	            }
	        }
	        this.dispatchModelUpdated();
	    };
	    __decorate([
	        context_1.Autowired('eventService'), 
	        __metadata('design:type', eventService_1.EventService)
	    ], VirtualPageCache.prototype, "eventService", void 0);
	    __decorate([
	        context_1.Autowired('context'), 
	        __metadata('design:type', context_1.Context)
	    ], VirtualPageCache.prototype, "context", void 0);
	    __decorate([
	        __param(0, context_1.Qualifier('loggerFactory')), 
	        __metadata('design:type', Function), 
	        __metadata('design:paramtypes', [logger_1.LoggerFactory]), 
	        __metadata('design:returntype', void 0)
	    ], VirtualPageCache.prototype, "setBeans", null);
	    __decorate([
	        context_1.PostConstruct, 
	        __metadata('design:type', Function), 
	        __metadata('design:paramtypes', []), 
	        __metadata('design:returntype', void 0)
	    ], VirtualPageCache.prototype, "init", null);
	    return VirtualPageCache;
	})();
	exports.VirtualPageCache = VirtualPageCache;


/***/ },
/* 88 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
	 * @version v7.0.2
	 * @link http://www.ag-grid.com/
	 * @license MIT
	 */
	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var utils_1 = __webpack_require__(7);
	var gridOptionsWrapper_1 = __webpack_require__(3);
	var rowNode_1 = __webpack_require__(27);
	var context_1 = __webpack_require__(6);
	var eventService_1 = __webpack_require__(4);
	var VirtualPage = (function () {
	    function VirtualPage(pageNumber, cacheSettings) {
	        this.state = VirtualPage.STATE_DIRTY;
	        this.version = 0;
	        this.localEventService = new eventService_1.EventService();
	        this.pageNumber = pageNumber;
	        this.cacheParams = cacheSettings;
	        // we don't need to calculate these now, as the inputs don't change,
	        // however it makes the code easier to read if we work them out up front
	        this.startRow = pageNumber * cacheSettings.pageSize;
	        this.endRow = this.startRow + cacheSettings.pageSize;
	    }
	    VirtualPage.prototype.setDirty = function () {
	        // in case any current loads in progress, this will have their results ignored
	        this.version++;
	        this.state = VirtualPage.STATE_DIRTY;
	    };
	    VirtualPage.prototype.setDirtyAndPurge = function () {
	        this.setDirty();
	        this.rowNodes.forEach(function (rowNode) {
	            rowNode.setData(null);
	        });
	    };
	    VirtualPage.prototype.getStartRow = function () {
	        return this.startRow;
	    };
	    VirtualPage.prototype.getEndRow = function () {
	        return this.endRow;
	    };
	    VirtualPage.prototype.getPageNumber = function () {
	        return this.pageNumber;
	    };
	    VirtualPage.prototype.addEventListener = function (eventType, listener) {
	        this.localEventService.addEventListener(eventType, listener);
	    };
	    VirtualPage.prototype.removeEventListener = function (eventType, listener) {
	        this.localEventService.removeEventListener(eventType, listener);
	    };
	    VirtualPage.prototype.getLastAccessed = function () {
	        return this.lastAccessed;
	    };
	    VirtualPage.prototype.getState = function () {
	        return this.state;
	    };
	    VirtualPage.prototype.setRowNode = function (rowIndex, rowNode) {
	        var localIndex = rowIndex - this.startRow;
	        this.rowNodes[localIndex] = rowNode;
	        rowNode.setRowIndex(rowIndex);
	        this.setTopOnRowNode(rowNode, rowIndex);
	    };
	    VirtualPage.prototype.setBlankRowNode = function (rowIndex) {
	        var localIndex = rowIndex - this.startRow;
	        var newRowNode = this.createBlankRowNode(rowIndex);
	        this.rowNodes[localIndex] = newRowNode;
	        return newRowNode;
	    };
	    VirtualPage.prototype.setNewData = function (rowIndex, dataItem) {
	        var newRowNode = this.setBlankRowNode(rowIndex);
	        newRowNode.setDataAndId(dataItem, rowIndex.toString());
	        return newRowNode;
	    };
	    VirtualPage.prototype.init = function () {
	        this.createRowNodes();
	    };
	    // creates empty row nodes, data is missing as not loaded yet
	    VirtualPage.prototype.createRowNodes = function () {
	        this.rowNodes = [];
	        for (var i = 0; i < this.cacheParams.pageSize; i++) {
	            var rowIndex = this.startRow + i;
	            var rowNode = this.createBlankRowNode(rowIndex);
	            this.rowNodes.push(rowNode);
	        }
	    };
	    VirtualPage.prototype.setTopOnRowNode = function (rowNode, rowIndex) {
	        rowNode.rowTop = this.cacheParams.rowHeight * rowIndex;
	    };
	    VirtualPage.prototype.createBlankRowNode = function (rowIndex) {
	        var rowNode = new rowNode_1.RowNode();
	        this.context.wireBean(rowNode);
	        rowNode.setRowHeight(this.cacheParams.rowHeight);
	        rowNode.setRowIndex(rowIndex);
	        this.setTopOnRowNode(rowNode, rowIndex);
	        return rowNode;
	    };
	    VirtualPage.prototype.getRow = function (rowIndex) {
	        this.lastAccessed = this.cacheParams.lastAccessedSequence.next();
	        var localIndex = rowIndex - this.startRow;
	        return this.rowNodes[localIndex];
	    };
	    VirtualPage.prototype.load = function () {
	        var _this = this;
	        this.state = VirtualPage.STATE_LOADING;
	        var params = {
	            startRow: this.startRow,
	            endRow: this.endRow,
	            successCallback: this.pageLoaded.bind(this, this.version),
	            failCallback: this.pageLoadFailed.bind(this),
	            sortModel: this.cacheParams.sortModel,
	            filterModel: this.cacheParams.filterModel,
	            context: this.gridOptionsWrapper.getContext()
	        };
	        if (utils_1.Utils.missing(this.cacheParams.datasource.getRows)) {
	            console.warn("ag-Grid: datasource is missing getRows method");
	            return;
	        }
	        // check if old version of datasource used
	        var getRowsParams = utils_1.Utils.getFunctionParameters(this.cacheParams.datasource.getRows);
	        if (getRowsParams.length > 1) {
	            console.warn('ag-grid: It looks like your paging datasource is of the old type, taking more than one parameter.');
	            console.warn('ag-grid: From ag-grid 1.9.0, now the getRows takes one parameter. See the documentation for details.');
	        }
	        // put in timeout, to force result to be async
	        setTimeout(function () {
	            _this.cacheParams.datasource.getRows(params);
	        }, 0);
	    };
	    VirtualPage.prototype.pageLoadFailed = function () {
	        this.state = VirtualPage.STATE_FAILED;
	        var event = { success: true, page: this };
	        this.localEventService.dispatchEvent(VirtualPage.EVENT_LOAD_COMPLETE, event);
	    };
	    VirtualPage.prototype.populateWithRowData = function (rows) {
	        var _this = this;
	        this.rowNodes.forEach(function (rowNode, index) {
	            var data = rows[index];
	            if (utils_1.Utils.exists(data)) {
	                // this means if the user is not providing id's we just use the
	                // index for the row. this will allow selection to work (that is based
	                // on index) as long user is not inserting or deleting rows,
	                // or wanting to keep selection between server side sorting or filtering
	                var indexOfRow = _this.startRow + index;
	                rowNode.setDataAndId(data, indexOfRow.toString());
	            }
	            else {
	                rowNode.setDataAndId(undefined, undefined);
	            }
	        });
	    };
	    VirtualPage.prototype.pageLoaded = function (version, rows, lastRow) {
	        // we need to check the version, in case there was an old request
	        // from the server that was sent before we refreshed the cache,
	        // if the load was done as a result of a cache refresh
	        if (version === this.version) {
	            this.state = VirtualPage.STATE_LOADED;
	            this.populateWithRowData(rows);
	        }
	        // check here if lastrow should be set
	        var event = { success: true, page: this, lastRow: lastRow };
	        this.localEventService.dispatchEvent(VirtualPage.EVENT_LOAD_COMPLETE, event);
	    };
	    VirtualPage.EVENT_LOAD_COMPLETE = 'loadComplete';
	    VirtualPage.STATE_DIRTY = 'dirty';
	    VirtualPage.STATE_LOADING = 'loading';
	    VirtualPage.STATE_LOADED = 'loaded';
	    VirtualPage.STATE_FAILED = 'failed';
	    __decorate([
	        context_1.Autowired('gridOptionsWrapper'), 
	        __metadata('design:type', gridOptionsWrapper_1.GridOptionsWrapper)
	    ], VirtualPage.prototype, "gridOptionsWrapper", void 0);
	    __decorate([
	        context_1.Autowired('context'), 
	        __metadata('design:type', context_1.Context)
	    ], VirtualPage.prototype, "context", void 0);
	    __decorate([
	        context_1.PostConstruct, 
	        __metadata('design:type', Function), 
	        __metadata('design:paramtypes', []), 
	        __metadata('design:returntype', void 0)
	    ], VirtualPage.prototype, "init", null);
	    return VirtualPage;
	})();
	exports.VirtualPage = VirtualPage;


/***/ },
/* 89 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
	 * @version v7.0.2
	 * @link http://www.ag-grid.com/
	 * @license MIT
	 */
	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var utils_1 = __webpack_require__(7);
	var constants_1 = __webpack_require__(8);
	var gridOptionsWrapper_1 = __webpack_require__(3);
	var columnController_1 = __webpack_require__(13);
	var filterManager_1 = __webpack_require__(43);
	var rowNode_1 = __webpack_require__(27);
	var eventService_1 = __webpack_require__(4);
	var events_1 = __webpack_require__(10);
	var context_1 = __webpack_require__(6);
	var selectionController_1 = __webpack_require__(28);
	var inMemoryNodeManager_1 = __webpack_require__(90);
	var RecursionType;
	(function (RecursionType) {
	    RecursionType[RecursionType["Normal"] = 0] = "Normal";
	    RecursionType[RecursionType["AfterFilter"] = 1] = "AfterFilter";
	    RecursionType[RecursionType["AfterFilterAndSort"] = 2] = "AfterFilterAndSort";
	    RecursionType[RecursionType["PivotNodes"] = 3] = "PivotNodes";
	})(RecursionType || (RecursionType = {}));
	;
	var InMemoryRowModel = (function () {
	    function InMemoryRowModel() {
	    }
	    InMemoryRowModel.prototype.init = function () {
	        this.eventService.addModalPriorityEventListener(events_1.Events.EVENT_COLUMN_EVERYTHING_CHANGED, this.refreshModel.bind(this, { step: constants_1.Constants.STEP_EVERYTHING }));
	        this.eventService.addModalPriorityEventListener(events_1.Events.EVENT_COLUMN_ROW_GROUP_CHANGED, this.refreshModel.bind(this, { step: constants_1.Constants.STEP_EVERYTHING }));
	        this.eventService.addModalPriorityEventListener(events_1.Events.EVENT_COLUMN_VALUE_CHANGED, this.onValueChanged.bind(this));
	        this.eventService.addModalPriorityEventListener(events_1.Events.EVENT_COLUMN_PIVOT_CHANGED, this.refreshModel.bind(this, { step: constants_1.Constants.STEP_PIVOT }));
	        this.eventService.addModalPriorityEventListener(events_1.Events.EVENT_ROW_GROUP_OPENED, this.onRowGroupOpened.bind(this));
	        this.eventService.addModalPriorityEventListener(events_1.Events.EVENT_FILTER_CHANGED, this.onFilterChanged.bind(this));
	        this.eventService.addModalPriorityEventListener(events_1.Events.EVENT_SORT_CHANGED, this.onSortChanged.bind(this));
	        this.eventService.addModalPriorityEventListener(events_1.Events.EVENT_COLUMN_PIVOT_MODE_CHANGED, this.refreshModel.bind(this, { step: constants_1.Constants.STEP_PIVOT }));
	        this.rootNode = new rowNode_1.RowNode();
	        this.nodeManager = new inMemoryNodeManager_1.InMemoryNodeManager(this.rootNode, this.gridOptionsWrapper, this.context, this.eventService);
	        this.context.wireBean(this.rootNode);
	        if (this.gridOptionsWrapper.isRowModelDefault()) {
	            this.setRowData(this.gridOptionsWrapper.getRowData(), this.columnController.isReady());
	        }
	    };
	    InMemoryRowModel.prototype.onRowGroupOpened = function () {
	        var animate = this.gridOptionsWrapper.isAnimateRows();
	        this.refreshModel({ step: constants_1.Constants.STEP_MAP, keepRenderedRows: true, animate: animate });
	    };
	    InMemoryRowModel.prototype.onFilterChanged = function () {
	        var animate = this.gridOptionsWrapper.isAnimateRows();
	        this.refreshModel({ step: constants_1.Constants.STEP_FILTER, keepRenderedRows: true, animate: animate });
	    };
	    InMemoryRowModel.prototype.onSortChanged = function () {
	        // we only act on the sort event here if the user is doing in grid sorting.
	        // we ignore it if the sorting is happening on the server side.
	        if (this.gridOptionsWrapper.isEnableServerSideSorting()) {
	            return;
	        }
	        var animate = this.gridOptionsWrapper.isAnimateRows();
	        this.refreshModel({ step: constants_1.Constants.STEP_SORT, keepRenderedRows: true, animate: animate });
	    };
	    InMemoryRowModel.prototype.getType = function () {
	        return constants_1.Constants.ROW_MODEL_TYPE_NORMAL;
	    };
	    InMemoryRowModel.prototype.onValueChanged = function () {
	        if (this.columnController.isPivotActive()) {
	            this.refreshModel({ step: constants_1.Constants.STEP_PIVOT });
	        }
	        else {
	            this.refreshModel({ step: constants_1.Constants.STEP_AGGREGATE });
	        }
	    };
	    InMemoryRowModel.prototype.refreshModel = function (params) {
	        // this goes through the pipeline of stages. what's in my head is similar
	        // to the diagram on this page:
	        // http://commons.apache.org/sandbox/commons-pipeline/pipeline_basics.html
	        // however we want to keep the results of each stage, hence we manually call
	        // each step rather than have them chain each other.
	        var _this = this;
	        // fallthrough in below switch is on purpose,
	        // eg if STEP_FILTER, then all steps below this
	        // step get done
	        // var start: number;
	        // console.log('======= start =======');
	        switch (params.step) {
	            case constants_1.Constants.STEP_EVERYTHING:
	                // start = new Date().getTime();
	                this.doRowGrouping(params.groupState);
	            // console.log('rowGrouping = ' + (new Date().getTime() - start));
	            case constants_1.Constants.STEP_FILTER:
	                // start = new Date().getTime();
	                this.doFilter();
	            // console.log('filter = ' + (new Date().getTime() - start));
	            case constants_1.Constants.STEP_PIVOT:
	                this.doPivot();
	            case constants_1.Constants.STEP_AGGREGATE:
	                // start = new Date().getTime();
	                this.doAggregate();
	            // console.log('aggregation = ' + (new Date().getTime() - start));
	            case constants_1.Constants.STEP_SORT:
	                // start = new Date().getTime();
	                this.doSort();
	            // console.log('sort = ' + (new Date().getTime() - start));
	            case constants_1.Constants.STEP_MAP:
	                // start = new Date().getTime();
	                this.doRowsToDisplay();
	        }
	        var event = { animate: params.animate, keepRenderedRows: params.keepRenderedRows };
	        this.eventService.dispatchEvent(events_1.Events.EVENT_MODEL_UPDATED, event);
	        if (this.$scope) {
	            setTimeout(function () {
	                _this.$scope.$apply();
	            }, 0);
	        }
	    };
	    InMemoryRowModel.prototype.isEmpty = function () {
	        var rowsMissing;
	        var rowsAlreadyGrouped = utils_1.Utils.exists(this.gridOptionsWrapper.getNodeChildDetailsFunc());
	        if (rowsAlreadyGrouped) {
	            rowsMissing = utils_1.Utils.missing(this.rootNode.childrenAfterGroup) || this.rootNode.childrenAfterGroup.length === 0;
	        }
	        else {
	            rowsMissing = utils_1.Utils.missing(this.rootNode.allLeafChildren) || this.rootNode.allLeafChildren.length === 0;
	        }
	        var empty = utils_1.Utils.missing(this.rootNode) || rowsMissing || !this.columnController.isReady();
	        return empty;
	    };
	    InMemoryRowModel.prototype.isRowsToRender = function () {
	        return utils_1.Utils.exists(this.rowsToDisplay) && this.rowsToDisplay.length > 0;
	    };
	    InMemoryRowModel.prototype.setDatasource = function (datasource) {
	        console.error('ag-Grid: should never call setDatasource on inMemoryRowController');
	    };
	    InMemoryRowModel.prototype.getTopLevelNodes = function () {
	        return this.rootNode ? this.rootNode.childrenAfterGroup : null;
	    };
	    InMemoryRowModel.prototype.getRow = function (index) {
	        return this.rowsToDisplay[index];
	    };
	    InMemoryRowModel.prototype.getVirtualRowCount = function () {
	        console.warn('ag-Grid: rowModel.getVirtualRowCount() is not longer a function, use rowModel.getRowCount() instead');
	        return this.getRowCount();
	    };
	    InMemoryRowModel.prototype.getRowCount = function () {
	        if (this.rowsToDisplay) {
	            return this.rowsToDisplay.length;
	        }
	        else {
	            return 0;
	        }
	    };
	    InMemoryRowModel.prototype.getRowIndexAtPixel = function (pixelToMatch) {
	        if (this.isEmpty()) {
	            return -1;
	        }
	        // do binary search of tree
	        // http://oli.me.uk/2013/06/08/searching-javascript-arrays-with-a-binary-search/
	        var bottomPointer = 0;
	        var topPointer = this.rowsToDisplay.length - 1;
	        // quick check, if the pixel is out of bounds, then return last row
	        if (pixelToMatch <= 0) {
	            // if pixel is less than or equal zero, it's always the first row
	            return 0;
	        }
	        var lastNode = this.rowsToDisplay[this.rowsToDisplay.length - 1];
	        if (lastNode.rowTop <= pixelToMatch) {
	            return this.rowsToDisplay.length - 1;
	        }
	        while (true) {
	            var midPointer = Math.floor((bottomPointer + topPointer) / 2);
	            var currentRowNode = this.rowsToDisplay[midPointer];
	            if (this.isRowInPixel(currentRowNode, pixelToMatch)) {
	                return midPointer;
	            }
	            else if (currentRowNode.rowTop < pixelToMatch) {
	                bottomPointer = midPointer + 1;
	            }
	            else if (currentRowNode.rowTop > pixelToMatch) {
	                topPointer = midPointer - 1;
	            }
	        }
	    };
	    InMemoryRowModel.prototype.isRowInPixel = function (rowNode, pixelToMatch) {
	        var topPixel = rowNode.rowTop;
	        var bottomPixel = rowNode.rowTop + rowNode.rowHeight;
	        var pixelInRow = topPixel <= pixelToMatch && bottomPixel > pixelToMatch;
	        return pixelInRow;
	    };
	    InMemoryRowModel.prototype.getRowCombinedHeight = function () {
	        if (this.rowsToDisplay && this.rowsToDisplay.length > 0) {
	            var lastRow = this.rowsToDisplay[this.rowsToDisplay.length - 1];
	            var lastPixel = lastRow.rowTop + lastRow.rowHeight;
	            return lastPixel;
	        }
	        else {
	            return 0;
	        }
	    };
	    InMemoryRowModel.prototype.forEachLeafNode = function (callback) {
	        if (this.rootNode.allLeafChildren) {
	            this.rootNode.allLeafChildren.forEach(function (rowNode, index) { return callback(rowNode, index); });
	        }
	    };
	    InMemoryRowModel.prototype.forEachNode = function (callback) {
	        this.recursivelyWalkNodesAndCallback(this.rootNode.childrenAfterGroup, callback, RecursionType.Normal, 0);
	    };
	    InMemoryRowModel.prototype.forEachNodeAfterFilter = function (callback) {
	        this.recursivelyWalkNodesAndCallback(this.rootNode.childrenAfterFilter, callback, RecursionType.AfterFilter, 0);
	    };
	    InMemoryRowModel.prototype.forEachNodeAfterFilterAndSort = function (callback) {
	        this.recursivelyWalkNodesAndCallback(this.rootNode.childrenAfterSort, callback, RecursionType.AfterFilterAndSort, 0);
	    };
	    InMemoryRowModel.prototype.forEachPivotNode = function (callback) {
	        this.recursivelyWalkNodesAndCallback([this.rootNode], callback, RecursionType.PivotNodes, 0);
	    };
	    // iterates through each item in memory, and calls the callback function
	    // nodes - the rowNodes to traverse
	    // callback - the user provided callback
	    // recursion type - need this to know what child nodes to recurse, eg if looking at all nodes, or filtered notes etc
	    // index - works similar to the index in forEach in javascripts array function
	    InMemoryRowModel.prototype.recursivelyWalkNodesAndCallback = function (nodes, callback, recursionType, index) {
	        if (nodes) {
	            for (var i = 0; i < nodes.length; i++) {
	                var node = nodes[i];
	                callback(node, index++);
	                // go to the next level if it is a group
	                if (node.group) {
	                    // depending on the recursion type, we pick a difference set of children
	                    var nodeChildren;
	                    switch (recursionType) {
	                        case RecursionType.Normal:
	                            nodeChildren = node.childrenAfterGroup;
	                            break;
	                        case RecursionType.AfterFilter:
	                            nodeChildren = node.childrenAfterFilter;
	                            break;
	                        case RecursionType.AfterFilterAndSort:
	                            nodeChildren = node.childrenAfterSort;
	                            break;
	                        case RecursionType.PivotNodes:
	                            // for pivot, we don't go below leafGroup levels
	                            nodeChildren = !node.leafGroup ? node.childrenAfterSort : null;
	                            break;
	                    }
	                    if (nodeChildren) {
	                        index = this.recursivelyWalkNodesAndCallback(nodeChildren, callback, recursionType, index);
	                    }
	                }
	            }
	        }
	        return index;
	    };
	    // it's possible to recompute the aggregate without doing the other parts
	    // + gridApi.recomputeAggregates()
	    InMemoryRowModel.prototype.doAggregate = function () {
	        if (this.aggregationStage) {
	            this.aggregationStage.execute(this.rootNode);
	        }
	    };
	    // + gridApi.expandAll()
	    // + gridApi.collapseAll()
	    InMemoryRowModel.prototype.expandOrCollapseAll = function (expand) {
	        if (this.rootNode) {
	            recursiveExpandOrCollapse(this.rootNode.childrenAfterGroup);
	        }
	        function recursiveExpandOrCollapse(rowNodes) {
	            if (!rowNodes) {
	                return;
	            }
	            rowNodes.forEach(function (rowNode) {
	                if (rowNode.group) {
	                    rowNode.expanded = expand;
	                    recursiveExpandOrCollapse(rowNode.childrenAfterGroup);
	                }
	            });
	        }
	        this.refreshModel({ step: constants_1.Constants.STEP_MAP });
	    };
	    InMemoryRowModel.prototype.doSort = function () {
	        this.sortStage.execute(this.rootNode);
	    };
	    InMemoryRowModel.prototype.doRowGrouping = function (groupState) {
	        // grouping is enterprise only, so if service missing, skip the step
	        var rowsAlreadyGrouped = utils_1.Utils.exists(this.gridOptionsWrapper.getNodeChildDetailsFunc());
	        if (rowsAlreadyGrouped) {
	            return;
	        }
	        if (this.groupStage) {
	            // remove old groups from the selection model, as we are about to replace them
	            // with new groups
	            this.selectionController.removeGroupsFromSelection();
	            this.groupStage.execute(this.rootNode);
	            this.restoreGroupState(groupState);
	            if (this.gridOptionsWrapper.isGroupSelectsChildren()) {
	                this.selectionController.updateGroupsFromChildrenSelections();
	            }
	        }
	        else {
	            this.rootNode.childrenAfterGroup = this.rootNode.allLeafChildren;
	        }
	    };
	    InMemoryRowModel.prototype.restoreGroupState = function (groupState) {
	        if (!groupState) {
	            return;
	        }
	        utils_1.Utils.traverseNodesWithKey(this.rootNode.childrenAfterGroup, function (node, key) {
	            // if the group was open last time, then open it this time. however
	            // if was not open last time, then don't touch the group, so the 'groupDefaultExpanded'
	            // setting will take effect.
	            if (typeof groupState[key] === 'boolean') {
	                node.expanded = groupState[key];
	            }
	        });
	    };
	    InMemoryRowModel.prototype.doFilter = function () {
	        this.filterStage.execute(this.rootNode);
	    };
	    InMemoryRowModel.prototype.doPivot = function () {
	        if (this.pivotStage) {
	            this.pivotStage.execute(this.rootNode);
	        }
	    };
	    InMemoryRowModel.prototype.getGroupState = function () {
	        if (!this.rootNode.childrenAfterGroup || !this.gridOptionsWrapper.isRememberGroupStateWhenNewData()) {
	            return null;
	        }
	        var result = {};
	        utils_1.Utils.traverseNodesWithKey(this.rootNode.childrenAfterGroup, function (node, key) { return result[key] = node.expanded; });
	        return result;
	    };
	    // rows: the rows to put into the model
	    // firstId: the first id to use, used for paging, where we are not on the first page
	    InMemoryRowModel.prototype.setRowData = function (rowData, refresh, firstId) {
	        // remember group state, so we can expand groups that should be expanded
	        var groupState = this.getGroupState();
	        this.nodeManager.setRowData(rowData, firstId);
	        // this event kicks off:
	        // - clears selection
	        // - updates filters
	        // - shows 'no rows' overlay if needed
	        this.eventService.dispatchEvent(events_1.Events.EVENT_ROW_DATA_CHANGED);
	        if (refresh) {
	            this.refreshModel({ step: constants_1.Constants.STEP_EVERYTHING, groupState: groupState });
	        }
	    };
	    InMemoryRowModel.prototype.doRowsToDisplay = function () {
	        this.rowsToDisplay = this.flattenStage.execute(this.rootNode);
	    };
	    InMemoryRowModel.prototype.insertItemsAtIndex = function (index, items) {
	        // remember group state, so we can expand groups that should be expanded
	        var groupState = this.getGroupState();
	        var newNodes = this.nodeManager.insertItemsAtIndex(index, items);
	        this.refreshAndFireEvent(events_1.Events.EVENT_ITEMS_ADDED, newNodes, groupState);
	    };
	    InMemoryRowModel.prototype.onRowHeightChanged = function () {
	        this.refreshModel({ step: constants_1.Constants.STEP_MAP, keepRenderedRows: true });
	    };
	    InMemoryRowModel.prototype.resetRowHeights = function () {
	        this.forEachNode(function (rowNode) { return rowNode.setRowHeight(null); });
	        this.onRowHeightChanged();
	    };
	    InMemoryRowModel.prototype.removeItems = function (rowNodes) {
	        var groupState = this.getGroupState();
	        var removedNodes = this.nodeManager.removeItems(rowNodes);
	        this.refreshAndFireEvent(events_1.Events.EVENT_ITEMS_REMOVED, removedNodes, groupState);
	    };
	    InMemoryRowModel.prototype.addItems = function (items) {
	        var groupState = this.getGroupState();
	        var newNodes = this.nodeManager.addItems(items);
	        this.refreshAndFireEvent(events_1.Events.EVENT_ITEMS_ADDED, newNodes, groupState);
	    };
	    InMemoryRowModel.prototype.refreshAndFireEvent = function (eventName, rowNodes, groupState) {
	        if (rowNodes) {
	            this.refreshModel({ step: constants_1.Constants.STEP_EVERYTHING, groupState: groupState });
	            this.eventService.dispatchEvent(eventName, { rowNodes: rowNodes });
	        }
	    };
	    __decorate([
	        context_1.Autowired('gridOptionsWrapper'), 
	        __metadata('design:type', gridOptionsWrapper_1.GridOptionsWrapper)
	    ], InMemoryRowModel.prototype, "gridOptionsWrapper", void 0);
	    __decorate([
	        context_1.Autowired('columnController'), 
	        __metadata('design:type', columnController_1.ColumnController)
	    ], InMemoryRowModel.prototype, "columnController", void 0);
	    __decorate([
	        context_1.Autowired('filterManager'), 
	        __metadata('design:type', filterManager_1.FilterManager)
	    ], InMemoryRowModel.prototype, "filterManager", void 0);
	    __decorate([
	        context_1.Autowired('$scope'), 
	        __metadata('design:type', Object)
	    ], InMemoryRowModel.prototype, "$scope", void 0);
	    __decorate([
	        context_1.Autowired('selectionController'), 
	        __metadata('design:type', selectionController_1.SelectionController)
	    ], InMemoryRowModel.prototype, "selectionController", void 0);
	    __decorate([
	        context_1.Autowired('eventService'), 
	        __metadata('design:type', eventService_1.EventService)
	    ], InMemoryRowModel.prototype, "eventService", void 0);
	    __decorate([
	        context_1.Autowired('context'), 
	        __metadata('design:type', context_1.Context)
	    ], InMemoryRowModel.prototype, "context", void 0);
	    __decorate([
	        context_1.Autowired('filterStage'), 
	        __metadata('design:type', Object)
	    ], InMemoryRowModel.prototype, "filterStage", void 0);
	    __decorate([
	        context_1.Autowired('sortStage'), 
	        __metadata('design:type', Object)
	    ], InMemoryRowModel.prototype, "sortStage", void 0);
	    __decorate([
	        context_1.Autowired('flattenStage'), 
	        __metadata('design:type', Object)
	    ], InMemoryRowModel.prototype, "flattenStage", void 0);
	    __decorate([
	        context_1.Optional('groupStage'), 
	        __metadata('design:type', Object)
	    ], InMemoryRowModel.prototype, "groupStage", void 0);
	    __decorate([
	        context_1.Optional('aggregationStage'), 
	        __metadata('design:type', Object)
	    ], InMemoryRowModel.prototype, "aggregationStage", void 0);
	    __decorate([
	        context_1.Optional('pivotStage'), 
	        __metadata('design:type', Object)
	    ], InMemoryRowModel.prototype, "pivotStage", void 0);
	    __decorate([
	        context_1.PostConstruct, 
	        __metadata('design:type', Function), 
	        __metadata('design:paramtypes', []), 
	        __metadata('design:returntype', void 0)
	    ], InMemoryRowModel.prototype, "init", null);
	    InMemoryRowModel = __decorate([
	        context_1.Bean('rowModel'), 
	        __metadata('design:paramtypes', [])
	    ], InMemoryRowModel);
	    return InMemoryRowModel;
	})();
	exports.InMemoryRowModel = InMemoryRowModel;


/***/ },
/* 90 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
	 * @version v7.0.2
	 * @link http://www.ag-grid.com/
	 * @license MIT
	 */
	var rowNode_1 = __webpack_require__(27);
	var utils_1 = __webpack_require__(7);
	var InMemoryNodeManager = (function () {
	    function InMemoryNodeManager(rootNode, gridOptionsWrapper, context, eventService) {
	        this.nextId = 0;
	        this.rootNode = rootNode;
	        this.gridOptionsWrapper = gridOptionsWrapper;
	        this.context = context;
	        this.eventService = eventService;
	        this.rootNode.group = true;
	        this.rootNode.level = -1;
	        this.rootNode.allLeafChildren = [];
	        this.rootNode.childrenAfterGroup = [];
	        this.rootNode.childrenAfterSort = [];
	        this.rootNode.childrenAfterFilter = [];
	    }
	    InMemoryNodeManager.prototype.setRowData = function (rowData, firstId) {
	        this.rootNode.childrenAfterFilter = null;
	        this.rootNode.childrenAfterGroup = null;
	        this.rootNode.childrenAfterSort = null;
	        this.rootNode.childrenMapped = null;
	        this.nextId = utils_1.Utils.exists(firstId) ? firstId : 0;
	        if (!rowData) {
	            this.rootNode.allLeafChildren = [];
	            this.rootNode.childrenAfterGroup = [];
	            return;
	        }
	        // func below doesn't have 'this' pointer, so need to pull out these bits
	        this.getNodeChildDetails = this.gridOptionsWrapper.getNodeChildDetailsFunc();
	        this.suppressParentsInRowNodes = this.gridOptionsWrapper.isSuppressParentsInRowNodes();
	        this.doesDataFlower = this.gridOptionsWrapper.getDoesDataFlowerFunc();
	        var rowsAlreadyGrouped = utils_1.Utils.exists(this.getNodeChildDetails);
	        // kick off recursion
	        var result = this.recursiveFunction(rowData, null, InMemoryNodeManager.TOP_LEVEL);
	        if (rowsAlreadyGrouped) {
	            this.rootNode.childrenAfterGroup = result;
	            this.setLeafChildren(this.rootNode);
	        }
	        else {
	            this.rootNode.allLeafChildren = result;
	        }
	    };
	    InMemoryNodeManager.prototype.recursiveFunction = function (rowData, parent, level) {
	        var _this = this;
	        // make sure the rowData is an array and not a string of json - this was a commonly reported problem on the forum
	        if (typeof rowData === 'string') {
	            console.warn('ag-Grid: rowData must be an array, however you passed in a string. If you are loading JSON, make sure you convert the JSON string to JavaScript objects first');
	            return;
	        }
	        var rowNodes = [];
	        rowData.forEach(function (dataItem) {
	            var node = _this.createNode(dataItem, parent, level);
	            var nodeChildDetails = _this.getNodeChildDetails ? _this.getNodeChildDetails(dataItem) : null;
	            if (nodeChildDetails && nodeChildDetails.group) {
	                node.group = true;
	                node.childrenAfterGroup = _this.recursiveFunction(nodeChildDetails.children, node, level + 1);
	                node.expanded = nodeChildDetails.expanded === true;
	                node.field = nodeChildDetails.field;
	                node.key = nodeChildDetails.key;
	                // pull out all the leaf children and add to our node
	                _this.setLeafChildren(node);
	            }
	            rowNodes.push(node);
	        });
	        return rowNodes;
	    };
	    InMemoryNodeManager.prototype.createNode = function (dataItem, parent, level) {
	        var node = new rowNode_1.RowNode();
	        this.context.wireBean(node);
	        var nodeChildDetails = this.getNodeChildDetails ? this.getNodeChildDetails(dataItem) : null;
	        if (nodeChildDetails && nodeChildDetails.group) {
	            node.group = true;
	            node.childrenAfterGroup = this.recursiveFunction(nodeChildDetails.children, node, level + 1);
	            node.expanded = nodeChildDetails.expanded === true;
	            node.field = nodeChildDetails.field;
	            node.key = nodeChildDetails.key;
	            node.canFlower = false;
	            // pull out all the leaf children and add to our node
	            this.setLeafChildren(node);
	        }
	        else {
	            node.group = false;
	            node.canFlower = this.doesDataFlower ? this.doesDataFlower(dataItem) : false;
	            if (node.canFlower) {
	                node.expanded = false;
	            }
	        }
	        if (parent && !this.suppressParentsInRowNodes) {
	            node.parent = parent;
	        }
	        node.level = level;
	        node.setDataAndId(dataItem, this.nextId.toString());
	        this.nextId++;
	        return node;
	    };
	    InMemoryNodeManager.prototype.setLeafChildren = function (node) {
	        node.allLeafChildren = [];
	        if (node.childrenAfterGroup) {
	            node.childrenAfterGroup.forEach(function (childAfterGroup) {
	                if (childAfterGroup.group) {
	                    if (childAfterGroup.allLeafChildren) {
	                        childAfterGroup.allLeafChildren.forEach(function (leafChild) { return node.allLeafChildren.push(leafChild); });
	                    }
	                }
	                else {
	                    node.allLeafChildren.push(childAfterGroup);
	                }
	            });
	        }
	    };
	    InMemoryNodeManager.prototype.insertItemsAtIndex = function (index, rowData) {
	        if (this.isRowsAlreadyGrouped()) {
	            return null;
	        }
	        var nodeList = this.rootNode.allLeafChildren;
	        if (index > nodeList.length) {
	            console.warn("ag-Grid: invalid index " + index + ", max index is " + nodeList.length);
	            return;
	        }
	        var newNodes = [];
	        // go through the items backwards, otherwise they get added in reverse order
	        for (var i = rowData.length - 1; i >= 0; i--) {
	            var data = rowData[i];
	            var newNode = this.createNode(data, null, InMemoryNodeManager.TOP_LEVEL);
	            utils_1.Utils.insertIntoArray(nodeList, newNode, index);
	            newNodes.push(newNode);
	        }
	        return newNodes.length > 0 ? newNodes : null;
	    };
	    InMemoryNodeManager.prototype.removeItems = function (rowNodes) {
	        if (this.isRowsAlreadyGrouped()) {
	            return;
	        }
	        var nodeList = this.rootNode.allLeafChildren;
	        var removedNodes = [];
	        rowNodes.forEach(function (rowNode) {
	            var indexOfNode = nodeList.indexOf(rowNode);
	            if (indexOfNode >= 0) {
	                rowNode.setSelected(false);
	                nodeList.splice(indexOfNode, 1);
	            }
	            removedNodes.push(rowNode);
	        });
	        return removedNodes.length > 0 ? removedNodes : null;
	    };
	    InMemoryNodeManager.prototype.addItems = function (items) {
	        var nodeList = this.rootNode.allLeafChildren;
	        return this.insertItemsAtIndex(nodeList.length, items);
	    };
	    InMemoryNodeManager.prototype.isRowsAlreadyGrouped = function () {
	        var rowsAlreadyGrouped = utils_1.Utils.exists(this.gridOptionsWrapper.getNodeChildDetailsFunc());
	        if (rowsAlreadyGrouped) {
	            console.warn('ag-Grid: adding and removing rows is not supported when using nodeChildDetailsFunc, ie it is not ' +
	                'supported if providing groups');
	            return true;
	        }
	        else {
	            return false;
	        }
	    };
	    InMemoryNodeManager.TOP_LEVEL = 0;
	    return InMemoryNodeManager;
	})();
	exports.InMemoryNodeManager = InMemoryNodeManager;


/***/ },
/* 91 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
	 * @version v7.0.2
	 * @link http://www.ag-grid.com/
	 * @license MIT
	 */
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var component_1 = __webpack_require__(47);
	var componentAnnotations_1 = __webpack_require__(92);
	var utils_1 = __webpack_require__(7);
	var context_1 = __webpack_require__(6);
	var gridOptionsWrapper_1 = __webpack_require__(3);
	var svgFactory_1 = __webpack_require__(59);
	var svgFactory = svgFactory_1.SvgFactory.getInstance();
	var AgCheckbox = (function (_super) {
	    __extends(AgCheckbox, _super);
	    function AgCheckbox() {
	        _super.call(this, AgCheckbox.TEMPLATE);
	        this.selected = false;
	        this.readOnly = false;
	        this.passive = false;
	    }
	    AgCheckbox.prototype.init = function () {
	        this.loadIcons();
	        this.updateIcons();
	        var label = this.getAttribute('label');
	        if (label) {
	            this.eLabel.innerText = label;
	        }
	    };
	    AgCheckbox.prototype.loadIcons = function () {
	        utils_1.Utils.removeAllChildren(this.eChecked);
	        utils_1.Utils.removeAllChildren(this.eUnchecked);
	        utils_1.Utils.removeAllChildren(this.eIndeterminate);
	        if (this.readOnly) {
	            this.eChecked.appendChild(utils_1.Utils.createIconNoSpan('checkboxCheckedReadOnly', this.gridOptionsWrapper, null, svgFactory.createCheckboxCheckedReadOnlyIcon));
	            this.eUnchecked.appendChild(utils_1.Utils.createIconNoSpan('checkboxUncheckedReadOnly', this.gridOptionsWrapper, null, svgFactory.createCheckboxUncheckedReadOnlyIcon));
	            this.eIndeterminate.appendChild(utils_1.Utils.createIconNoSpan('checkboxIndeterminateReadOnly', this.gridOptionsWrapper, null, svgFactory.createCheckboxIndeterminateReadOnlyIcon));
	        }
	        else {
	            this.eChecked.appendChild(utils_1.Utils.createIconNoSpan('checkboxChecked', this.gridOptionsWrapper, null, svgFactory.createCheckboxCheckedIcon));
	            this.eUnchecked.appendChild(utils_1.Utils.createIconNoSpan('checkboxUnchecked', this.gridOptionsWrapper, null, svgFactory.createCheckboxUncheckedIcon));
	            this.eIndeterminate.appendChild(utils_1.Utils.createIconNoSpan('checkboxIndeterminate', this.gridOptionsWrapper, null, svgFactory.createCheckboxIndeterminateIcon));
	        }
	    };
	    AgCheckbox.prototype.onClick = function () {
	        if (!this.readOnly) {
	            this.toggle();
	        }
	    };
	    AgCheckbox.prototype.getNextValue = function () {
	        if (this.selected === undefined) {
	            return true;
	        }
	        else {
	            return !this.selected;
	        }
	    };
	    AgCheckbox.prototype.setPassive = function (passive) {
	        this.passive = passive;
	    };
	    AgCheckbox.prototype.setReadOnly = function (readOnly) {
	        this.readOnly = readOnly;
	        this.loadIcons();
	    };
	    AgCheckbox.prototype.isReadOnly = function () {
	        return this.readOnly;
	    };
	    AgCheckbox.prototype.isSelected = function () {
	        return this.selected;
	    };
	    AgCheckbox.prototype.toggle = function () {
	        var nextValue = this.getNextValue();
	        if (this.passive) {
	            this.dispatchEvent(AgCheckbox.EVENT_CHANGED, { selected: nextValue });
	        }
	        else {
	            this.setSelected(nextValue);
	        }
	    };
	    AgCheckbox.prototype.setSelected = function (selected) {
	        if (this.selected === selected) {
	            return;
	        }
	        if (selected === true) {
	            this.selected = true;
	        }
	        else if (selected === false) {
	            this.selected = false;
	        }
	        else {
	            this.selected = undefined;
	        }
	        this.updateIcons();
	        this.dispatchEvent(AgCheckbox.EVENT_CHANGED, { selected: this.selected });
	    };
	    AgCheckbox.prototype.updateIcons = function () {
	        utils_1.Utils.setVisible(this.eChecked, this.selected === true);
	        utils_1.Utils.setVisible(this.eUnchecked, this.selected === false);
	        utils_1.Utils.setVisible(this.eIndeterminate, this.selected === undefined);
	    };
	    AgCheckbox.EVENT_CHANGED = 'change';
	    AgCheckbox.TEMPLATE = '<span class="ag-checkbox">' +
	        '  <span class="ag-checkbox-checked"></span>' +
	        '  <span class="ag-checkbox-unchecked"></span>' +
	        '  <span class="ag-checkbox-indeterminate"></span>' +
	        '  <span class="ag-checkbox-label"></span>' +
	        '</span>';
	    __decorate([
	        context_1.Autowired('gridOptionsWrapper'), 
	        __metadata('design:type', gridOptionsWrapper_1.GridOptionsWrapper)
	    ], AgCheckbox.prototype, "gridOptionsWrapper", void 0);
	    __decorate([
	        componentAnnotations_1.QuerySelector('.ag-checkbox-checked'), 
	        __metadata('design:type', HTMLElement)
	    ], AgCheckbox.prototype, "eChecked", void 0);
	    __decorate([
	        componentAnnotations_1.QuerySelector('.ag-checkbox-unchecked'), 
	        __metadata('design:type', HTMLElement)
	    ], AgCheckbox.prototype, "eUnchecked", void 0);
	    __decorate([
	        componentAnnotations_1.QuerySelector('.ag-checkbox-indeterminate'), 
	        __metadata('design:type', HTMLElement)
	    ], AgCheckbox.prototype, "eIndeterminate", void 0);
	    __decorate([
	        componentAnnotations_1.QuerySelector('.ag-checkbox-label'), 
	        __metadata('design:type', HTMLElement)
	    ], AgCheckbox.prototype, "eLabel", void 0);
	    __decorate([
	        context_1.PostConstruct, 
	        __metadata('design:type', Function), 
	        __metadata('design:paramtypes', []), 
	        __metadata('design:returntype', void 0)
	    ], AgCheckbox.prototype, "init", null);
	    __decorate([
	        componentAnnotations_1.Listener('click'), 
	        __metadata('design:type', Function), 
	        __metadata('design:paramtypes', []), 
	        __metadata('design:returntype', void 0)
	    ], AgCheckbox.prototype, "onClick", null);
	    return AgCheckbox;
	})(component_1.Component);
	exports.AgCheckbox = AgCheckbox;


/***/ },
/* 92 */
/***/ function(module, exports) {

	/**
	 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
	 * @version v7.0.2
	 * @link http://www.ag-grid.com/
	 * @license MIT
	 */
	function QuerySelector(selector) {
	    return querySelectorFunc.bind(this, selector);
	}
	exports.QuerySelector = QuerySelector;
	function querySelectorFunc(selector, classPrototype, methodOrAttributeName, index) {
	    if (selector === null) {
	        console.error('ag-Grid: QuerySelector selector should not be null');
	        return;
	    }
	    if (typeof index === 'number') {
	        console.error('ag-Grid: QuerySelector should be on an attribute');
	        return;
	    }
	    // it's an attribute on the class
	    var props = getOrCreateProps(classPrototype);
	    if (!props.querySelectors) {
	        props.querySelectors = [];
	    }
	    props.querySelectors.push({
	        attributeName: methodOrAttributeName,
	        querySelector: selector
	    });
	}
	function Listener(eventName) {
	    return listenerFunc.bind(this, eventName);
	}
	exports.Listener = Listener;
	function listenerFunc(eventName, target, methodName, descriptor) {
	    if (eventName === null) {
	        console.error('ag-Grid: EventListener eventName should not be null');
	        return;
	    }
	    // it's an attribute on the class
	    var props = getOrCreateProps(target);
	    if (!props.listenerMethods) {
	        props.listenerMethods = [];
	    }
	    props.listenerMethods.push({
	        methodName: methodName,
	        eventName: eventName
	    });
	}
	function getOrCreateProps(target) {
	    var props = target.__agComponentMetaData;
	    if (!props) {
	        props = {};
	        target.__agComponentMetaData = props;
	    }
	    return props;
	}


/***/ },
/* 93 */
/***/ function(module, exports) {

	/**
	 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
	 * @version v7.0.2
	 * @link http://www.ag-grid.com/
	 * @license MIT
	 */
	/** The base frameworks, eg React & Angular 2, override this bean with implementations specific to their requirement. */
	var BaseFrameworkFactory = (function () {
	    function BaseFrameworkFactory() {
	    }
	    BaseFrameworkFactory.prototype.colDefFloatingCellRenderer = function (colDef) {
	        return colDef.floatingCellRenderer;
	    };
	    BaseFrameworkFactory.prototype.colDefCellRenderer = function (colDef) {
	        return colDef.cellRenderer;
	    };
	    BaseFrameworkFactory.prototype.colDefCellEditor = function (colDef) {
	        return colDef.cellEditor;
	    };
	    BaseFrameworkFactory.prototype.colDefFilter = function (colDef) {
	        return colDef.filter;
	    };
	    BaseFrameworkFactory.prototype.gridOptionsFullWidthCellRenderer = function (gridOptions) {
	        return gridOptions.fullWidthCellRenderer;
	    };
	    BaseFrameworkFactory.prototype.gridOptionsGroupRowRenderer = function (gridOptions) {
	        return gridOptions.groupRowRenderer;
	    };
	    BaseFrameworkFactory.prototype.gridOptionsGroupRowInnerRenderer = function (gridOptions) {
	        return gridOptions.groupRowInnerRenderer;
	    };
	    BaseFrameworkFactory.prototype.setTimeout = function (handler, timeout) {
	        return setTimeout(handler, timeout);
	    };
	    return BaseFrameworkFactory;
	})();
	exports.BaseFrameworkFactory = BaseFrameworkFactory;


/***/ },
/* 94 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
	 * @version v7.0.2
	 * @link http://www.ag-grid.com/
	 * @license MIT
	 */
	var grid_1 = __webpack_require__(2);
	function initialiseAgGridWithAngular1(angular) {
	    var angularModule = angular.module("agGrid", []);
	    angularModule.directive("agGrid", function () {
	        return {
	            restrict: "A",
	            controller: ['$element', '$scope', '$compile', '$attrs', AngularDirectiveController],
	            scope: true
	        };
	    });
	}
	exports.initialiseAgGridWithAngular1 = initialiseAgGridWithAngular1;
	function AngularDirectiveController($element, $scope, $compile, $attrs) {
	    var gridOptions;
	    var quickFilterOnScope;
	    var keyOfGridInScope = $attrs.agGrid;
	    quickFilterOnScope = keyOfGridInScope + '.quickFilterText';
	    gridOptions = $scope.$eval(keyOfGridInScope);
	    if (!gridOptions) {
	        console.warn("WARNING - grid options for ag-Grid not found. Please ensure the attribute ag-grid points to a valid object on the scope");
	        return;
	    }
	    var eGridDiv = $element[0];
	    var gridParams = {
	        $scope: $scope,
	        $compile: $compile,
	        quickFilterOnScope: quickFilterOnScope
	    };
	    var grid = new grid_1.Grid(eGridDiv, gridOptions, gridParams);
	    $scope.$on("$destroy", function () {
	        grid.destroy();
	    });
	}


/***/ },
/* 95 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
	 * @version v7.0.2
	 * @link http://www.ag-grid.com/
	 * @license MIT
	 */
	var componentUtil_1 = __webpack_require__(9);
	var grid_1 = __webpack_require__(2);
	var registered = false;
	function initialiseAgGridWithWebComponents() {
	    // only register to WebComponents once
	    if (registered) {
	        return;
	    }
	    registered = true;
	    if (typeof document === 'undefined' || !document.registerElement) {
	        console.error('ag-Grid: unable to find document.registerElement() function, unable to initialise ag-Grid as a Web Component');
	    }
	    // i don't think this type of extension is possible in TypeScript, so back to
	    // plain Javascript to create this object
	    var AgileGridProto = Object.create(HTMLElement.prototype);
	    // wrap each property with a get and set method, so we can track when changes are done
	    componentUtil_1.ComponentUtil.ALL_PROPERTIES.forEach(function (key) {
	        Object.defineProperty(AgileGridProto, key, {
	            set: function (v) {
	                this.__agGridSetProperty(key, v);
	            },
	            get: function () {
	                return this.__agGridGetProperty(key);
	            }
	        });
	    });
	    var agGridProtoNoType = AgileGridProto;
	    agGridProtoNoType.__agGridSetProperty = function (key, value) {
	        if (!this.__attributes) {
	            this.__attributes = {};
	        }
	        this.__attributes[key] = value;
	        // keeping this consistent with the ng2 onChange, so I can reuse the handling code
	        var changeObject = {};
	        changeObject[key] = { currentValue: value };
	        this.onChange(changeObject);
	    };
	    agGridProtoNoType.onChange = function (changes) {
	        if (this._initialised) {
	            componentUtil_1.ComponentUtil.processOnChange(changes, this._gridOptions, this.api, this.columnApi);
	        }
	    };
	    agGridProtoNoType.__agGridGetProperty = function (key) {
	        if (!this.__attributes) {
	            this.__attributes = {};
	        }
	        return this.__attributes[key];
	    };
	    agGridProtoNoType.setGridOptions = function (options) {
	        var globalEventListener = this.globalEventListener.bind(this);
	        this._gridOptions = componentUtil_1.ComponentUtil.copyAttributesToGridOptions(options, this);
	        var gridParams = {
	            globalEventListener: globalEventListener
	        };
	        this._agGrid = new grid_1.Grid(this, this._gridOptions, gridParams);
	        this.api = options.api;
	        this.columnApi = options.columnApi;
	        this._initialised = true;
	    };
	    // copies all the attributes into this object
	    agGridProtoNoType.createdCallback = function () {
	        for (var i = 0; i < this.attributes.length; i++) {
	            var attribute = this.attributes[i];
	            this.setPropertyFromAttribute(attribute);
	        }
	    };
	    agGridProtoNoType.setPropertyFromAttribute = function (attribute) {
	        var name = toCamelCase(attribute.nodeName);
	        var value = attribute.nodeValue;
	        if (componentUtil_1.ComponentUtil.ALL_PROPERTIES.indexOf(name) >= 0) {
	            this[name] = value;
	        }
	    };
	    agGridProtoNoType.attachedCallback = function (params) { };
	    agGridProtoNoType.detachedCallback = function (params) { };
	    agGridProtoNoType.attributeChangedCallback = function (attributeName) {
	        var attribute = this.attributes[attributeName];
	        this.setPropertyFromAttribute(attribute);
	    };
	    agGridProtoNoType.globalEventListener = function (eventType, event) {
	        var eventLowerCase = eventType.toLowerCase();
	        var browserEvent = new Event(eventLowerCase);
	        var browserEventNoType = browserEvent;
	        browserEventNoType.agGridDetails = event;
	        this.dispatchEvent(browserEvent);
	        var callbackMethod = 'on' + eventLowerCase;
	        if (typeof this[callbackMethod] === 'function') {
	            this[callbackMethod](browserEvent);
	        }
	    };
	    // finally, register
	    document.registerElement('ag-grid', { prototype: AgileGridProto });
	}
	exports.initialiseAgGridWithWebComponents = initialiseAgGridWithWebComponents;
	function toCamelCase(myString) {
	    if (typeof myString === 'string') {
	        var result = myString.replace(/-([a-z])/g, function (g) {
	            return g[1].toUpperCase();
	        });
	        return result;
	    }
	    else {
	        return myString;
	    }
	}


/***/ },
/* 96 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
	 * @version v7.0.2
	 * @link http://www.ag-grid.com/
	 * @license MIT
	 */
	var utils_1 = __webpack_require__(7);
	var TabbedLayout = (function () {
	    function TabbedLayout(params) {
	        var _this = this;
	        this.items = [];
	        this.params = params;
	        this.eGui = document.createElement('div');
	        this.eGui.innerHTML = TabbedLayout.TEMPLATE;
	        this.eHeader = this.eGui.querySelector('#tabHeader');
	        this.eBody = this.eGui.querySelector('#tabBody');
	        utils_1.Utils.addCssClass(this.eGui, params.cssClass);
	        if (params.items) {
	            params.items.forEach(function (item) { return _this.addItem(item); });
	        }
	    }
	    TabbedLayout.prototype.setAfterAttachedParams = function (params) {
	        this.afterAttachedParams = params;
	    };
	    TabbedLayout.prototype.getMinWidth = function () {
	        var eDummyContainer = document.createElement('span');
	        // position fixed, so it isn't restricted to the boundaries of the parent
	        eDummyContainer.style.position = 'fixed';
	        // we put the dummy into the body container, so it will inherit all the
	        // css styles that the real cells are inheriting
	        this.eGui.appendChild(eDummyContainer);
	        var minWidth = 0;
	        this.items.forEach(function (itemWrapper) {
	            utils_1.Utils.removeAllChildren(eDummyContainer);
	            var eClone = itemWrapper.tabbedItem.body.cloneNode(true);
	            eDummyContainer.appendChild(eClone);
	            if (minWidth < eDummyContainer.offsetWidth) {
	                minWidth = eDummyContainer.offsetWidth;
	            }
	        });
	        this.eGui.removeChild(eDummyContainer);
	        return minWidth;
	    };
	    TabbedLayout.prototype.showFirstItem = function () {
	        if (this.items.length > 0) {
	            this.showItemWrapper(this.items[0]);
	        }
	    };
	    TabbedLayout.prototype.addItem = function (item) {
	        var eHeaderButton = document.createElement('span');
	        eHeaderButton.appendChild(item.title);
	        utils_1.Utils.addCssClass(eHeaderButton, 'ag-tab');
	        this.eHeader.appendChild(eHeaderButton);
	        var wrapper = {
	            tabbedItem: item,
	            eHeaderButton: eHeaderButton
	        };
	        this.items.push(wrapper);
	        eHeaderButton.addEventListener('click', this.showItemWrapper.bind(this, wrapper));
	    };
	    TabbedLayout.prototype.showItem = function (tabbedItem) {
	        var itemWrapper = utils_1.Utils.find(this.items, function (itemWrapper) {
	            return itemWrapper.tabbedItem === tabbedItem;
	        });
	        if (itemWrapper) {
	            this.showItemWrapper(itemWrapper);
	        }
	    };
	    TabbedLayout.prototype.showItemWrapper = function (wrapper) {
	        if (this.params.onItemClicked) {
	            this.params.onItemClicked({ item: wrapper.tabbedItem });
	        }
	        if (this.activeItem === wrapper) {
	            utils_1.Utils.callIfPresent(this.params.onActiveItemClicked);
	            return;
	        }
	        utils_1.Utils.removeAllChildren(this.eBody);
	        this.eBody.appendChild(wrapper.tabbedItem.body);
	        if (this.activeItem) {
	            utils_1.Utils.removeCssClass(this.activeItem.eHeaderButton, 'ag-tab-selected');
	        }
	        utils_1.Utils.addCssClass(wrapper.eHeaderButton, 'ag-tab-selected');
	        this.activeItem = wrapper;
	        if (wrapper.tabbedItem.afterAttachedCallback) {
	            wrapper.tabbedItem.afterAttachedCallback(this.afterAttachedParams);
	        }
	    };
	    TabbedLayout.prototype.getGui = function () {
	        return this.eGui;
	    };
	    TabbedLayout.TEMPLATE = '<div>' +
	        '<div id="tabHeader" class="ag-tab-header"></div>' +
	        '<div id="tabBody" class="ag-tab-body"></div>' +
	        '</div>';
	    return TabbedLayout;
	})();
	exports.TabbedLayout = TabbedLayout;


/***/ },
/* 97 */
/***/ function(module, exports) {

	/**
	 * ag-grid - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components
	 * @version v7.0.2
	 * @link http://www.ag-grid.com/
	 * @license MIT
	 */
	var VerticalStack = (function () {
	    function VerticalStack() {
	        this.isLayoutPanel = true;
	        this.childPanels = [];
	        this.eGui = document.createElement('div');
	        this.eGui.style.height = '100%';
	    }
	    VerticalStack.prototype.addPanel = function (panel, height) {
	        var component;
	        if (panel.isLayoutPanel) {
	            this.childPanels.push(panel);
	            component = panel.getGui();
	        }
	        else {
	            component = panel;
	        }
	        if (height) {
	            component.style.height = height;
	        }
	        this.eGui.appendChild(component);
	    };
	    VerticalStack.prototype.getGui = function () {
	        return this.eGui;
	    };
	    VerticalStack.prototype.doLayout = function () {
	        for (var i = 0; i < this.childPanels.length; i++) {
	            this.childPanels[i].doLayout();
	        }
	    };
	    return VerticalStack;
	})();
	exports.VerticalStack = VerticalStack;


/***/ }
/******/ ])
});
;